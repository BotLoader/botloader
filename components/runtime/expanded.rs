#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
use std::{cell::RefCell, rc::Rc, sync::{Arc, RwLock}};
use common::DiscordConfig;
use deno_core::{op2, Extension, Op, OpState, ResourceId, ResourceTable};
use guild_logger::{entry::CreateLogEntry, GuildLogSender};
use runtime_models::internal::script::{ScriptMeta, SettingsOptionValue};
use stores::{config::PremiumSlotTier, Db};
use tokio::sync::mpsc;
use tracing::info;
use twilight_model::id::marker::GuildMarker;
use twilight_model::id::Id;
use vm::{AnyError, JsValue};
use crate::limits::RateLimiters;
pub mod extensions {
    use std::{cell::RefCell, rc::Rc};
    use deno_core::OpState;
    use twilight_model::{
        channel::Channel,
        id::{
            marker::{ChannelMarker, GenericMarker},
            Id,
        },
    };
    use vm::AnyError;
    use crate::RuntimeContext;
    use self::discord::{discord_request, not_found_error};
    pub mod base64 {
        use deno_core::{error::AnyError, op2, ByteString, ToJsBuffer};
        #[allow(non_camel_case_types)]
        struct op_base64_decode {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_base64_decode {
            const NAME: &'static str = "op_base64_decode";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_base64_decode".as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    ("op_base64_decode", ::deno_core::FastStaticString::new(s))
                },
                false,
                false,
                1usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_base64_decode {
            pub const fn name() -> &'static str {
                "op_base64_decode"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let result = {
                    let arg0 = args.get(0usize as i32);
                    let arg0 = deno_core::_ops::to_string(&mut scope, &arg0);
                    Self::call(arg0)
                };
                match result {
                    Ok(result) => {
                        match deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                            deno_core::_ops::RustToV8Marker::<
                                deno_core::_ops::SerdeMarker,
                                _,
                            >::from(result),
                            &mut scope,
                        ) {
                            Ok(v) => rv.set(v),
                            Err(rv_err) => {
                                let msg = deno_core::v8::String::new(
                                        &mut scope,
                                        &{
                                            let res = ::alloc::fmt::format(
                                                format_args!("{0}", deno_core::anyhow::Error::from(rv_err)),
                                            );
                                            res
                                        },
                                    )
                                    .unwrap();
                                let exc = deno_core::v8::Exception::type_error(
                                    &mut scope,
                                    msg,
                                );
                                scope.throw_exception(exc);
                                return 1;
                            }
                        }
                    }
                    Err(err) => {
                        let opctx = unsafe {
                            &*(deno_core::v8::Local::<
                                deno_core::v8::External,
                            >::cast(args.data())
                                .value() as *const deno_core::_ops::OpCtx)
                        };
                        let err = err.into();
                        let exception = deno_core::error::to_v8_error(
                            &mut scope,
                            opctx.get_error_class_fn,
                            &err,
                        );
                        scope.throw_exception(exception);
                        return 1;
                    }
                };
                return 0;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_slow(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_slow(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else {
                    deno_core::_ops::dispatch_metrics_slow(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            fn call(input: String) -> Result<ToJsBuffer, AnyError> {
                let mut s = input.into_bytes();
                let decoded_len = forgiving_base64_decode_inplace(&mut s)?;
                s.truncate(decoded_len);
                Ok(s.into())
            }
        }
        #[allow(non_camel_case_types)]
        struct op_base64_atob {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_base64_atob {
            const NAME: &'static str = "op_base64_atob";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_base64_atob".as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    ("op_base64_atob", ::deno_core::FastStaticString::new(s))
                },
                false,
                false,
                1usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_base64_atob {
            pub const fn name() -> &'static str {
                "op_base64_atob"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let result = {
                    let arg0 = args.get(0usize as i32);
                    let arg0 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg0,
                    ) {
                        Ok(t) => t,
                        Err(arg0_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg0_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    Self::call(arg0)
                };
                match result {
                    Ok(result) => {
                        match deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                            deno_core::_ops::RustToV8Marker::<
                                deno_core::_ops::SerdeMarker,
                                _,
                            >::from(result),
                            &mut scope,
                        ) {
                            Ok(v) => rv.set(v),
                            Err(rv_err) => {
                                let msg = deno_core::v8::String::new(
                                        &mut scope,
                                        &{
                                            let res = ::alloc::fmt::format(
                                                format_args!("{0}", deno_core::anyhow::Error::from(rv_err)),
                                            );
                                            res
                                        },
                                    )
                                    .unwrap();
                                let exc = deno_core::v8::Exception::type_error(
                                    &mut scope,
                                    msg,
                                );
                                scope.throw_exception(exc);
                                return 1;
                            }
                        }
                    }
                    Err(err) => {
                        let opctx = unsafe {
                            &*(deno_core::v8::Local::<
                                deno_core::v8::External,
                            >::cast(args.data())
                                .value() as *const deno_core::_ops::OpCtx)
                        };
                        let err = err.into();
                        let exception = deno_core::error::to_v8_error(
                            &mut scope,
                            opctx.get_error_class_fn,
                            &err,
                        );
                        scope.throw_exception(exception);
                        return 1;
                    }
                };
                return 0;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_slow(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_slow(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else {
                    deno_core::_ops::dispatch_metrics_slow(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            fn call(mut s: ByteString) -> Result<ByteString, AnyError> {
                let decoded_len = forgiving_base64_decode_inplace(&mut s)?;
                s.truncate(decoded_len);
                Ok(s)
            }
        }
        /// See <https://infra.spec.whatwg.org/#forgiving-base64>
        #[inline]
        fn forgiving_base64_decode_inplace(input: &mut [u8]) -> Result<usize, AnyError> {
            let decoded = base64_simd::forgiving_decode_inplace(input)
                .map_err(|_| ::anyhow::__private::must_use({
                    let error = ::anyhow::__private::format_err(
                        format_args!("Failed to decode base64"),
                    );
                    error
                }))?;
            Ok(decoded.len())
        }
        #[allow(non_camel_case_types)]
        struct op_base64_encode {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_base64_encode {
            const NAME: &'static str = "op_base64_encode";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_base64_encode".as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    ("op_base64_encode", ::deno_core::FastStaticString::new(s))
                },
                false,
                false,
                1usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_base64_encode {
            pub const fn name() -> &'static str {
                "op_base64_encode"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let result = {
                    let arg0 = args.get(0usize as i32);
                    let mut arg0_temp;
                    arg0_temp = match unsafe {
                        deno_core::_ops::to_v8_slice::<u8>(arg0)
                    } {
                        Ok(arg0) => arg0,
                        Err(arg0_err) => {
                            let mut scope = unsafe {
                                deno_core::v8::CallbackScope::new(&*info)
                            };
                            let msg = deno_core::v8::String::new_from_one_byte(
                                    &mut scope,
                                    arg0_err.as_bytes(),
                                    deno_core::v8::NewStringType::Normal,
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg0 = arg0_temp.as_ref();
                    Self::call(arg0)
                };
                match deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                    result,
                    &mut scope,
                ) {
                    Ok(v) => rv.set(v),
                    Err(rv_err) => {
                        let msg = deno_core::v8::String::new(
                                &mut scope,
                                &{
                                    let res = ::alloc::fmt::format(
                                        format_args!("{0}", deno_core::anyhow::Error::from(rv_err)),
                                    );
                                    res
                                },
                            )
                            .unwrap();
                        let exc = deno_core::v8::Exception::type_error(&mut scope, msg);
                        scope.throw_exception(exc);
                        return 1;
                    }
                };
                return 0;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_slow(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_slow(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else {
                    deno_core::_ops::dispatch_metrics_slow(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            fn call(s: &[u8]) -> String {
                forgiving_base64_encode(s)
            }
        }
        #[allow(non_camel_case_types)]
        struct op_base64_btoa {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_base64_btoa {
            const NAME: &'static str = "op_base64_btoa";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_base64_btoa".as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    ("op_base64_btoa", ::deno_core::FastStaticString::new(s))
                },
                false,
                false,
                1usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_base64_btoa {
            pub const fn name() -> &'static str {
                "op_base64_btoa"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let result = {
                    let arg0 = args.get(0usize as i32);
                    let arg0 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg0,
                    ) {
                        Ok(t) => t,
                        Err(arg0_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg0_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    Self::call(arg0)
                };
                match deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                    result,
                    &mut scope,
                ) {
                    Ok(v) => rv.set(v),
                    Err(rv_err) => {
                        let msg = deno_core::v8::String::new(
                                &mut scope,
                                &{
                                    let res = ::alloc::fmt::format(
                                        format_args!("{0}", deno_core::anyhow::Error::from(rv_err)),
                                    );
                                    res
                                },
                            )
                            .unwrap();
                        let exc = deno_core::v8::Exception::type_error(&mut scope, msg);
                        scope.throw_exception(exc);
                        return 1;
                    }
                };
                return 0;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_slow(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_slow(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else {
                    deno_core::_ops::dispatch_metrics_slow(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            fn call(s: ByteString) -> String {
                forgiving_base64_encode(s.as_ref())
            }
        }
        /// See <https://infra.spec.whatwg.org/#forgiving-base64>
        #[inline]
        fn forgiving_base64_encode(s: &[u8]) -> String {
            base64_simd::STANDARD.encode_to_string(s)
        }
    }
    pub mod console {
        use deno_core::{op2, OpState};
        use guild_logger::entry::CreateLogEntry;
        use runtime_models::internal::console::ConsoleLogMessage;
        use crate::RuntimeContext;
        ///
        /// An extension for use with the Deno JS runtime.
        /// To use it, provide it as an argument when instantiating your runtime:
        ///
        /// ```rust,ignore
        /// use deno_core::{ JsRuntime, RuntimeOptions };
        ///
        ///let mut extensions = vec![bl_console::init_ops_and_esm()];
        /// let mut js_runtime = JsRuntime::new(RuntimeOptions {
        ///   extensions,
        ///   ..Default::default()
        /// });
        /// ```
        ///
        #[allow(non_camel_case_types)]
        pub struct bl_console {}
        impl bl_console {
            fn ext() -> ::deno_core::Extension {
                #[allow(unused_imports)]
                use ::deno_core::Op;
                ::deno_core::Extension {
                    name: "bl_console",
                    deps: &[],
                    js_files: {
                        const JS: &'static [::deno_core::ExtensionFileSource] = &[];
                        ::std::borrow::Cow::Borrowed(JS)
                    },
                    esm_files: {
                        const JS: &'static [::deno_core::ExtensionFileSource] = &[];
                        ::std::borrow::Cow::Borrowed(JS)
                    },
                    lazy_loaded_esm_files: {
                        const JS: &'static [::deno_core::ExtensionFileSource] = &[];
                        ::std::borrow::Cow::Borrowed(JS)
                    },
                    esm_entry_point: {
                        const V: ::std::option::Option<&'static ::std::primitive::str> = ::std::option::Option::None;
                        V
                    },
                    ops: ::std::borrow::Cow::Borrowed(&[op_botloader_log::DECL]),
                    external_references: ::std::borrow::Cow::Borrowed(&[]),
                    global_template_middleware: ::std::option::Option::None,
                    global_object_middleware: ::std::option::Option::None,
                    op_state_fn: ::std::option::Option::None,
                    middleware_fn: ::std::option::Option::None,
                    enabled: true,
                }
            }
            #[inline(always)]
            #[allow(unused_variables)]
            fn with_ops_fn(ext: &mut ::deno_core::Extension) {}
            #[inline(always)]
            #[allow(unused_variables)]
            fn with_state_and_middleware(ext: &mut ::deno_core::Extension) {}
            #[inline(always)]
            #[allow(unused_variables)]
            #[allow(clippy::redundant_closure_call)]
            fn with_customizer(ext: &mut ::deno_core::Extension) {}
            #[allow(dead_code)]
            /// Initialize this extension for runtime or snapshot creation. Use this
            /// function if the runtime or snapshot is not created from a (separate)
            /// snapshot, or that snapshot does not contain this extension. Otherwise
            /// use `init_ops()` instead.
            ///
            /// # Returns
            /// an Extension object that can be used during instantiation of a JsRuntime
            pub fn init_ops_and_esm() -> ::deno_core::Extension {
                let mut ext = Self::ext();
                Self::with_ops_fn(&mut ext);
                Self::with_state_and_middleware(&mut ext);
                Self::with_customizer(&mut ext);
                ext
            }
            #[allow(dead_code)]
            /// Initialize this extension for runtime or snapshot creation, excluding
            /// its JavaScript sources and evaluation. This is used when the runtime
            /// or snapshot is created from a (separate) snapshot which includes this
            /// extension in order to avoid evaluating the JavaScript twice.
            ///
            /// # Returns
            /// an Extension object that can be used during instantiation of a JsRuntime
            pub fn init_ops() -> ::deno_core::Extension {
                let mut ext = Self::ext();
                Self::with_ops_fn(&mut ext);
                Self::with_state_and_middleware(&mut ext);
                Self::with_customizer(&mut ext);
                ext.js_files = ::std::borrow::Cow::Borrowed(&[]);
                ext.esm_files = ::std::borrow::Cow::Borrowed(&[]);
                ext.esm_entry_point = ::std::option::Option::None;
                ext
            }
        }
        #[allow(non_camel_case_types)]
        pub struct op_botloader_log {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_botloader_log {
            const NAME: &'static str = "op_botloader_log";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_botloader_log".as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    ("op_botloader_log", ::deno_core::FastStaticString::new(s))
                },
                false,
                false,
                2usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_botloader_log {
            pub const fn name() -> &'static str {
                "op_botloader_log"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(0usize as i32);
                    let arg1 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg1,
                    ) {
                        Ok(t) => t,
                        Err(arg1_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg1_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg0 = &mut ::std::cell::RefCell::borrow_mut(&opstate);
                    Self::call(arg0, arg1)
                };
                deno_core::_ops::RustToV8RetVal::to_v8_rv(result, &mut rv);
                return 0;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_slow(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_slow(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else {
                    deno_core::_ops::dispatch_metrics_slow(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub fn call(state: &mut OpState, args: ConsoleLogMessage) {
                let (name, line_col) = if let (Some(orig_name), Some(line)) = (
                    args.file_name,
                    args.line_number,
                ) {
                    let col = args.col_number.unwrap_or_default();
                    (orig_name, Some((line, col)))
                } else {
                    (String::new(), None)
                };
                let ctx = state.borrow::<RuntimeContext>();
                ctx.guild_logger
                    .log(CreateLogEntry::script_console(args.message, name, line_col));
            }
        }
    }
    pub mod discord {
        use anyhow::anyhow;
        use chrono::TimeZone;
        use deno_core::{
            error::{custom_error, get_custom_error_class},
            op2, OpState,
        };
        use futures::TryFutureExt;
        use runtime_models::{
            discord::{
                channel::{PermissionOverwrite, PermissionOverwriteType},
                guild::Guild, message::SendEmoji, util::AuditLogExtras,
            },
            internal::{
                channel::{
                    CreateChannel, CreateForumThread, CreateThread,
                    CreateThreadFromMessage, EditChannel, EditGuildChannelPosition,
                    ForumThreadResponse, GuildChannel, ListThreadMembersRequest,
                    ListThreadsRequest, ThreadMember, ThreadsListing, UpdateThread,
                },
                events::VoiceState, interactions::InteractionCallback,
                invite::CreateInviteFields, member::{Ban, UpdateGuildMemberFields},
                messages::{
                    Message, OpCreateChannelMessage, OpCreateFollowUpMessage,
                    OpDeleteMessage, OpDeleteMessagesBulk, OpEditChannelMessage,
                    OpGetMessages,
                },
                misc_op::{CreateBanFields, GetReactionsFields},
                user::User,
            },
            ops::{handle_async_op, EasyOpsASync, EasyOpsHandlerASync},
        };
        use std::{
            borrow::Cow, collections::VecDeque, future::Future, time::{Duration, Instant},
        };
        use std::{cell::RefCell, rc::Rc};
        use tracing::{info, warn};
        use twilight_http::error::ErrorType;
        use twilight_http::request::AuditLogReason;
        use twilight_http::{
            api_error::{ApiError, GeneralApiError},
            response::StatusCode,
        };
        use twilight_model::id::marker::{
            GenericMarker, InteractionMarker, MessageMarker, RoleMarker, TagMarker,
        };
        use twilight_model::id::Id;
        use twilight_model::{
            guild::Permissions, id::marker::{ChannelMarker, UserMarker},
        };
        use vm::AnyError;
        use super::{
            get_guild_channel, parse_discord_id, parse_get_guild_channel,
            parse_str_snowflake_id,
        };
        use crate::{get_rt_ctx, limits::RateLimiters, RuntimeContext};
        ///
        /// An extension for use with the Deno JS runtime.
        /// To use it, provide it as an argument when instantiating your runtime:
        ///
        /// ```rust,ignore
        /// use deno_core::{ JsRuntime, RuntimeOptions };
        ///
        ///let mut extensions = vec![bl_discord::init_ops_and_esm()];
        /// let mut js_runtime = JsRuntime::new(RuntimeOptions {
        ///   extensions,
        ///   ..Default::default()
        /// });
        /// ```
        ///
        #[allow(non_camel_case_types)]
        pub struct bl_discord {}
        impl bl_discord {
            fn ext() -> ::deno_core::Extension {
                #[allow(unused_imports)]
                use ::deno_core::Op;
                ::deno_core::Extension {
                    name: "bl_discord",
                    deps: &[],
                    js_files: {
                        const JS: &'static [::deno_core::ExtensionFileSource] = &[];
                        ::std::borrow::Cow::Borrowed(JS)
                    },
                    esm_files: {
                        const JS: &'static [::deno_core::ExtensionFileSource] = &[];
                        ::std::borrow::Cow::Borrowed(JS)
                    },
                    lazy_loaded_esm_files: {
                        const JS: &'static [::deno_core::ExtensionFileSource] = &[];
                        ::std::borrow::Cow::Borrowed(JS)
                    },
                    esm_entry_point: {
                        const V: ::std::option::Option<&'static ::std::primitive::str> = ::std::option::Option::None;
                        V
                    },
                    ops: ::std::borrow::Cow::Borrowed(
                        &[
                            op_discord_get_invites::DECL,
                            op_discord_get_invite::DECL,
                            op_discord_delete_invite::DECL,
                            op_discord_create_reaction::DECL,
                            op_discord_delete_own_reaction::DECL,
                            op_discord_delete_user_reaction::DECL,
                            op_discord_get_reactions::DECL,
                            op_discord_delete_all_reactions::DECL,
                            op_discord_delete_all_reactions_for_emoji::DECL,
                            op_discord_get_role::DECL,
                            op_discord_get_roles::DECL,
                            op_discord_get_channel::DECL,
                            op_discord_get_channels::DECL,
                            op_discord_create_channel::DECL,
                            op_discord_edit_channel::DECL,
                            op_discord_delete_channel::DECL,
                            op_discord_update_channel_permission::DECL,
                            op_discord_delete_channel_permission::DECL,
                            op_discord_get_channel_invites::DECL,
                            op_discord_create_channel_invite::DECL,
                            op_discord_get_voice_states::DECL,
                            op_discord_get_channel_pins::DECL,
                            op_discord_create_pin::DECL,
                            op_discord_delete_pin::DECL,
                            op_discord_remove_member::DECL,
                            op_discord_get_members::DECL,
                            op_discord_update_member::DECL,
                            op_discord_add_member_role::DECL,
                            op_discord_remove_member_role::DECL,
                            op_discord_interaction_callback::DECL,
                            op_discord_interaction_get_original_response::DECL,
                            op_discord_interaction_edit_original_response::DECL,
                            op_discord_interaction_delete_original::DECL,
                            op_discord_interaction_followup_message::DECL,
                            op_discord_interaction_get_followup_message::DECL,
                            op_discord_interaction_edit_followup_message::DECL,
                            op_discord_interaction_delete_followup_message::DECL,
                            op_discord_create_ban::DECL,
                            op_discord_get_ban::DECL,
                            op_discord_get_bans::DECL,
                            op_discord_delete_ban::DECL,
                            op_discord_get_member_permissions::DECL,
                            op_easyops_async::DECL,
                        ],
                    ),
                    external_references: ::std::borrow::Cow::Borrowed(&[]),
                    global_template_middleware: ::std::option::Option::None,
                    global_object_middleware: ::std::option::Option::None,
                    op_state_fn: ::std::option::Option::None,
                    middleware_fn: ::std::option::Option::None,
                    enabled: true,
                }
            }
            #[inline(always)]
            #[allow(unused_variables)]
            fn with_ops_fn(ext: &mut ::deno_core::Extension) {}
            #[inline(always)]
            #[allow(unused_variables)]
            fn with_state_and_middleware(ext: &mut ::deno_core::Extension) {
                ext
                    .op_state_fn = ::std::option::Option::Some(
                    ::std::boxed::Box::new(|state| {
                        state
                            .put(DiscordOpsState {
                                recent_bad_requests: VecDeque::new(),
                            });
                    }),
                );
            }
            #[inline(always)]
            #[allow(unused_variables)]
            #[allow(clippy::redundant_closure_call)]
            fn with_customizer(ext: &mut ::deno_core::Extension) {}
            #[allow(dead_code)]
            /// Initialize this extension for runtime or snapshot creation. Use this
            /// function if the runtime or snapshot is not created from a (separate)
            /// snapshot, or that snapshot does not contain this extension. Otherwise
            /// use `init_ops()` instead.
            ///
            /// # Returns
            /// an Extension object that can be used during instantiation of a JsRuntime
            pub fn init_ops_and_esm() -> ::deno_core::Extension {
                let mut ext = Self::ext();
                Self::with_ops_fn(&mut ext);
                Self::with_state_and_middleware(&mut ext);
                Self::with_customizer(&mut ext);
                ext
            }
            #[allow(dead_code)]
            /// Initialize this extension for runtime or snapshot creation, excluding
            /// its JavaScript sources and evaluation. This is used when the runtime
            /// or snapshot is created from a (separate) snapshot which includes this
            /// extension in order to avoid evaluating the JavaScript twice.
            ///
            /// # Returns
            /// an Extension object that can be used during instantiation of a JsRuntime
            pub fn init_ops() -> ::deno_core::Extension {
                let mut ext = Self::ext();
                Self::with_ops_fn(&mut ext);
                Self::with_state_and_middleware(&mut ext);
                Self::with_customizer(&mut ext);
                ext.js_files = ::std::borrow::Cow::Borrowed(&[]);
                ext.esm_files = ::std::borrow::Cow::Borrowed(&[]);
                ext.esm_entry_point = ::std::option::Option::None;
                ext
            }
        }
        struct DiscordOpsState {
            recent_bad_requests: VecDeque<Instant>,
        }
        impl DiscordOpsState {
            fn add_failed_req(&mut self) {
                self.recent_bad_requests.push_back(Instant::now());
                while self.recent_bad_requests.len() > 29 {
                    self.recent_bad_requests.pop_front();
                }
            }
            fn should_suspend_guild(&self) -> bool {
                if self.recent_bad_requests.len() < 29 {
                    return false;
                }
                self.recent_bad_requests[0].elapsed() < Duration::from_secs(60)
            }
        }
        pub async fn discord_request<T: Send + Sync + 'static>(
            state: &Rc<RefCell<OpState>>,
            f: impl Future<Output = Result<T, twilight_http::Error>> + Send + 'static,
        ) -> Result<T, AnyError> {
            let rt_handle = {
                let state = state.borrow();
                let rt_ctx: &RuntimeContext = state.borrow();
                rt_ctx.main_tokio_runtime.clone()
            };
            rt_handle
                .spawn(f)
                .await
                .unwrap()
                .map_err(|err| handle_discord_error(state, err))
        }
        pub async fn discord_request_with_extra_error<T: Send + Sync + 'static>(
            state: &Rc<RefCell<OpState>>,
            f: impl Future<
                Output = Result<Result<T, twilight_http::Error>, AnyError>,
            > + Send + 'static,
        ) -> Result<T, AnyError> {
            let rt_handle = {
                let state = state.borrow();
                let rt_ctx: &RuntimeContext = state.borrow();
                rt_ctx.main_tokio_runtime.clone()
            };
            rt_handle
                .spawn(f)
                .await
                .unwrap()?
                .map_err(|err| handle_discord_error(state, err))
        }
        pub fn handle_discord_error(
            state: &Rc<RefCell<OpState>>,
            err: twilight_http::Error,
        ) -> AnyError {
            let kind = err.kind();
            if let ErrorType::Response { status, .. } = kind {
                let raw = status.get();
                if raw == 401 || raw == 403 || raw == 429 {
                    let mut rc = state.borrow_mut();
                    let dstate = rc.borrow_mut::<DiscordOpsState>();
                    dstate.add_failed_req();
                    if dstate.should_suspend_guild() {
                        let handle = rc.borrow::<vm::vm::VmShutdownHandle>().clone();
                        let rt_ctx = rc.borrow::<RuntimeContext>().clone();
                        drop(rc);
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event components/runtime/src/extensions/discord.rs:208",
                                        "runtime::extensions::discord",
                                        ::tracing::Level::WARN,
                                        ::core::option::Option::Some(
                                            "components/runtime/src/extensions/discord.rs",
                                        ),
                                        ::core::option::Option::Some(208u32),
                                        ::core::option::Option::Some(
                                            "runtime::extensions::discord",
                                        ),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message", "guild_id"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::WARN
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::WARN
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                    if match ::tracing::Level::WARN {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                use ::tracing::log;
                                                let level = match ::tracing::Level::WARN {
                                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                    _ => ::tracing::log::Level::Trace,
                                                };
                                                if level <= log::max_level() {
                                                    let meta = __CALLSITE.metadata();
                                                    let log_meta = log::Metadata::builder()
                                                        .level(level)
                                                        .target(meta.target())
                                                        .build();
                                                    let logger = log::logger();
                                                    if logger.enabled(&log_meta) {
                                                        ::tracing::__macro_support::__tracing_log(
                                                            meta,
                                                            logger,
                                                            log_meta,
                                                            &value_set,
                                                        )
                                                    }
                                                }
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!(
                                                            "guild hit >30 invalid requests within 60s, suspending it",
                                                        ) as &dyn Value,
                                                    ),
                                                ),
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &rt_ctx.guild_id.get() as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                                if match ::tracing::Level::WARN {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                } <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match ::tracing::Level::WARN {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let meta = __CALLSITE.metadata();
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(meta.target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    ::tracing::__macro_support::__tracing_log(
                                                        meta,
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                                            __CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &::core::iter::Iterator::next(&mut iter)
                                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                                            ::core::option::Option::Some(
                                                                                &format_args!(
                                                                                    "guild hit >30 invalid requests within 60s, suspending it",
                                                                                ) as &dyn Value,
                                                                            ),
                                                                        ),
                                                                        (
                                                                            &::core::iter::Iterator::next(&mut iter)
                                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                                            ::core::option::Option::Some(
                                                                                &rt_ctx.guild_id.get() as &dyn Value,
                                                                            ),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            }
                        };
                        handle
                            .shutdown_vm(
                                vm::vm::ShutdownReason::DiscordInvalidRequestsRatelimit,
                                false,
                            );
                    }
                }
            }
            match kind {
                ErrorType::Response {
                    error: ApiError::General(GeneralApiError { code, message, .. }),
                    status,
                    ..
                } => error_from_code(*status, *code, message),
                _ => err.into(),
            }
        }
        pub fn error_from_code(
            resp_code: StatusCode,
            code: u64,
            message: &str,
        ) -> AnyError {
            match resp_code.get() {
                404 => {
                    not_found_error({
                        let res = ::alloc::fmt::format(
                            format_args!("{0}: {1}", code, message),
                        );
                        res
                    })
                }
                403 => {
                    custom_error(
                        "DiscordPermissionsError",
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("{0}: {1}", code, message),
                            );
                            res
                        },
                    )
                }
                400..=499 => {
                    match code {
                        30001..=40000 => {
                            custom_error(
                                "DiscordLimitReachedError",
                                {
                                    let res = ::alloc::fmt::format(
                                        format_args!("{0}: {1}", code, message),
                                    );
                                    res
                                },
                            )
                        }
                        _ => {
                            custom_error(
                                "DiscordGenericErrorResponse",
                                {
                                    let res = ::alloc::fmt::format(
                                        format_args!("{0}: {1}", code, message),
                                    );
                                    res
                                },
                            )
                        }
                    }
                }
                status @ 500..=599 => {
                    custom_error(
                        "DiscordServerErrorResponse",
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "Discord failed handling the request (5xx response), http status: {0}, code: {1}, message: {2}",
                                    status,
                                    code,
                                    message,
                                ),
                            );
                            res
                        },
                    )
                }
                other => {
                    custom_error(
                        "DiscordGenericErrorResponse",
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "An error occurred with the discord API, http status: {0}, code: {1}, message: {2}",
                                    other,
                                    code,
                                    message,
                                ),
                            );
                            res
                        },
                    )
                }
            }
        }
        const DISCORD_NOT_FOUND_CLASS_NAME: &str = "DiscordNotFoundError";
        pub fn not_found_error(message: impl Into<Cow<'static, str>>) -> AnyError {
            custom_error(DISCORD_NOT_FOUND_CLASS_NAME, message)
        }
        #[allow(non_camel_case_types)]
        pub struct op_easyops_async {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_easyops_async {
            const NAME: &'static str = "op_easyops_async";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_easyops_async".as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    ("op_easyops_async", ::deno_core::FastStaticString::new(s))
                },
                true,
                false,
                3usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_easyops_async {
            pub const fn name() -> &'static str {
                "op_easyops_async"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg1,
                    ) {
                        Ok(t) => t,
                        Err(arg1_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg1_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                            deno_core::_ops::RustToV8Marker::<
                                deno_core::_ops::SerdeMarker,
                                _,
                            >::from(result),
                            scope,
                        )
                    },
                ) {
                    match result {
                        Ok(result) => {
                            match deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                                deno_core::_ops::RustToV8Marker::<
                                    deno_core::_ops::SerdeMarker,
                                    _,
                                >::from(result),
                                &mut scope,
                            ) {
                                Ok(v) => rv.set(v),
                                Err(rv_err) => {
                                    let msg = deno_core::v8::String::new(
                                            &mut scope,
                                            &{
                                                let res = ::alloc::fmt::format(
                                                    format_args!("{0}", deno_core::anyhow::Error::from(rv_err)),
                                                );
                                                res
                                            },
                                        )
                                        .unwrap();
                                    let exc = deno_core::v8::Exception::type_error(
                                        &mut scope,
                                        msg,
                                    );
                                    scope.throw_exception(exc);
                                    return 1;
                                }
                            }
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state: Rc<RefCell<OpState>>,
                op: EasyOpsASync,
            ) -> Result<serde_json::Value, AnyError> {
                let handler = EasyOpsHandler { state };
                handle_async_op(&handler, op).await
            }
        }
        struct EasyOpsHandler {
            state: Rc<RefCell<OpState>>,
        }
        impl EasyOpsHandlerASync for EasyOpsHandler {
            async fn discord_get_guild(&self, _arg: ()) -> Result<Guild, anyhow::Error> {
                let rt_ctx = get_rt_ctx(&self.state);
                match rt_ctx
                    .bot_state
                    .get_guild(rt_ctx.guild_id)
                    .map_err(|err| ::anyhow::Error::msg({
                        let res = ::alloc::fmt::format(
                            format_args!("error calling state api: {0}", err),
                        );
                        res
                    }))
                    .await?
                {
                    Some(c) => Ok(c.into()),
                    None => {
                        Err(
                            ::anyhow::__private::must_use({
                                let error = ::anyhow::__private::format_err(
                                    format_args!("guild not in state"),
                                );
                                error
                            }),
                        )
                    }
                }
            }
            async fn discord_get_message(
                &self,
                (channel_id_raw, message_id_raw): (String, String),
            ) -> Result<Message, anyhow::Error> {
                let rt_ctx = get_rt_ctx(&self.state);
                let channel = parse_get_guild_channel(
                        &self.state,
                        &rt_ctx,
                        &channel_id_raw,
                    )
                    .await?;
                let message_id = parse_discord_id(&message_id_raw)?;
                discord_request(
                        &self.state,
                        async move {
                            rt_ctx
                                .discord_config
                                .client
                                .message(channel.id, message_id)
                                .await
                        },
                    )
                    .await?
                    .model()
                    .await?
                    .try_into()
            }
            async fn discord_get_messages(
                &self,
                args: OpGetMessages,
            ) -> Result<Vec<Message>, anyhow::Error> {
                let rt_ctx = get_rt_ctx(&self.state);
                let channel = parse_get_guild_channel(
                        &self.state,
                        &rt_ctx,
                        &args.channel_id,
                    )
                    .await?;
                let limit = if let Some(limit) = args.limit {
                    limit.clamp(1, 100)
                } else {
                    50
                };
                let before_id: Option<Id<MessageMarker>> = args
                    .before
                    .map(|v| parse_discord_id(&v))
                    .transpose()
                    .map_err(|err| ::anyhow::__private::must_use({
                        let error = ::anyhow::__private::format_err(
                            format_args!("invalid \'before\' message id: {0}", err),
                        );
                        error
                    }))?;
                let after_id: Option<Id<MessageMarker>> = args
                    .after
                    .map(|v| parse_discord_id(&v))
                    .transpose()
                    .map_err(|err| ::anyhow::__private::must_use({
                        let error = ::anyhow::__private::format_err(
                            format_args!("invalid \'after\' message id: {0}", err),
                        );
                        error
                    }))?;
                let res = discord_request_with_extra_error(
                        &self.state,
                        async move {
                            let req = rt_ctx
                                .discord_config
                                .client
                                .channel_messages(channel.id)
                                .limit(limit as u16)?;
                            if let Some(before) = before_id {
                                Ok(req.before(before).await)
                            } else if let Some(after) = after_id {
                                Ok(req.after(after).await)
                            } else {
                                Ok(req.await)
                            }
                        },
                    )
                    .await?;
                let messages = res.model().await?;
                messages.into_iter().map(TryInto::try_into).collect::<Result<_, _>>()
            }
            async fn discord_create_message(
                &self,
                args: OpCreateChannelMessage,
            ) -> Result<Message, anyhow::Error> {
                let rt_ctx = get_rt_ctx(&self.state);
                let channel = parse_get_guild_channel(
                        &self.state,
                        &rt_ctx,
                        &args.channel_id,
                    )
                    .await?;
                discord_request_with_extra_error(
                        &self.state,
                        async move {
                            let maybe_embeds = args
                                .fields
                                .embeds
                                .unwrap_or_default()
                                .into_iter()
                                .map(Into::into)
                                .collect::<Vec<_>>();
                            let components = args
                                .fields
                                .components
                                .unwrap_or_default()
                                .into_iter()
                                .map(Into::into)
                                .collect::<Vec<_>>();
                            let mut mc = rt_ctx
                                .discord_config
                                .client
                                .create_message(channel.id)
                                .embeds(&maybe_embeds)?
                                .components(&components)?;
                            if let Some(content) = &args.fields.content {
                                mc = mc.content(content)?;
                            }
                            let mentions = args.fields.allowed_mentions.map(Into::into);
                            if mentions.is_some() {
                                mc = mc.allowed_mentions(mentions.as_ref());
                            }
                            if let Some(reply) = &args.fields.reply_to_message_id {
                                mc = mc.reply(parse_discord_id(reply)?);
                            }
                            Ok(mc.await)
                        },
                    )
                    .await?
                    .model()
                    .await?
                    .try_into()
            }
            async fn discord_edit_message(
                &self,
                args: OpEditChannelMessage,
            ) -> Result<Message, anyhow::Error> {
                let rt_ctx = get_rt_ctx(&self.state);
                let channel = parse_get_guild_channel(
                        &self.state,
                        &rt_ctx,
                        &args.channel_id,
                    )
                    .await?;
                let message_id = parse_str_snowflake_id(&args.message_id)?;
                let res = discord_request_with_extra_error(
                        &self.state,
                        async move {
                            let maybe_embeds = args
                                .fields
                                .embeds
                                .map(|inner| {
                                    inner.into_iter().map(Into::into).collect::<Vec<_>>()
                                });
                            let components = args
                                .fields
                                .components
                                .map(|inner| {
                                    inner.into_iter().map(Into::into).collect::<Vec<_>>()
                                });
                            let mut mc = rt_ctx
                                .discord_config
                                .client
                                .update_message(channel.id, message_id.cast())
                                .content(args.fields.content.as_deref())?
                                .components(components.as_deref())?;
                            if let Some(embeds) = &maybe_embeds {
                                mc = mc.embeds(Some(embeds))?;
                            }
                            let mentions = args.fields.allowed_mentions.map(Into::into);
                            if mentions.is_some() {
                                mc = mc.allowed_mentions(mentions.as_ref());
                            }
                            Ok(mc.await)
                        },
                    )
                    .await?;
                res.model().await?.try_into()
            }
            async fn discord_crosspost_message(
                &self,
                (channel_id_raw, message_id_raw): (String, String),
            ) -> Result<(), anyhow::Error> {
                let ctx = get_rt_ctx(&self.state);
                let channel = parse_get_guild_channel(&self.state, &ctx, &channel_id_raw)
                    .await?;
                let message_id: Id<MessageMarker> = parse_discord_id(&message_id_raw)?;
                discord_request(
                        &self.state,
                        async move {
                            ctx.discord_config
                                .client
                                .crosspost_message(channel.id, message_id)
                                .await
                        },
                    )
                    .await?;
                Ok(())
            }
            async fn discord_delete_message(
                &self,
                args: OpDeleteMessage,
            ) -> Result<(), anyhow::Error> {
                let rt_ctx = get_rt_ctx(&self.state);
                let channel = parse_get_guild_channel(
                        &self.state,
                        &rt_ctx,
                        &args.channel_id,
                    )
                    .await?;
                let message_id = parse_str_snowflake_id(&args.message_id)?;
                discord_request(
                        &self.state,
                        async move {
                            rt_ctx
                                .discord_config
                                .client
                                .delete_message(channel.id, message_id.cast())
                                .await
                        },
                    )
                    .await?;
                Ok(())
            }
            async fn discord_bulk_delete_messages(
                &self,
                args: OpDeleteMessagesBulk,
            ) -> Result<(), anyhow::Error> {
                let rt_ctx = get_rt_ctx(&self.state);
                let channel = parse_get_guild_channel(
                        &self.state,
                        &rt_ctx,
                        &args.channel_id,
                    )
                    .await?;
                let message_ids = args
                    .message_ids
                    .iter()
                    .filter_map(|v| parse_str_snowflake_id(v).ok())
                    .map(|v| v.cast())
                    .collect::<Vec<_>>();
                discord_request_with_extra_error(
                        &self.state,
                        async move {
                            Ok(
                                rt_ctx
                                    .discord_config
                                    .client
                                    .delete_messages(channel.id, &message_ids)?
                                    .await,
                            )
                        },
                    )
                    .await?;
                Ok(())
            }
            async fn discord_start_thread_from_message(
                &self,
                arg: CreateThreadFromMessage,
            ) -> Result<GuildChannel, anyhow::Error> {
                let rt_ctx = get_rt_ctx(&self.state);
                let channel = parse_get_guild_channel(
                        &self.state,
                        &rt_ctx,
                        &arg.channel_id,
                    )
                    .await?;
                let message_id = parse_discord_id(&arg.message_id)?;
                Ok(
                    discord_request_with_extra_error(
                            &self.state,
                            async move {
                                let mut req = rt_ctx
                                    .discord_config
                                    .client
                                    .create_thread_from_message(
                                        channel.id,
                                        message_id,
                                        &arg.name,
                                    )?;
                                if let Some(auto_archive) = arg
                                    .auto_archive_duration_minutes
                                {
                                    req = req
                                        .auto_archive_duration(
                                            twilight_model::channel::thread::AutoArchiveDuration::from(
                                                auto_archive,
                                            ),
                                        );
                                }
                                Ok(req.await)
                            },
                        )
                        .await?
                        .model()
                        .await?
                        .into(),
                )
            }
            async fn discord_start_thread_without_message(
                &self,
                arg: CreateThread,
            ) -> Result<GuildChannel, anyhow::Error> {
                let rt_ctx = get_rt_ctx(&self.state);
                let channel = parse_get_guild_channel(
                        &self.state,
                        &rt_ctx,
                        &arg.channel_id,
                    )
                    .await?;
                Ok(
                    discord_request_with_extra_error(
                            &self.state,
                            async move {
                                let mut req = rt_ctx
                                    .discord_config
                                    .client
                                    .create_thread(channel.id, &arg.name, arg.kind.into())?;
                                if let Some(auto_archive) = arg
                                    .auto_archive_duration_minutes
                                {
                                    req = req
                                        .auto_archive_duration(
                                            twilight_model::channel::thread::AutoArchiveDuration::from(
                                                auto_archive,
                                            ),
                                        );
                                }
                                if let Some(invitable) = arg.invitable {
                                    req = req.invitable(invitable);
                                }
                                Ok(req.await)
                            },
                        )
                        .await?
                        .model()
                        .await?
                        .into(),
                )
            }
            async fn discord_start_forum_thread(
                &self,
                arg: CreateForumThread,
            ) -> Result<ForumThreadResponse, anyhow::Error> {
                let rt_ctx = get_rt_ctx(&self.state);
                let channel = parse_get_guild_channel(
                        &self.state,
                        &rt_ctx,
                        &arg.channel_id,
                    )
                    .await?;
                let res = discord_request_with_extra_error(
                        &self.state,
                        async move {
                            let mut req = rt_ctx
                                .discord_config
                                .client
                                .create_forum_thread(channel.id, &arg.name);
                            if let Some(auto_archive) = arg.auto_archive_duration_minutes
                            {
                                req = req
                                    .auto_archive_duration(
                                        twilight_model::channel::thread::AutoArchiveDuration::from(
                                            auto_archive,
                                        ),
                                    );
                            }
                            let maybe_tags: Option<Vec<Id<TagMarker>>> = arg
                                .tag_ids
                                .map(|v| {
                                    v.into_iter()
                                        .filter_map(|string_id| parse_discord_id(&string_id).ok())
                                        .collect()
                                });
                            if let Some(tags) = &maybe_tags {
                                req = req.applied_tags(tags);
                            }
                            let mut req = req.message();
                            let embeds = arg
                                .message
                                .embeds
                                .unwrap_or_default()
                                .into_iter()
                                .map(Into::into)
                                .collect::<Vec<_>>();
                            if !embeds.is_empty() {
                                req = req.embeds(&embeds)?;
                            }
                            let components = arg
                                .message
                                .components
                                .unwrap_or_default()
                                .into_iter()
                                .map(Into::into)
                                .collect::<Vec<_>>();
                            if !components.is_empty() {
                                req = req.components(&components)?;
                            }
                            if let Some(content) = &arg.message.content {
                                req = req.content(content)?;
                            }
                            let mentions = arg.message.allowed_mentions.map(Into::into);
                            if mentions.is_some() {
                                req = req.allowed_mentions(mentions.as_ref());
                            }
                            Ok(req.await)
                        },
                    )
                    .await?;
                let result = res.model().await?;
                Ok(ForumThreadResponse {
                    message: result.message.try_into()?,
                    channel: result.channel.into(),
                })
            }
            async fn discord_add_thread_member(
                &self,
                (channel_id_raw, user_id_raw): (String, String),
            ) -> Result<(), anyhow::Error> {
                let rt_ctx = get_rt_ctx(&self.state);
                let channel = parse_get_guild_channel(
                        &self.state,
                        &rt_ctx,
                        &channel_id_raw,
                    )
                    .await?;
                let user_id: Id<UserMarker> = parse_discord_id(&user_id_raw)?;
                discord_request(
                        &self.state,
                        async move {
                            rt_ctx
                                .discord_config
                                .client
                                .add_thread_member(channel.id, user_id)
                                .await
                        },
                    )
                    .await?;
                Ok(())
            }
            async fn discord_remove_thread_member(
                &self,
                (channel_id_raw, user_id_raw): (String, String),
            ) -> Result<(), anyhow::Error> {
                let rt_ctx = get_rt_ctx(&self.state);
                let channel = parse_get_guild_channel(
                        &self.state,
                        &rt_ctx,
                        &channel_id_raw,
                    )
                    .await?;
                let user_id: Id<UserMarker> = parse_discord_id(&user_id_raw)?;
                discord_request(
                        &self.state,
                        async move {
                            rt_ctx
                                .discord_config
                                .client
                                .remove_thread_member(channel.id, user_id)
                                .await
                        },
                    )
                    .await?;
                Ok(())
            }
            async fn discord_list_thread_members(
                &self,
                args: ListThreadMembersRequest,
            ) -> Result<Vec<ThreadMember>, anyhow::Error> {
                let rt_ctx = get_rt_ctx(&self.state);
                let channel = parse_get_guild_channel(
                        &self.state,
                        &rt_ctx,
                        &args.channel_id,
                    )
                    .await?;
                Ok(
                    discord_request_with_extra_error(
                            &self.state,
                            async move {
                                let mut req = rt_ctx
                                    .discord_config
                                    .client
                                    .thread_members(channel.id);
                                if let Some(limit) = args.limit {
                                    req = req.limit(limit)?;
                                }
                                if let Some(after) = args.after_user_id {
                                    req = req.after(parse_discord_id(&after)?);
                                }
                                if let Some(with_member) = args.with_member {
                                    req = req.with_member(with_member);
                                }
                                Ok(req.await)
                            },
                        )
                        .await?
                        .models()
                        .await?
                        .into_iter()
                        .map(Into::into)
                        .collect(),
                )
            }
            async fn discord_list_active_threads(
                &self,
                _arg: (),
            ) -> Result<ThreadsListing, anyhow::Error> {
                let rt_ctx = get_rt_ctx(&self.state);
                Ok(
                    discord_request(
                            &self.state,
                            async move {
                                rt_ctx
                                    .discord_config
                                    .client
                                    .active_threads(rt_ctx.guild_id)
                                    .await
                            },
                        )
                        .await?
                        .model()
                        .await?
                        .into(),
                )
            }
            async fn discord_list_public_archived_threads(
                &self,
                arg: ListThreadsRequest,
            ) -> Result<ThreadsListing, anyhow::Error> {
                let rt_ctx = get_rt_ctx(&self.state);
                let channel = parse_get_guild_channel(
                        &self.state,
                        &rt_ctx,
                        &arg.channel_id,
                    )
                    .await?;
                let before_str = arg
                    .before
                    .map(|v| {
                        chrono::Utc
                            .timestamp_millis_opt(v.0 as i64)
                            .single()
                            .ok_or(
                                ::anyhow::__private::must_use({
                                    let error = ::anyhow::__private::format_err(
                                        format_args!("bad \'before\' timestamp"),
                                    );
                                    error
                                }),
                            )
                            .map(|ts| ts.to_rfc3339())
                    })
                    .transpose()?;
                Ok(
                    discord_request(
                            &self.state,
                            async move {
                                let mut threads_request = rt_ctx
                                    .discord_config
                                    .client
                                    .public_archived_threads(channel.id);
                                if let Some(before_str) = &before_str {
                                    threads_request = threads_request.before(before_str);
                                }
                                threads_request.await
                            },
                        )
                        .await?
                        .model()
                        .await?
                        .into(),
                )
            }
            async fn discord_list_private_archived_threads(
                &self,
                arg: ListThreadsRequest,
            ) -> Result<ThreadsListing, anyhow::Error> {
                let rt_ctx = get_rt_ctx(&self.state);
                let channel = parse_get_guild_channel(
                        &self.state,
                        &rt_ctx,
                        &arg.channel_id,
                    )
                    .await?;
                let before_str = arg
                    .before
                    .map(|v| {
                        chrono::Utc
                            .timestamp_millis_opt(v.0 as i64)
                            .single()
                            .ok_or(
                                ::anyhow::__private::must_use({
                                    let error = ::anyhow::__private::format_err(
                                        format_args!("bad \'before\' timestamp"),
                                    );
                                    error
                                }),
                            )
                            .map(|ts| ts.to_rfc3339())
                    })
                    .transpose()?;
                Ok(
                    discord_request(
                            &self.state,
                            async move {
                                let mut threads_request = rt_ctx
                                    .discord_config
                                    .client
                                    .private_archived_threads(channel.id);
                                if let Some(before_str) = &before_str {
                                    threads_request = threads_request.before(before_str);
                                }
                                threads_request.await
                            },
                        )
                        .await?
                        .model()
                        .await?
                        .into(),
                )
            }
            async fn discord_edit_thread(
                &self,
                arg: UpdateThread,
            ) -> Result<GuildChannel, anyhow::Error> {
                let rt_ctx = get_rt_ctx(&self.state);
                let channel = parse_get_guild_channel(
                        &self.state,
                        &rt_ctx,
                        &arg.channel_id,
                    )
                    .await?;
                Ok(
                    discord_request_with_extra_error(
                            &self.state,
                            async move {
                                let mut req = rt_ctx
                                    .discord_config
                                    .client
                                    .update_thread(channel.id);
                                let maybe_tags: Option<Vec<Id<TagMarker>>> = arg
                                    .tag_ids
                                    .map(|v| {
                                        v.into_iter()
                                            .filter_map(|string_id| parse_discord_id(&string_id).ok())
                                            .collect()
                                    });
                                if let Some(tags) = &maybe_tags {
                                    req = req.applied_tags(Some(tags));
                                }
                                if let Some(archived) = arg.archived {
                                    req = req.archived(archived);
                                }
                                if let Some(auto_archive_duration_minutes) = arg
                                    .auto_archive_duration_minutes
                                {
                                    req = req
                                        .auto_archive_duration(
                                            auto_archive_duration_minutes.into(),
                                        );
                                }
                                if let Some(invitable) = arg.invitable {
                                    req = req.invitable(invitable);
                                }
                                if let Some(locked) = arg.locked {
                                    req = req.locked(locked);
                                }
                                if let Some(name) = &arg.name {
                                    req = req.name(name)?;
                                }
                                if let Some(rate_limit_per_user) = &arg.rate_limit_per_user
                                {
                                    req = req.rate_limit_per_user(*rate_limit_per_user)?;
                                }
                                Ok(req.await)
                            },
                        )
                        .await?
                        .model()
                        .await?
                        .into(),
                )
            }
            async fn discord_bulk_edit_channels(
                &self,
                arg: Vec<EditGuildChannelPosition>,
            ) -> Result<(), anyhow::Error> {
                let rt_ctx = get_rt_ctx(&self.state);
                discord_request_with_extra_error(
                        &self.state,
                        async move {
                            let positions = arg
                                .into_iter()
                                .map(|v| v.try_into())
                                .collect::<Result<Vec<_>, _>>()?;
                            let req = rt_ctx
                                .discord_config
                                .client
                                .update_guild_channel_positions(
                                    rt_ctx.guild_id,
                                    &positions,
                                );
                            Ok(req.await)
                        },
                    )
                    .await?;
                Ok(())
            }
        }
        #[allow(non_camel_case_types)]
        pub struct op_discord_get_invites {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_discord_get_invites {
            const NAME: &'static str = "op_discord_get_invites";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_discord_get_invites".as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    ("op_discord_get_invites", ::deno_core::FastStaticString::new(s))
                },
                true,
                false,
                2usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_discord_get_invites {
            pub const fn name() -> &'static str {
                "op_discord_get_invites"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg0 = opstate.clone();
                    Self::call(arg0)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                            deno_core::_ops::RustToV8Marker::<
                                deno_core::_ops::SerdeMarker,
                                _,
                            >::from(result),
                            scope,
                        )
                    },
                ) {
                    match result {
                        Ok(result) => {
                            match deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                                deno_core::_ops::RustToV8Marker::<
                                    deno_core::_ops::SerdeMarker,
                                    _,
                                >::from(result),
                                &mut scope,
                            ) {
                                Ok(v) => rv.set(v),
                                Err(rv_err) => {
                                    let msg = deno_core::v8::String::new(
                                            &mut scope,
                                            &{
                                                let res = ::alloc::fmt::format(
                                                    format_args!("{0}", deno_core::anyhow::Error::from(rv_err)),
                                                );
                                                res
                                            },
                                        )
                                        .unwrap();
                                    let exc = deno_core::v8::Exception::type_error(
                                        &mut scope,
                                        msg,
                                    );
                                    scope.throw_exception(exc);
                                    return 1;
                                }
                            }
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state: Rc<RefCell<OpState>>,
            ) -> Result<Vec<runtime_models::internal::invite::Invite>, AnyError> {
                let rt_ctx = get_rt_ctx(&state);
                let resp = discord_request(
                        &state,
                        async move {
                            rt_ctx
                                .discord_config
                                .client
                                .guild_invites(rt_ctx.guild_id)
                                .await
                        },
                    )
                    .await?
                    .model()
                    .await?;
                resp.into_iter().map(TryInto::try_into).collect()
            }
        }
        #[allow(non_camel_case_types)]
        pub struct op_discord_get_invite {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_discord_get_invite {
            const NAME: &'static str = "op_discord_get_invite";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_discord_get_invite".as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    ("op_discord_get_invite", ::deno_core::FastStaticString::new(s))
                },
                true,
                false,
                5usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_discord_get_invite {
            pub const fn name() -> &'static str {
                "op_discord_get_invite"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = deno_core::_ops::to_string(&mut scope, &arg1);
                    let arg2 = args.get(2usize as i32);
                    let arg2 = arg2.is_true();
                    let arg3 = args.get(3usize as i32);
                    let arg3 = arg3.is_true();
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1, arg2, arg3)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                            deno_core::_ops::RustToV8Marker::<
                                deno_core::_ops::SerdeMarker,
                                _,
                            >::from(result),
                            scope,
                        )
                    },
                ) {
                    match result {
                        Ok(result) => {
                            match deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                                deno_core::_ops::RustToV8Marker::<
                                    deno_core::_ops::SerdeMarker,
                                    _,
                                >::from(result),
                                &mut scope,
                            ) {
                                Ok(v) => rv.set(v),
                                Err(rv_err) => {
                                    let msg = deno_core::v8::String::new(
                                            &mut scope,
                                            &{
                                                let res = ::alloc::fmt::format(
                                                    format_args!("{0}", deno_core::anyhow::Error::from(rv_err)),
                                                );
                                                res
                                            },
                                        )
                                        .unwrap();
                                    let exc = deno_core::v8::Exception::type_error(
                                        &mut scope,
                                        msg,
                                    );
                                    scope.throw_exception(exc);
                                    return 1;
                                }
                            }
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state: Rc<RefCell<OpState>>,
                code: String,
                with_counts: bool,
                with_expiration: bool,
            ) -> Result<runtime_models::internal::invite::Invite, AnyError> {
                RateLimiters::discord_get_public_invite(&state).await;
                let rt_ctx = get_rt_ctx(&state);
                discord_request(
                        &state,
                        async move {
                            let mut req = rt_ctx.discord_config.client.invite(&code);
                            if with_counts {
                                req = req.with_counts();
                            }
                            if with_expiration {
                                req = req.with_expiration();
                            }
                            req.await
                        },
                    )
                    .await?
                    .model()
                    .await?
                    .try_into()
            }
        }
        #[allow(non_camel_case_types)]
        pub struct op_discord_delete_invite {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_discord_delete_invite {
            const NAME: &'static str = "op_discord_delete_invite";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_discord_delete_invite".as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    ("op_discord_delete_invite", ::deno_core::FastStaticString::new(s))
                },
                true,
                false,
                3usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_discord_delete_invite {
            pub const fn name() -> &'static str {
                "op_discord_delete_invite"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = deno_core::_ops::to_string(&mut scope, &arg1);
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                            deno_core::_ops::RustToV8Marker::<
                                deno_core::_ops::SerdeMarker,
                                _,
                            >::from(result),
                            scope,
                        )
                    },
                ) {
                    match result {
                        Ok(result) => {
                            match deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                                deno_core::_ops::RustToV8Marker::<
                                    deno_core::_ops::SerdeMarker,
                                    _,
                                >::from(result),
                                &mut scope,
                            ) {
                                Ok(v) => rv.set(v),
                                Err(rv_err) => {
                                    let msg = deno_core::v8::String::new(
                                            &mut scope,
                                            &{
                                                let res = ::alloc::fmt::format(
                                                    format_args!("{0}", deno_core::anyhow::Error::from(rv_err)),
                                                );
                                                res
                                            },
                                        )
                                        .unwrap();
                                    let exc = deno_core::v8::Exception::type_error(
                                        &mut scope,
                                        msg,
                                    );
                                    scope.throw_exception(exc);
                                    return 1;
                                }
                            }
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state: Rc<RefCell<OpState>>,
                code: String,
            ) -> Result<(), AnyError> {
                let rt_ctx = get_rt_ctx(&state);
                let code_cloned = code.clone();
                let rt_ctx_cloned = rt_ctx.clone();
                let invite = discord_request(
                        &state,
                        async move {
                            rt_ctx_cloned
                                .discord_config
                                .client
                                .invite(&code_cloned)
                                .await
                        },
                    )
                    .await?
                    .model()
                    .await?;
                let is_correct_guild = if let Some(guild) = invite.guild {
                    guild.id == rt_ctx.guild_id
                } else {
                    false
                };
                if !is_correct_guild {
                    return Err(
                        ::anyhow::__private::must_use({
                            let error = ::anyhow::__private::format_err(
                                format_args!("This invite does not belong to your server."),
                            );
                            error
                        }),
                    );
                }
                discord_request(
                        &state,
                        async move {
                            rt_ctx.discord_config.client.delete_invite(&code).await
                        },
                    )
                    .await?;
                Ok(())
            }
        }
        #[allow(non_camel_case_types)]
        pub struct op_discord_get_voice_states {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_discord_get_voice_states {
            const NAME: &'static str = "op_discord_get_voice_states";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_discord_get_voice_states"
                        .as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    (
                        "op_discord_get_voice_states",
                        ::deno_core::FastStaticString::new(s),
                    )
                },
                true,
                false,
                2usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_discord_get_voice_states {
            pub const fn name() -> &'static str {
                "op_discord_get_voice_states"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg0 = opstate.clone();
                    Self::call(arg0)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                            deno_core::_ops::RustToV8Marker::<
                                deno_core::_ops::SerdeMarker,
                                _,
                            >::from(result),
                            scope,
                        )
                    },
                ) {
                    match result {
                        Ok(result) => {
                            match deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                                deno_core::_ops::RustToV8Marker::<
                                    deno_core::_ops::SerdeMarker,
                                    _,
                                >::from(result),
                                &mut scope,
                            ) {
                                Ok(v) => rv.set(v),
                                Err(rv_err) => {
                                    let msg = deno_core::v8::String::new(
                                            &mut scope,
                                            &{
                                                let res = ::alloc::fmt::format(
                                                    format_args!("{0}", deno_core::anyhow::Error::from(rv_err)),
                                                );
                                                res
                                            },
                                        )
                                        .unwrap();
                                    let exc = deno_core::v8::Exception::type_error(
                                        &mut scope,
                                        msg,
                                    );
                                    scope.throw_exception(exc);
                                    return 1;
                                }
                            }
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state: Rc<RefCell<OpState>>,
            ) -> Result<Vec<VoiceState>, AnyError> {
                let rt_ctx = get_rt_ctx(&state);
                let voice_states = rt_ctx
                    .bot_state
                    .get_guild_voice_states(rt_ctx.guild_id)
                    .await?;
                Ok(voice_states.into_iter().filter_map(|v| v.try_into().ok()).collect())
            }
        }
        #[allow(non_camel_case_types)]
        pub struct op_discord_interaction_callback {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_discord_interaction_callback {
            const NAME: &'static str = "op_discord_interaction_callback";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_discord_interaction_callback"
                        .as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    (
                        "op_discord_interaction_callback",
                        ::deno_core::FastStaticString::new(s),
                    )
                },
                true,
                false,
                3usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_discord_interaction_callback {
            pub const fn name() -> &'static str {
                "op_discord_interaction_callback"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg1,
                    ) {
                        Ok(t) => t,
                        Err(arg1_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg1_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        Ok(deno_core::_ops::RustToV8::to_v8(result, scope))
                    },
                ) {
                    match result {
                        Ok(result) => {
                            deno_core::_ops::RustToV8RetVal::to_v8_rv(result, &mut rv)
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state: Rc<RefCell<OpState>>,
                args: InteractionCallback,
            ) -> Result<(), AnyError> {
                let rt_ctx = get_rt_ctx(&state);
                let interaction_id: Id<InteractionMarker> = parse_discord_id(
                    &args.interaction_id,
                )?;
                discord_request(
                        &state,
                        async move {
                            let client = rt_ctx.discord_config.interaction_client();
                            client
                                .create_response(
                                    interaction_id,
                                    &args.interaction_token,
                                    &args.data.into(),
                                )
                                .await
                        },
                    )
                    .await?;
                Ok(())
            }
        }
        #[allow(non_camel_case_types)]
        pub struct op_discord_interaction_get_original_response {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_discord_interaction_get_original_response {
            const NAME: &'static str = "op_discord_interaction_get_original_response";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_discord_interaction_get_original_response"
                        .as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    (
                        "op_discord_interaction_get_original_response",
                        ::deno_core::FastStaticString::new(s),
                    )
                },
                true,
                false,
                3usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_discord_interaction_get_original_response {
            pub const fn name() -> &'static str {
                "op_discord_interaction_get_original_response"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = deno_core::_ops::to_string(&mut scope, &arg1);
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                            deno_core::_ops::RustToV8Marker::<
                                deno_core::_ops::SerdeMarker,
                                _,
                            >::from(result),
                            scope,
                        )
                    },
                ) {
                    match result {
                        Ok(result) => {
                            match deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                                deno_core::_ops::RustToV8Marker::<
                                    deno_core::_ops::SerdeMarker,
                                    _,
                                >::from(result),
                                &mut scope,
                            ) {
                                Ok(v) => rv.set(v),
                                Err(rv_err) => {
                                    let msg = deno_core::v8::String::new(
                                            &mut scope,
                                            &{
                                                let res = ::alloc::fmt::format(
                                                    format_args!("{0}", deno_core::anyhow::Error::from(rv_err)),
                                                );
                                                res
                                            },
                                        )
                                        .unwrap();
                                    let exc = deno_core::v8::Exception::type_error(
                                        &mut scope,
                                        msg,
                                    );
                                    scope.throw_exception(exc);
                                    return 1;
                                }
                            }
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state: Rc<RefCell<OpState>>,
                token: String,
            ) -> Result<Message, AnyError> {
                let rt_ctx = get_rt_ctx(&state);
                discord_request(
                        &state,
                        async move {
                            let client = rt_ctx.discord_config.interaction_client();
                            client.response(&token).await
                        },
                    )
                    .await?
                    .model()
                    .await?
                    .try_into()
            }
        }
        #[allow(non_camel_case_types)]
        pub struct op_discord_interaction_edit_original_response {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_discord_interaction_edit_original_response {
            const NAME: &'static str = "op_discord_interaction_edit_original_response";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_discord_interaction_edit_original_response"
                        .as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    (
                        "op_discord_interaction_edit_original_response",
                        ::deno_core::FastStaticString::new(s),
                    )
                },
                true,
                false,
                3usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_discord_interaction_edit_original_response {
            pub const fn name() -> &'static str {
                "op_discord_interaction_edit_original_response"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg1,
                    ) {
                        Ok(t) => t,
                        Err(arg1_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg1_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                            deno_core::_ops::RustToV8Marker::<
                                deno_core::_ops::SerdeMarker,
                                _,
                            >::from(result),
                            scope,
                        )
                    },
                ) {
                    match result {
                        Ok(result) => {
                            match deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                                deno_core::_ops::RustToV8Marker::<
                                    deno_core::_ops::SerdeMarker,
                                    _,
                                >::from(result),
                                &mut scope,
                            ) {
                                Ok(v) => rv.set(v),
                                Err(rv_err) => {
                                    let msg = deno_core::v8::String::new(
                                            &mut scope,
                                            &{
                                                let res = ::alloc::fmt::format(
                                                    format_args!("{0}", deno_core::anyhow::Error::from(rv_err)),
                                                );
                                                res
                                            },
                                        )
                                        .unwrap();
                                    let exc = deno_core::v8::Exception::type_error(
                                        &mut scope,
                                        msg,
                                    );
                                    scope.throw_exception(exc);
                                    return 1;
                                }
                            }
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state: Rc<RefCell<OpState>>,
                args: OpCreateFollowUpMessage,
            ) -> Result<Message, AnyError> {
                let rt_ctx = get_rt_ctx(&state);
                let maybe_embeds = args
                    .fields
                    .embeds
                    .map(|inner| inner.into_iter().map(Into::into).collect::<Vec<_>>());
                let components = args
                    .fields
                    .components
                    .map(|inner| inner.into_iter().map(Into::into).collect::<Vec<_>>());
                discord_request_with_extra_error(
                        &state,
                        async move {
                            let interaction_client = rt_ctx
                                .discord_config
                                .interaction_client();
                            let mut mc = interaction_client
                                .update_response(&args.interaction_token)
                                .content(args.fields.content.as_deref())?
                                .embeds(maybe_embeds.as_deref())?
                                .components(components.as_deref())?
                                .content(args.fields.content.as_deref())?;
                            let mentions = args.fields.allowed_mentions.map(Into::into);
                            if mentions.is_some() {
                                mc = mc.allowed_mentions(mentions.as_ref());
                            }
                            Ok(mc.await)
                        },
                    )
                    .await?
                    .model()
                    .await?
                    .try_into()
            }
        }
        #[allow(non_camel_case_types)]
        pub struct op_discord_interaction_delete_original {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_discord_interaction_delete_original {
            const NAME: &'static str = "op_discord_interaction_delete_original";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_discord_interaction_delete_original"
                        .as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    (
                        "op_discord_interaction_delete_original",
                        ::deno_core::FastStaticString::new(s),
                    )
                },
                true,
                false,
                3usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_discord_interaction_delete_original {
            pub const fn name() -> &'static str {
                "op_discord_interaction_delete_original"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = deno_core::_ops::to_string(&mut scope, &arg1);
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        Ok(deno_core::_ops::RustToV8::to_v8(result, scope))
                    },
                ) {
                    match result {
                        Ok(result) => {
                            deno_core::_ops::RustToV8RetVal::to_v8_rv(result, &mut rv)
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state: Rc<RefCell<OpState>>,
                token: String,
            ) -> Result<(), AnyError> {
                let rt_ctx = get_rt_ctx(&state);
                discord_request(
                        &state,
                        async move {
                            let client = rt_ctx.discord_config.interaction_client();
                            client.delete_response(&token).await
                        },
                    )
                    .await?;
                Ok(())
            }
        }
        #[allow(non_camel_case_types)]
        pub struct op_discord_interaction_get_followup_message {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_discord_interaction_get_followup_message {
            const NAME: &'static str = "op_discord_interaction_get_followup_message";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_discord_interaction_get_followup_message"
                        .as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    (
                        "op_discord_interaction_get_followup_message",
                        ::deno_core::FastStaticString::new(s),
                    )
                },
                true,
                false,
                4usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_discord_interaction_get_followup_message {
            pub const fn name() -> &'static str {
                "op_discord_interaction_get_followup_message"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = deno_core::_ops::to_string(&mut scope, &arg1);
                    let arg2 = args.get(2usize as i32);
                    let arg2 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg2,
                    ) {
                        Ok(t) => t,
                        Err(arg2_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg2_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1, arg2)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                            deno_core::_ops::RustToV8Marker::<
                                deno_core::_ops::SerdeMarker,
                                _,
                            >::from(result),
                            scope,
                        )
                    },
                ) {
                    match result {
                        Ok(result) => {
                            match deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                                deno_core::_ops::RustToV8Marker::<
                                    deno_core::_ops::SerdeMarker,
                                    _,
                                >::from(result),
                                &mut scope,
                            ) {
                                Ok(v) => rv.set(v),
                                Err(rv_err) => {
                                    let msg = deno_core::v8::String::new(
                                            &mut scope,
                                            &{
                                                let res = ::alloc::fmt::format(
                                                    format_args!("{0}", deno_core::anyhow::Error::from(rv_err)),
                                                );
                                                res
                                            },
                                        )
                                        .unwrap();
                                    let exc = deno_core::v8::Exception::type_error(
                                        &mut scope,
                                        msg,
                                    );
                                    scope.throw_exception(exc);
                                    return 1;
                                }
                            }
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state: Rc<RefCell<OpState>>,
                token: String,
                id: Id<MessageMarker>,
            ) -> Result<Message, AnyError> {
                let rt_ctx = get_rt_ctx(&state);
                discord_request(
                        &state,
                        async move {
                            let client = rt_ctx.discord_config.interaction_client();
                            client.followup(&token, id).await
                        },
                    )
                    .await?
                    .model()
                    .await?
                    .try_into()
            }
        }
        #[allow(non_camel_case_types)]
        pub struct op_discord_interaction_followup_message {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_discord_interaction_followup_message {
            const NAME: &'static str = "op_discord_interaction_followup_message";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_discord_interaction_followup_message"
                        .as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    (
                        "op_discord_interaction_followup_message",
                        ::deno_core::FastStaticString::new(s),
                    )
                },
                true,
                false,
                3usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_discord_interaction_followup_message {
            pub const fn name() -> &'static str {
                "op_discord_interaction_followup_message"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg1,
                    ) {
                        Ok(t) => t,
                        Err(arg1_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg1_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                            deno_core::_ops::RustToV8Marker::<
                                deno_core::_ops::SerdeMarker,
                                _,
                            >::from(result),
                            scope,
                        )
                    },
                ) {
                    match result {
                        Ok(result) => {
                            match deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                                deno_core::_ops::RustToV8Marker::<
                                    deno_core::_ops::SerdeMarker,
                                    _,
                                >::from(result),
                                &mut scope,
                            ) {
                                Ok(v) => rv.set(v),
                                Err(rv_err) => {
                                    let msg = deno_core::v8::String::new(
                                            &mut scope,
                                            &{
                                                let res = ::alloc::fmt::format(
                                                    format_args!("{0}", deno_core::anyhow::Error::from(rv_err)),
                                                );
                                                res
                                            },
                                        )
                                        .unwrap();
                                    let exc = deno_core::v8::Exception::type_error(
                                        &mut scope,
                                        msg,
                                    );
                                    scope.throw_exception(exc);
                                    return 1;
                                }
                            }
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state: Rc<RefCell<OpState>>,
                args: OpCreateFollowUpMessage,
            ) -> Result<Message, AnyError> {
                let rt_ctx = get_rt_ctx(&state);
                let maybe_embeds = args
                    .fields
                    .embeds
                    .unwrap_or_default()
                    .into_iter()
                    .map(Into::into)
                    .collect::<Vec<_>>();
                let components = args
                    .fields
                    .components
                    .unwrap_or_default()
                    .into_iter()
                    .map(Into::into)
                    .collect::<Vec<_>>();
                discord_request_with_extra_error(
                        &state,
                        async move {
                            let interaction_client = rt_ctx
                                .discord_config
                                .interaction_client();
                            let mut mc = interaction_client
                                .create_followup(&args.interaction_token)
                                .embeds(&maybe_embeds)?
                                .components(&components)?;
                            if let Some(flags) = args.flags {
                                mc = mc.flags(flags.into());
                            }
                            if let Some(content) = &args.fields.content {
                                mc = mc.content(content)?;
                            }
                            let mentions = args.fields.allowed_mentions.map(Into::into);
                            if mentions.is_some() {
                                mc = mc.allowed_mentions(mentions.as_ref());
                            }
                            Ok(mc.await)
                        },
                    )
                    .await?
                    .model()
                    .await?
                    .try_into()
            }
        }
        #[allow(non_camel_case_types)]
        pub struct op_discord_interaction_edit_followup_message {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_discord_interaction_edit_followup_message {
            const NAME: &'static str = "op_discord_interaction_edit_followup_message";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_discord_interaction_edit_followup_message"
                        .as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    (
                        "op_discord_interaction_edit_followup_message",
                        ::deno_core::FastStaticString::new(s),
                    )
                },
                true,
                false,
                4usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_discord_interaction_edit_followup_message {
            pub const fn name() -> &'static str {
                "op_discord_interaction_edit_followup_message"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg1,
                    ) {
                        Ok(t) => t,
                        Err(arg1_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg1_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg2 = args.get(2usize as i32);
                    let arg2 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg2,
                    ) {
                        Ok(t) => t,
                        Err(arg2_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg2_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1, arg2)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                            deno_core::_ops::RustToV8Marker::<
                                deno_core::_ops::SerdeMarker,
                                _,
                            >::from(result),
                            scope,
                        )
                    },
                ) {
                    match result {
                        Ok(result) => {
                            match deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                                deno_core::_ops::RustToV8Marker::<
                                    deno_core::_ops::SerdeMarker,
                                    _,
                                >::from(result),
                                &mut scope,
                            ) {
                                Ok(v) => rv.set(v),
                                Err(rv_err) => {
                                    let msg = deno_core::v8::String::new(
                                            &mut scope,
                                            &{
                                                let res = ::alloc::fmt::format(
                                                    format_args!("{0}", deno_core::anyhow::Error::from(rv_err)),
                                                );
                                                res
                                            },
                                        )
                                        .unwrap();
                                    let exc = deno_core::v8::Exception::type_error(
                                        &mut scope,
                                        msg,
                                    );
                                    scope.throw_exception(exc);
                                    return 1;
                                }
                            }
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state: Rc<RefCell<OpState>>,
                message_id: Id<MessageMarker>,
                args: OpCreateFollowUpMessage,
            ) -> Result<(), AnyError> {
                let rt_ctx = get_rt_ctx(&state);
                let maybe_embeds = args
                    .fields
                    .embeds
                    .map(|inner| inner.into_iter().map(Into::into).collect::<Vec<_>>());
                let components = args
                    .fields
                    .components
                    .map(|inner| inner.into_iter().map(Into::into).collect::<Vec<_>>());
                discord_request_with_extra_error(
                        &state,
                        async move {
                            let interaction_client = rt_ctx
                                .discord_config
                                .interaction_client();
                            let mut mc = interaction_client
                                .update_followup(&args.interaction_token, message_id)
                                .content(args.fields.content.as_deref())?
                                .embeds(maybe_embeds.as_deref())?
                                .components(components.as_deref())?
                                .content(args.fields.content.as_deref())?;
                            let mentions = args.fields.allowed_mentions.map(Into::into);
                            if mentions.is_some() {
                                mc = mc.allowed_mentions(mentions.as_ref());
                            }
                            Ok(mc.await)
                        },
                    )
                    .await?;
                Ok(())
            }
        }
        #[allow(non_camel_case_types)]
        pub struct op_discord_interaction_delete_followup_message {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_discord_interaction_delete_followup_message {
            const NAME: &'static str = "op_discord_interaction_delete_followup_message";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_discord_interaction_delete_followup_message"
                        .as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    (
                        "op_discord_interaction_delete_followup_message",
                        ::deno_core::FastStaticString::new(s),
                    )
                },
                true,
                false,
                4usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_discord_interaction_delete_followup_message {
            pub const fn name() -> &'static str {
                "op_discord_interaction_delete_followup_message"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = deno_core::_ops::to_string(&mut scope, &arg1);
                    let arg2 = args.get(2usize as i32);
                    let arg2 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg2,
                    ) {
                        Ok(t) => t,
                        Err(arg2_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg2_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1, arg2)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        Ok(deno_core::_ops::RustToV8::to_v8(result, scope))
                    },
                ) {
                    match result {
                        Ok(result) => {
                            deno_core::_ops::RustToV8RetVal::to_v8_rv(result, &mut rv)
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state: Rc<RefCell<OpState>>,
                token: String,
                id: Id<MessageMarker>,
            ) -> Result<(), AnyError> {
                let rt_ctx = get_rt_ctx(&state);
                discord_request(
                        &state,
                        async move {
                            let client = rt_ctx.discord_config.interaction_client();
                            client.delete_followup(&token, id).await
                        },
                    )
                    .await?;
                Ok(())
            }
        }
        #[allow(non_camel_case_types)]
        pub struct op_discord_get_role {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_discord_get_role {
            const NAME: &'static str = "op_discord_get_role";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_discord_get_role".as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    ("op_discord_get_role", ::deno_core::FastStaticString::new(s))
                },
                true,
                false,
                3usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_discord_get_role {
            pub const fn name() -> &'static str {
                "op_discord_get_role"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg1,
                    ) {
                        Ok(t) => t,
                        Err(arg1_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg1_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                            deno_core::_ops::RustToV8Marker::<
                                deno_core::_ops::SerdeMarker,
                                _,
                            >::from(result),
                            scope,
                        )
                    },
                ) {
                    match result {
                        Ok(result) => {
                            match deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                                deno_core::_ops::RustToV8Marker::<
                                    deno_core::_ops::SerdeMarker,
                                    _,
                                >::from(result),
                                &mut scope,
                            ) {
                                Ok(v) => rv.set(v),
                                Err(rv_err) => {
                                    let msg = deno_core::v8::String::new(
                                            &mut scope,
                                            &{
                                                let res = ::alloc::fmt::format(
                                                    format_args!("{0}", deno_core::anyhow::Error::from(rv_err)),
                                                );
                                                res
                                            },
                                        )
                                        .unwrap();
                                    let exc = deno_core::v8::Exception::type_error(
                                        &mut scope,
                                        msg,
                                    );
                                    scope.throw_exception(exc);
                                    return 1;
                                }
                            }
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state: Rc<RefCell<OpState>>,
                role_id: Id<RoleMarker>,
            ) -> Result<runtime_models::discord::role::Role, AnyError> {
                let rt_ctx = get_rt_ctx(&state);
                match rt_ctx.bot_state.get_role(rt_ctx.guild_id, role_id).await? {
                    Some(c) => Ok(c.into()),
                    _ => {
                        Err(
                            not_found_error({
                                let res = ::alloc::fmt::format(
                                    format_args!("role `{0}` not found", role_id),
                                );
                                res
                            }),
                        )
                    }
                }
            }
        }
        #[allow(non_camel_case_types)]
        pub struct op_discord_get_roles {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_discord_get_roles {
            const NAME: &'static str = "op_discord_get_roles";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_discord_get_roles".as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    ("op_discord_get_roles", ::deno_core::FastStaticString::new(s))
                },
                true,
                false,
                2usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_discord_get_roles {
            pub const fn name() -> &'static str {
                "op_discord_get_roles"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg0 = opstate.clone();
                    Self::call(arg0)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                            deno_core::_ops::RustToV8Marker::<
                                deno_core::_ops::SerdeMarker,
                                _,
                            >::from(result),
                            scope,
                        )
                    },
                ) {
                    match result {
                        Ok(result) => {
                            match deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                                deno_core::_ops::RustToV8Marker::<
                                    deno_core::_ops::SerdeMarker,
                                    _,
                                >::from(result),
                                &mut scope,
                            ) {
                                Ok(v) => rv.set(v),
                                Err(rv_err) => {
                                    let msg = deno_core::v8::String::new(
                                            &mut scope,
                                            &{
                                                let res = ::alloc::fmt::format(
                                                    format_args!("{0}", deno_core::anyhow::Error::from(rv_err)),
                                                );
                                                res
                                            },
                                        )
                                        .unwrap();
                                    let exc = deno_core::v8::Exception::type_error(
                                        &mut scope,
                                        msg,
                                    );
                                    scope.throw_exception(exc);
                                    return 1;
                                }
                            }
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state: Rc<RefCell<OpState>>,
            ) -> Result<Vec<runtime_models::discord::role::Role>, AnyError> {
                let rt_ctx = get_rt_ctx(&state);
                let roles = rt_ctx.bot_state.get_roles(rt_ctx.guild_id).await?;
                Ok(roles.into_iter().map(Into::into).collect())
            }
        }
        #[allow(non_camel_case_types)]
        pub struct op_discord_create_reaction {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_discord_create_reaction {
            const NAME: &'static str = "op_discord_create_reaction";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_discord_create_reaction"
                        .as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    ("op_discord_create_reaction", ::deno_core::FastStaticString::new(s))
                },
                true,
                false,
                4usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_discord_create_reaction {
            pub const fn name() -> &'static str {
                "op_discord_create_reaction"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg1,
                    ) {
                        Ok(t) => t,
                        Err(arg1_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg1_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg2 = args.get(2usize as i32);
                    let arg2 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg2,
                    ) {
                        Ok(t) => t,
                        Err(arg2_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg2_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1, arg2)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        Ok(deno_core::_ops::RustToV8::to_v8(result, scope))
                    },
                ) {
                    match result {
                        Ok(result) => {
                            deno_core::_ops::RustToV8RetVal::to_v8_rv(result, &mut rv)
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state: Rc<RefCell<OpState>>,
                (channel_id, message_id): (Id<ChannelMarker>, Id<MessageMarker>),
                emoji: SendEmoji,
            ) -> Result<(), AnyError> {
                let rt_ctx = get_rt_ctx(&state);
                let _ = get_guild_channel(&state, &rt_ctx, channel_id).await?;
                discord_request(
                        &state,
                        async move {
                            rt_ctx
                                .discord_config
                                .client
                                .create_reaction(channel_id, message_id, &(&emoji).into())
                                .await
                        },
                    )
                    .await?;
                Ok(())
            }
        }
        #[allow(non_camel_case_types)]
        pub struct op_discord_delete_own_reaction {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_discord_delete_own_reaction {
            const NAME: &'static str = "op_discord_delete_own_reaction";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_discord_delete_own_reaction"
                        .as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    (
                        "op_discord_delete_own_reaction",
                        ::deno_core::FastStaticString::new(s),
                    )
                },
                true,
                false,
                4usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_discord_delete_own_reaction {
            pub const fn name() -> &'static str {
                "op_discord_delete_own_reaction"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg1,
                    ) {
                        Ok(t) => t,
                        Err(arg1_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg1_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg2 = args.get(2usize as i32);
                    let arg2 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg2,
                    ) {
                        Ok(t) => t,
                        Err(arg2_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg2_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1, arg2)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        Ok(deno_core::_ops::RustToV8::to_v8(result, scope))
                    },
                ) {
                    match result {
                        Ok(result) => {
                            deno_core::_ops::RustToV8RetVal::to_v8_rv(result, &mut rv)
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state: Rc<RefCell<OpState>>,
                (channel_id, message_id): (Id<ChannelMarker>, Id<MessageMarker>),
                emoji: SendEmoji,
            ) -> Result<(), AnyError> {
                let rt_ctx = get_rt_ctx(&state);
                let _ = get_guild_channel(&state, &rt_ctx, channel_id).await?;
                discord_request(
                        &state,
                        async move {
                            rt_ctx
                                .discord_config
                                .client
                                .delete_current_user_reaction(
                                    channel_id,
                                    message_id,
                                    &(&emoji).into(),
                                )
                                .await
                        },
                    )
                    .await?;
                Ok(())
            }
        }
        #[allow(non_camel_case_types)]
        pub struct op_discord_delete_user_reaction {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_discord_delete_user_reaction {
            const NAME: &'static str = "op_discord_delete_user_reaction";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_discord_delete_user_reaction"
                        .as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    (
                        "op_discord_delete_user_reaction",
                        ::deno_core::FastStaticString::new(s),
                    )
                },
                true,
                false,
                4usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_discord_delete_user_reaction {
            pub const fn name() -> &'static str {
                "op_discord_delete_user_reaction"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg1,
                    ) {
                        Ok(t) => t,
                        Err(arg1_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg1_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg2 = args.get(2usize as i32);
                    let arg2 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg2,
                    ) {
                        Ok(t) => t,
                        Err(arg2_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg2_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1, arg2)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        Ok(deno_core::_ops::RustToV8::to_v8(result, scope))
                    },
                ) {
                    match result {
                        Ok(result) => {
                            deno_core::_ops::RustToV8RetVal::to_v8_rv(result, &mut rv)
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state: Rc<RefCell<OpState>>,
                (
                    channel_id,
                    message_id,
                    user_id,
                ): (Id<ChannelMarker>, Id<MessageMarker>, Id<UserMarker>),
                emoji: SendEmoji,
            ) -> Result<(), AnyError> {
                let rt_ctx = get_rt_ctx(&state);
                let _ = get_guild_channel(&state, &rt_ctx, channel_id).await?;
                discord_request(
                        &state,
                        async move {
                            rt_ctx
                                .discord_config
                                .client
                                .delete_reaction(
                                    channel_id,
                                    message_id,
                                    &(&emoji).into(),
                                    user_id,
                                )
                                .await
                        },
                    )
                    .await?;
                Ok(())
            }
        }
        #[allow(non_camel_case_types)]
        pub struct op_discord_get_reactions {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_discord_get_reactions {
            const NAME: &'static str = "op_discord_get_reactions";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_discord_get_reactions".as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    ("op_discord_get_reactions", ::deno_core::FastStaticString::new(s))
                },
                true,
                false,
                4usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_discord_get_reactions {
            pub const fn name() -> &'static str {
                "op_discord_get_reactions"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg1,
                    ) {
                        Ok(t) => t,
                        Err(arg1_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg1_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg2 = args.get(2usize as i32);
                    let arg2 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg2,
                    ) {
                        Ok(t) => t,
                        Err(arg2_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg2_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1, arg2)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                            deno_core::_ops::RustToV8Marker::<
                                deno_core::_ops::SerdeMarker,
                                _,
                            >::from(result),
                            scope,
                        )
                    },
                ) {
                    match result {
                        Ok(result) => {
                            match deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                                deno_core::_ops::RustToV8Marker::<
                                    deno_core::_ops::SerdeMarker,
                                    _,
                                >::from(result),
                                &mut scope,
                            ) {
                                Ok(v) => rv.set(v),
                                Err(rv_err) => {
                                    let msg = deno_core::v8::String::new(
                                            &mut scope,
                                            &{
                                                let res = ::alloc::fmt::format(
                                                    format_args!("{0}", deno_core::anyhow::Error::from(rv_err)),
                                                );
                                                res
                                            },
                                        )
                                        .unwrap();
                                    let exc = deno_core::v8::Exception::type_error(
                                        &mut scope,
                                        msg,
                                    );
                                    scope.throw_exception(exc);
                                    return 1;
                                }
                            }
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state: Rc<RefCell<OpState>>,
                (channel_id, message_id): (Id<ChannelMarker>, Id<MessageMarker>),
                fields: GetReactionsFields,
            ) -> Result<Vec<User>, AnyError> {
                let rt_ctx = get_rt_ctx(&state);
                let _ = get_guild_channel(&state, &rt_ctx, channel_id).await?;
                Ok(
                    discord_request_with_extra_error(
                            &state,
                            async move {
                                let emoji = (&fields.emoji).into();
                                let mut req = rt_ctx
                                    .discord_config
                                    .client
                                    .reactions(channel_id, message_id, &emoji);
                                if let Some(after_str) = &fields.after {
                                    req = req.after(parse_str_snowflake_id(after_str)?.cast());
                                }
                                if let Some(limit) = fields.limit {
                                    req = req.limit(limit as u16)?;
                                }
                                Ok(req.await)
                            },
                        )
                        .await?
                        .model()
                        .await?
                        .into_iter()
                        .map(Into::into)
                        .collect(),
                )
            }
        }
        #[allow(non_camel_case_types)]
        pub struct op_discord_delete_all_reactions {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_discord_delete_all_reactions {
            const NAME: &'static str = "op_discord_delete_all_reactions";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_discord_delete_all_reactions"
                        .as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    (
                        "op_discord_delete_all_reactions",
                        ::deno_core::FastStaticString::new(s),
                    )
                },
                true,
                false,
                3usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_discord_delete_all_reactions {
            pub const fn name() -> &'static str {
                "op_discord_delete_all_reactions"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg1,
                    ) {
                        Ok(t) => t,
                        Err(arg1_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg1_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        Ok(deno_core::_ops::RustToV8::to_v8(result, scope))
                    },
                ) {
                    match result {
                        Ok(result) => {
                            deno_core::_ops::RustToV8RetVal::to_v8_rv(result, &mut rv)
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state: Rc<RefCell<OpState>>,
                (channel_id, message_id): (Id<ChannelMarker>, Id<MessageMarker>),
            ) -> Result<(), AnyError> {
                let rt_ctx = get_rt_ctx(&state);
                let _ = get_guild_channel(&state, &rt_ctx, channel_id).await?;
                discord_request(
                        &state,
                        async move {
                            rt_ctx
                                .discord_config
                                .client
                                .delete_all_reactions(channel_id, message_id)
                                .await
                        },
                    )
                    .await?;
                Ok(())
            }
        }
        #[allow(non_camel_case_types)]
        pub struct op_discord_delete_all_reactions_for_emoji {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_discord_delete_all_reactions_for_emoji {
            const NAME: &'static str = "op_discord_delete_all_reactions_for_emoji";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_discord_delete_all_reactions_for_emoji"
                        .as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    (
                        "op_discord_delete_all_reactions_for_emoji",
                        ::deno_core::FastStaticString::new(s),
                    )
                },
                true,
                false,
                4usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_discord_delete_all_reactions_for_emoji {
            pub const fn name() -> &'static str {
                "op_discord_delete_all_reactions_for_emoji"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg1,
                    ) {
                        Ok(t) => t,
                        Err(arg1_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg1_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg2 = args.get(2usize as i32);
                    let arg2 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg2,
                    ) {
                        Ok(t) => t,
                        Err(arg2_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg2_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1, arg2)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        Ok(deno_core::_ops::RustToV8::to_v8(result, scope))
                    },
                ) {
                    match result {
                        Ok(result) => {
                            deno_core::_ops::RustToV8RetVal::to_v8_rv(result, &mut rv)
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state: Rc<RefCell<OpState>>,
                (channel_id, message_id): (Id<ChannelMarker>, Id<MessageMarker>),
                emoji: SendEmoji,
            ) -> Result<(), AnyError> {
                let rt_ctx = get_rt_ctx(&state);
                let _ = get_guild_channel(&state, &rt_ctx, channel_id).await?;
                discord_request(
                        &state,
                        async move {
                            rt_ctx
                                .discord_config
                                .client
                                .delete_all_reaction(
                                    channel_id,
                                    message_id,
                                    &(&emoji).into(),
                                )
                                .await
                        },
                    )
                    .await?;
                Ok(())
            }
        }
        #[allow(non_camel_case_types)]
        pub struct op_discord_get_channel {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_discord_get_channel {
            const NAME: &'static str = "op_discord_get_channel";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_discord_get_channel".as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    ("op_discord_get_channel", ::deno_core::FastStaticString::new(s))
                },
                true,
                false,
                3usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_discord_get_channel {
            pub const fn name() -> &'static str {
                "op_discord_get_channel"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = deno_core::_ops::to_string(&mut scope, &arg1);
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                            deno_core::_ops::RustToV8Marker::<
                                deno_core::_ops::SerdeMarker,
                                _,
                            >::from(result),
                            scope,
                        )
                    },
                ) {
                    match result {
                        Ok(result) => {
                            match deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                                deno_core::_ops::RustToV8Marker::<
                                    deno_core::_ops::SerdeMarker,
                                    _,
                                >::from(result),
                                &mut scope,
                            ) {
                                Ok(v) => rv.set(v),
                                Err(rv_err) => {
                                    let msg = deno_core::v8::String::new(
                                            &mut scope,
                                            &{
                                                let res = ::alloc::fmt::format(
                                                    format_args!("{0}", deno_core::anyhow::Error::from(rv_err)),
                                                );
                                                res
                                            },
                                        )
                                        .unwrap();
                                    let exc = deno_core::v8::Exception::type_error(
                                        &mut scope,
                                        msg,
                                    );
                                    scope.throw_exception(exc);
                                    return 1;
                                }
                            }
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state: Rc<RefCell<OpState>>,
                channel_id_str: String,
            ) -> Result<runtime_models::internal::channel::GuildChannel, AnyError> {
                let rt_ctx = get_rt_ctx(&state);
                let channel = parse_get_guild_channel(&state, &rt_ctx, &channel_id_str)
                    .await?;
                Ok(channel.into())
            }
        }
        #[allow(non_camel_case_types)]
        pub struct op_discord_get_channels {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_discord_get_channels {
            const NAME: &'static str = "op_discord_get_channels";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_discord_get_channels".as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    ("op_discord_get_channels", ::deno_core::FastStaticString::new(s))
                },
                true,
                false,
                2usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_discord_get_channels {
            pub const fn name() -> &'static str {
                "op_discord_get_channels"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg0 = opstate.clone();
                    Self::call(arg0)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                            deno_core::_ops::RustToV8Marker::<
                                deno_core::_ops::SerdeMarker,
                                _,
                            >::from(result),
                            scope,
                        )
                    },
                ) {
                    match result {
                        Ok(result) => {
                            match deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                                deno_core::_ops::RustToV8Marker::<
                                    deno_core::_ops::SerdeMarker,
                                    _,
                                >::from(result),
                                &mut scope,
                            ) {
                                Ok(v) => rv.set(v),
                                Err(rv_err) => {
                                    let msg = deno_core::v8::String::new(
                                            &mut scope,
                                            &{
                                                let res = ::alloc::fmt::format(
                                                    format_args!("{0}", deno_core::anyhow::Error::from(rv_err)),
                                                );
                                                res
                                            },
                                        )
                                        .unwrap();
                                    let exc = deno_core::v8::Exception::type_error(
                                        &mut scope,
                                        msg,
                                    );
                                    scope.throw_exception(exc);
                                    return 1;
                                }
                            }
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state: Rc<RefCell<OpState>>,
            ) -> Result<Vec<runtime_models::internal::channel::GuildChannel>, AnyError> {
                let rt_ctx = get_rt_ctx(&state);
                let channels = rt_ctx.bot_state.get_channels(rt_ctx.guild_id).await?;
                Ok(channels.into_iter().map(Into::into).collect())
            }
        }
        #[allow(non_camel_case_types)]
        pub struct op_discord_edit_channel {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_discord_edit_channel {
            const NAME: &'static str = "op_discord_edit_channel";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_discord_edit_channel".as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    ("op_discord_edit_channel", ::deno_core::FastStaticString::new(s))
                },
                true,
                false,
                4usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_discord_edit_channel {
            pub const fn name() -> &'static str {
                "op_discord_edit_channel"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg1,
                    ) {
                        Ok(t) => t,
                        Err(arg1_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg1_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg2 = args.get(2usize as i32);
                    let arg2 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg2,
                    ) {
                        Ok(t) => t,
                        Err(arg2_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg2_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1, arg2)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                            deno_core::_ops::RustToV8Marker::<
                                deno_core::_ops::SerdeMarker,
                                _,
                            >::from(result),
                            scope,
                        )
                    },
                ) {
                    match result {
                        Ok(result) => {
                            match deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                                deno_core::_ops::RustToV8Marker::<
                                    deno_core::_ops::SerdeMarker,
                                    _,
                                >::from(result),
                                &mut scope,
                            ) {
                                Ok(v) => rv.set(v),
                                Err(rv_err) => {
                                    let msg = deno_core::v8::String::new(
                                            &mut scope,
                                            &{
                                                let res = ::alloc::fmt::format(
                                                    format_args!("{0}", deno_core::anyhow::Error::from(rv_err)),
                                                );
                                                res
                                            },
                                        )
                                        .unwrap();
                                    let exc = deno_core::v8::Exception::type_error(
                                        &mut scope,
                                        msg,
                                    );
                                    scope.throw_exception(exc);
                                    return 1;
                                }
                            }
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state: Rc<RefCell<OpState>>,
                channel_id: Id<ChannelMarker>,
                params: EditChannel,
            ) -> Result<runtime_models::internal::channel::GuildChannel, AnyError> {
                let rt_ctx = get_rt_ctx(&state);
                get_guild_channel(&state, &rt_ctx, channel_id).await?;
                Ok(
                    discord_request_with_extra_error(
                            &state,
                            async move {
                                let mut overwrites = Vec::new();
                                let edit = rt_ctx
                                    .discord_config
                                    .client
                                    .update_channel(channel_id);
                                Ok(params.apply(&mut overwrites, edit)?.await)
                            },
                        )
                        .await?
                        .model()
                        .await?
                        .into(),
                )
            }
        }
        #[allow(non_camel_case_types)]
        pub struct op_discord_create_channel {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_discord_create_channel {
            const NAME: &'static str = "op_discord_create_channel";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_discord_create_channel"
                        .as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    ("op_discord_create_channel", ::deno_core::FastStaticString::new(s))
                },
                true,
                false,
                3usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_discord_create_channel {
            pub const fn name() -> &'static str {
                "op_discord_create_channel"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg1,
                    ) {
                        Ok(t) => t,
                        Err(arg1_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg1_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                            deno_core::_ops::RustToV8Marker::<
                                deno_core::_ops::SerdeMarker,
                                _,
                            >::from(result),
                            scope,
                        )
                    },
                ) {
                    match result {
                        Ok(result) => {
                            match deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                                deno_core::_ops::RustToV8Marker::<
                                    deno_core::_ops::SerdeMarker,
                                    _,
                                >::from(result),
                                &mut scope,
                            ) {
                                Ok(v) => rv.set(v),
                                Err(rv_err) => {
                                    let msg = deno_core::v8::String::new(
                                            &mut scope,
                                            &{
                                                let res = ::alloc::fmt::format(
                                                    format_args!("{0}", deno_core::anyhow::Error::from(rv_err)),
                                                );
                                                res
                                            },
                                        )
                                        .unwrap();
                                    let exc = deno_core::v8::Exception::type_error(
                                        &mut scope,
                                        msg,
                                    );
                                    scope.throw_exception(exc);
                                    return 1;
                                }
                            }
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state: Rc<RefCell<OpState>>,
                params: CreateChannel,
            ) -> Result<runtime_models::internal::channel::GuildChannel, AnyError> {
                let rt_ctx = get_rt_ctx(&state);
                Ok(
                    discord_request_with_extra_error(
                            &state,
                            async move {
                                let mut overwrites = Vec::new();
                                let edit = rt_ctx
                                    .discord_config
                                    .client
                                    .create_guild_channel(rt_ctx.guild_id, &params.name)?;
                                Ok(params.apply(&mut overwrites, edit)?.await)
                            },
                        )
                        .await?
                        .model()
                        .await?
                        .into(),
                )
            }
        }
        #[allow(non_camel_case_types)]
        pub struct op_discord_delete_channel {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_discord_delete_channel {
            const NAME: &'static str = "op_discord_delete_channel";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_discord_delete_channel"
                        .as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    ("op_discord_delete_channel", ::deno_core::FastStaticString::new(s))
                },
                true,
                false,
                3usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_discord_delete_channel {
            pub const fn name() -> &'static str {
                "op_discord_delete_channel"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg1,
                    ) {
                        Ok(t) => t,
                        Err(arg1_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg1_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                            deno_core::_ops::RustToV8Marker::<
                                deno_core::_ops::SerdeMarker,
                                _,
                            >::from(result),
                            scope,
                        )
                    },
                ) {
                    match result {
                        Ok(result) => {
                            match deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                                deno_core::_ops::RustToV8Marker::<
                                    deno_core::_ops::SerdeMarker,
                                    _,
                                >::from(result),
                                &mut scope,
                            ) {
                                Ok(v) => rv.set(v),
                                Err(rv_err) => {
                                    let msg = deno_core::v8::String::new(
                                            &mut scope,
                                            &{
                                                let res = ::alloc::fmt::format(
                                                    format_args!("{0}", deno_core::anyhow::Error::from(rv_err)),
                                                );
                                                res
                                            },
                                        )
                                        .unwrap();
                                    let exc = deno_core::v8::Exception::type_error(
                                        &mut scope,
                                        msg,
                                    );
                                    scope.throw_exception(exc);
                                    return 1;
                                }
                            }
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state: Rc<RefCell<OpState>>,
                channel_id: Id<ChannelMarker>,
            ) -> Result<runtime_models::internal::channel::GuildChannel, AnyError> {
                let rt_ctx = get_rt_ctx(&state);
                get_guild_channel(&state, &rt_ctx, channel_id).await?;
                Ok(
                    discord_request(
                            &state,
                            async move {
                                rt_ctx
                                    .discord_config
                                    .client
                                    .delete_channel(channel_id)
                                    .await
                            },
                        )
                        .await?
                        .model()
                        .await?
                        .into(),
                )
            }
        }
        #[allow(non_camel_case_types)]
        pub struct op_discord_update_channel_permission {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_discord_update_channel_permission {
            const NAME: &'static str = "op_discord_update_channel_permission";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_discord_update_channel_permission"
                        .as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    (
                        "op_discord_update_channel_permission",
                        ::deno_core::FastStaticString::new(s),
                    )
                },
                true,
                false,
                4usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_discord_update_channel_permission {
            pub const fn name() -> &'static str {
                "op_discord_update_channel_permission"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg1,
                    ) {
                        Ok(t) => t,
                        Err(arg1_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg1_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg2 = args.get(2usize as i32);
                    let arg2 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg2,
                    ) {
                        Ok(t) => t,
                        Err(arg2_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg2_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1, arg2)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        Ok(deno_core::_ops::RustToV8::to_v8(result, scope))
                    },
                ) {
                    match result {
                        Ok(result) => {
                            deno_core::_ops::RustToV8RetVal::to_v8_rv(result, &mut rv)
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state: Rc<RefCell<OpState>>,
                channel_id: Id<ChannelMarker>,
                permission_overwrite: PermissionOverwrite,
            ) -> Result<(), AnyError> {
                let rt_ctx = get_rt_ctx(&state);
                get_guild_channel(&state, &rt_ctx, channel_id).await?;
                discord_request_with_extra_error(
                        &state,
                        async move {
                            let conv = permission_overwrite
                                .try_into()
                                .map_err(|_| ::anyhow::__private::must_use({
                                    let error = ::anyhow::__private::format_err(
                                        format_args!("invalid id"),
                                    );
                                    error
                                }))?;
                            Ok(
                                rt_ctx
                                    .discord_config
                                    .client
                                    .update_channel_permission(channel_id, &conv)
                                    .await,
                            )
                        },
                    )
                    .await?;
                Ok(())
            }
        }
        #[allow(non_camel_case_types)]
        pub struct op_discord_delete_channel_permission {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_discord_delete_channel_permission {
            const NAME: &'static str = "op_discord_delete_channel_permission";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_discord_delete_channel_permission"
                        .as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    (
                        "op_discord_delete_channel_permission",
                        ::deno_core::FastStaticString::new(s),
                    )
                },
                true,
                false,
                4usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_discord_delete_channel_permission {
            pub const fn name() -> &'static str {
                "op_discord_delete_channel_permission"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg1,
                    ) {
                        Ok(t) => t,
                        Err(arg1_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg1_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg2 = args.get(2usize as i32);
                    let arg2 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg2,
                    ) {
                        Ok(t) => t,
                        Err(arg2_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg2_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1, arg2)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        Ok(deno_core::_ops::RustToV8::to_v8(result, scope))
                    },
                ) {
                    match result {
                        Ok(result) => {
                            deno_core::_ops::RustToV8RetVal::to_v8_rv(result, &mut rv)
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state: Rc<RefCell<OpState>>,
                channel_id: Id<ChannelMarker>,
                (kind, overwrite_id): (PermissionOverwriteType, Id<GenericMarker>),
            ) -> Result<(), AnyError> {
                let rt_ctx = get_rt_ctx(&state);
                get_guild_channel(&state, &rt_ctx, channel_id).await?;
                discord_request(
                        &state,
                        async move {
                            let req = rt_ctx
                                .discord_config
                                .client
                                .delete_channel_permission(channel_id);
                            match kind {
                                PermissionOverwriteType::Member => {
                                    req.member(overwrite_id.cast()).await
                                }
                                PermissionOverwriteType::Role => {
                                    req.role(overwrite_id.cast()).await
                                }
                            }
                        },
                    )
                    .await?;
                Ok(())
            }
        }
        #[allow(non_camel_case_types)]
        pub struct op_discord_get_channel_invites {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_discord_get_channel_invites {
            const NAME: &'static str = "op_discord_get_channel_invites";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_discord_get_channel_invites"
                        .as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    (
                        "op_discord_get_channel_invites",
                        ::deno_core::FastStaticString::new(s),
                    )
                },
                true,
                false,
                3usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_discord_get_channel_invites {
            pub const fn name() -> &'static str {
                "op_discord_get_channel_invites"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = deno_core::_ops::to_string(&mut scope, &arg1);
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                            deno_core::_ops::RustToV8Marker::<
                                deno_core::_ops::SerdeMarker,
                                _,
                            >::from(result),
                            scope,
                        )
                    },
                ) {
                    match result {
                        Ok(result) => {
                            match deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                                deno_core::_ops::RustToV8Marker::<
                                    deno_core::_ops::SerdeMarker,
                                    _,
                                >::from(result),
                                &mut scope,
                            ) {
                                Ok(v) => rv.set(v),
                                Err(rv_err) => {
                                    let msg = deno_core::v8::String::new(
                                            &mut scope,
                                            &{
                                                let res = ::alloc::fmt::format(
                                                    format_args!("{0}", deno_core::anyhow::Error::from(rv_err)),
                                                );
                                                res
                                            },
                                        )
                                        .unwrap();
                                    let exc = deno_core::v8::Exception::type_error(
                                        &mut scope,
                                        msg,
                                    );
                                    scope.throw_exception(exc);
                                    return 1;
                                }
                            }
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state: Rc<RefCell<OpState>>,
                channel_id_str: String,
            ) -> Result<Vec<runtime_models::internal::invite::Invite>, AnyError> {
                let rt_ctx = get_rt_ctx(&state);
                let channel = parse_get_guild_channel(&state, &rt_ctx, &channel_id_str)
                    .await?;
                let rt_ctx = get_rt_ctx(&state);
                let resp = discord_request(
                        &state,
                        async move {
                            rt_ctx
                                .discord_config
                                .client
                                .channel_invites(channel.id)
                                .await
                        },
                    )
                    .await?
                    .model()
                    .await?;
                resp.into_iter().map(TryInto::try_into).collect()
            }
        }
        #[allow(non_camel_case_types)]
        pub struct op_discord_create_channel_invite {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_discord_create_channel_invite {
            const NAME: &'static str = "op_discord_create_channel_invite";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_discord_create_channel_invite"
                        .as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    (
                        "op_discord_create_channel_invite",
                        ::deno_core::FastStaticString::new(s),
                    )
                },
                true,
                false,
                4usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_discord_create_channel_invite {
            pub const fn name() -> &'static str {
                "op_discord_create_channel_invite"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg1,
                    ) {
                        Ok(t) => t,
                        Err(arg1_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg1_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg2 = args.get(2usize as i32);
                    let arg2 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg2,
                    ) {
                        Ok(t) => t,
                        Err(arg2_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg2_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1, arg2)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                            deno_core::_ops::RustToV8Marker::<
                                deno_core::_ops::SerdeMarker,
                                _,
                            >::from(result),
                            scope,
                        )
                    },
                ) {
                    match result {
                        Ok(result) => {
                            match deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                                deno_core::_ops::RustToV8Marker::<
                                    deno_core::_ops::SerdeMarker,
                                    _,
                                >::from(result),
                                &mut scope,
                            ) {
                                Ok(v) => rv.set(v),
                                Err(rv_err) => {
                                    let msg = deno_core::v8::String::new(
                                            &mut scope,
                                            &{
                                                let res = ::alloc::fmt::format(
                                                    format_args!("{0}", deno_core::anyhow::Error::from(rv_err)),
                                                );
                                                res
                                            },
                                        )
                                        .unwrap();
                                    let exc = deno_core::v8::Exception::type_error(
                                        &mut scope,
                                        msg,
                                    );
                                    scope.throw_exception(exc);
                                    return 1;
                                }
                            }
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state: Rc<RefCell<OpState>>,
                channel_id: Id<ChannelMarker>,
                fields: CreateInviteFields,
            ) -> Result<runtime_models::internal::invite::Invite, AnyError> {
                let rt_ctx = get_rt_ctx(&state);
                let channel = get_guild_channel(&state, &rt_ctx, channel_id).await?;
                discord_request_with_extra_error(
                        &state,
                        async move {
                            let mut req = rt_ctx
                                .discord_config
                                .client
                                .create_invite(channel.id);
                            if let Some(max_age) = fields.max_age {
                                req = req.max_age(max_age)?;
                            }
                            if let Some(max_uses) = fields.max_uses {
                                req = req.max_uses(max_uses)?;
                            }
                            if let Some(temporary) = fields.temporary {
                                req = req.temporary(temporary);
                            }
                            if let Some(target_application_id) = fields
                                .target_application_id
                            {
                                req = req.target_application_id(target_application_id);
                            }
                            if let Some(target_user_id) = fields.target_user_id {
                                req = req.target_user_id(target_user_id);
                            }
                            if let Some(target_type) = fields.target_type {
                                req = req.target_type(target_type.into());
                            }
                            if let Some(unique) = fields.unique {
                                req = req.unique(unique);
                            }
                            Ok(req.await)
                        },
                    )
                    .await?
                    .model()
                    .await?
                    .try_into()
            }
        }
        #[allow(non_camel_case_types)]
        pub struct op_discord_get_channel_pins {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_discord_get_channel_pins {
            const NAME: &'static str = "op_discord_get_channel_pins";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_discord_get_channel_pins"
                        .as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    (
                        "op_discord_get_channel_pins",
                        ::deno_core::FastStaticString::new(s),
                    )
                },
                true,
                false,
                3usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_discord_get_channel_pins {
            pub const fn name() -> &'static str {
                "op_discord_get_channel_pins"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg1,
                    ) {
                        Ok(t) => t,
                        Err(arg1_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg1_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                            deno_core::_ops::RustToV8Marker::<
                                deno_core::_ops::SerdeMarker,
                                _,
                            >::from(result),
                            scope,
                        )
                    },
                ) {
                    match result {
                        Ok(result) => {
                            match deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                                deno_core::_ops::RustToV8Marker::<
                                    deno_core::_ops::SerdeMarker,
                                    _,
                                >::from(result),
                                &mut scope,
                            ) {
                                Ok(v) => rv.set(v),
                                Err(rv_err) => {
                                    let msg = deno_core::v8::String::new(
                                            &mut scope,
                                            &{
                                                let res = ::alloc::fmt::format(
                                                    format_args!("{0}", deno_core::anyhow::Error::from(rv_err)),
                                                );
                                                res
                                            },
                                        )
                                        .unwrap();
                                    let exc = deno_core::v8::Exception::type_error(
                                        &mut scope,
                                        msg,
                                    );
                                    scope.throw_exception(exc);
                                    return 1;
                                }
                            }
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state: Rc<RefCell<OpState>>,
                channel_id: Id<ChannelMarker>,
            ) -> Result<Vec<Message>, AnyError> {
                let rt_ctx = get_rt_ctx(&state);
                get_guild_channel(&state, &rt_ctx, channel_id).await?;
                let pins = discord_request(
                        &state,
                        async move {
                            rt_ctx.discord_config.client.pins(channel_id).await
                        },
                    )
                    .await?
                    .model()
                    .await?;
                pins.into_iter().map(TryInto::try_into).collect::<Result<_, _>>()
            }
        }
        #[allow(non_camel_case_types)]
        pub struct op_discord_create_pin {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_discord_create_pin {
            const NAME: &'static str = "op_discord_create_pin";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_discord_create_pin".as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    ("op_discord_create_pin", ::deno_core::FastStaticString::new(s))
                },
                true,
                false,
                4usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_discord_create_pin {
            pub const fn name() -> &'static str {
                "op_discord_create_pin"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg1,
                    ) {
                        Ok(t) => t,
                        Err(arg1_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg1_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg2 = args.get(2usize as i32);
                    let arg2 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg2,
                    ) {
                        Ok(t) => t,
                        Err(arg2_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg2_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1, arg2)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        Ok(deno_core::_ops::RustToV8::to_v8(result, scope))
                    },
                ) {
                    match result {
                        Ok(result) => {
                            deno_core::_ops::RustToV8RetVal::to_v8_rv(result, &mut rv)
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state: Rc<RefCell<OpState>>,
                channel_id: Id<ChannelMarker>,
                message_id: Id<MessageMarker>,
            ) -> Result<(), AnyError> {
                let rt_ctx = get_rt_ctx(&state);
                get_guild_channel(&state, &rt_ctx, channel_id).await?;
                discord_request(
                        &state,
                        async move {
                            rt_ctx
                                .discord_config
                                .client
                                .create_pin(channel_id, message_id)
                                .await
                        },
                    )
                    .await?;
                Ok(())
            }
        }
        #[allow(non_camel_case_types)]
        pub struct op_discord_delete_pin {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_discord_delete_pin {
            const NAME: &'static str = "op_discord_delete_pin";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_discord_delete_pin".as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    ("op_discord_delete_pin", ::deno_core::FastStaticString::new(s))
                },
                true,
                false,
                4usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_discord_delete_pin {
            pub const fn name() -> &'static str {
                "op_discord_delete_pin"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg1,
                    ) {
                        Ok(t) => t,
                        Err(arg1_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg1_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg2 = args.get(2usize as i32);
                    let arg2 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg2,
                    ) {
                        Ok(t) => t,
                        Err(arg2_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg2_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1, arg2)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        Ok(deno_core::_ops::RustToV8::to_v8(result, scope))
                    },
                ) {
                    match result {
                        Ok(result) => {
                            deno_core::_ops::RustToV8RetVal::to_v8_rv(result, &mut rv)
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state: Rc<RefCell<OpState>>,
                channel_id: Id<ChannelMarker>,
                message_id: Id<MessageMarker>,
            ) -> Result<(), AnyError> {
                let rt_ctx = get_rt_ctx(&state);
                get_guild_channel(&state, &rt_ctx, channel_id).await?;
                discord_request(
                        &state,
                        async move {
                            rt_ctx
                                .discord_config
                                .client
                                .delete_pin(channel_id, message_id)
                                .await
                        },
                    )
                    .await?;
                Ok(())
            }
        }
        #[allow(non_camel_case_types)]
        pub struct op_discord_get_members {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_discord_get_members {
            const NAME: &'static str = "op_discord_get_members";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_discord_get_members".as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    ("op_discord_get_members", ::deno_core::FastStaticString::new(s))
                },
                true,
                false,
                3usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_discord_get_members {
            pub const fn name() -> &'static str {
                "op_discord_get_members"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg1,
                    ) {
                        Ok(t) => t,
                        Err(arg1_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg1_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                            deno_core::_ops::RustToV8Marker::<
                                deno_core::_ops::SerdeMarker,
                                _,
                            >::from(result),
                            scope,
                        )
                    },
                ) {
                    match result {
                        Ok(result) => {
                            match deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                                deno_core::_ops::RustToV8Marker::<
                                    deno_core::_ops::SerdeMarker,
                                    _,
                                >::from(result),
                                &mut scope,
                            ) {
                                Ok(v) => rv.set(v),
                                Err(rv_err) => {
                                    let msg = deno_core::v8::String::new(
                                            &mut scope,
                                            &{
                                                let res = ::alloc::fmt::format(
                                                    format_args!("{0}", deno_core::anyhow::Error::from(rv_err)),
                                                );
                                                res
                                            },
                                        )
                                        .unwrap();
                                    let exc = deno_core::v8::Exception::type_error(
                                        &mut scope,
                                        msg,
                                    );
                                    scope.throw_exception(exc);
                                    return 1;
                                }
                            }
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state: Rc<RefCell<OpState>>,
                user_ids: Vec<String>,
            ) -> Result<
                Vec<Option<runtime_models::internal::member::Member>>,
                AnyError,
            > {
                let rt_ctx = get_rt_ctx(&state);
                if user_ids.len() > 100 {
                    return Err(
                        ::anyhow::__private::must_use({
                            let error = ::anyhow::__private::format_err(
                                format_args!("too many user ids provided, max 100"),
                            );
                            error
                        }),
                    );
                }
                if user_ids.is_empty() {
                    return Ok(::alloc::vec::Vec::new());
                }
                let ids = user_ids
                    .into_iter()
                    .map(|v| v.parse().map(Id::new_checked).ok().flatten())
                    .collect::<Vec<_>>();
                let valid_ids = ids.iter().filter(|v| v.is_some()).count();
                if valid_ids > 2 {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event components/runtime/src/extensions/discord.rs:1720",
                                    "runtime::extensions::discord",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some(
                                        "components/runtime/src/extensions/discord.rs",
                                    ),
                                    ::core::option::Option::Some(1720u32),
                                    ::core::option::Option::Some(
                                        "runtime::extensions::discord",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if match ::tracing::Level::INFO {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                } <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match ::tracing::Level::INFO {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let meta = __CALLSITE.metadata();
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(meta.target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    ::tracing::__macro_support::__tracing_log(
                                                        meta,
                                                        logger,
                                                        log_meta,
                                                        &value_set,
                                                    )
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("Fetching members through gateway")
                                                        as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if match ::tracing::Level::INFO {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            } <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match ::tracing::Level::INFO {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let meta = __CALLSITE.metadata();
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(meta.target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                ::tracing::__macro_support::__tracing_log(
                                                    meta,
                                                    logger,
                                                    log_meta,
                                                    &{
                                                        #[allow(unused_imports)]
                                                        use ::tracing::field::{debug, display, Value};
                                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                                        __CALLSITE
                                                            .metadata()
                                                            .fields()
                                                            .value_set(
                                                                &[
                                                                    (
                                                                        &::core::iter::Iterator::next(&mut iter)
                                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                                        ::core::option::Option::Some(
                                                                            &format_args!("Fetching members through gateway")
                                                                                as &dyn Value,
                                                                        ),
                                                                    ),
                                                                ],
                                                            )
                                                    },
                                                )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let resp = rt_ctx
                        .bot_state
                        .get_guild_members(
                            rt_ctx.guild_id,
                            ids.iter().filter_map(|v| *v).collect(),
                        )
                        .await?;
                    let mut ret = Vec::with_capacity(ids.len());
                    for id in ids {
                        match id {
                            Some(user_id) => {
                                ret.push(
                                    resp
                                        .iter()
                                        .find(|v| v.user.id == user_id)
                                        .cloned()
                                        .map(From::from),
                                )
                            }
                            None => ret.push(None),
                        }
                    }
                    Ok(ret)
                } else {
                    Ok(fetch_members_through_api(&state, &rt_ctx, ids).await?)
                }
            }
        }
        async fn fetch_members_through_api(
            state: &Rc<RefCell<OpState>>,
            rt_ctx: &RuntimeContext,
            ids: Vec<Option<Id<UserMarker>>>,
        ) -> Result<Vec<Option<runtime_models::internal::member::Member>>, AnyError> {
            let mut res = Vec::new();
            for item in ids {
                if let Some(id) = item {
                    let cloned_discord = rt_ctx.discord_config.clone();
                    let guild_id = rt_ctx.guild_id;
                    let resp = discord_request(
                            state,
                            async move {
                                cloned_discord.client.guild_member(guild_id, id).await
                            },
                        )
                        .await;
                    match resp {
                        Ok(next) => {
                            let member = next.model().await?;
                            res.push(Some(member.into()))
                        }
                        Err(err) => {
                            let class = get_custom_error_class(&err);
                            if !match class {
                                Some(DISCORD_NOT_FOUND_CLASS_NAME) => true,
                                _ => false,
                            } {
                                return Err(err);
                            }
                            res.push(None);
                        }
                    }
                } else {
                    res.push(None)
                }
            }
            Ok(res)
        }
        #[allow(non_camel_case_types)]
        pub struct op_discord_add_member_role {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_discord_add_member_role {
            const NAME: &'static str = "op_discord_add_member_role";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_discord_add_member_role"
                        .as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    ("op_discord_add_member_role", ::deno_core::FastStaticString::new(s))
                },
                true,
                false,
                4usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_discord_add_member_role {
            pub const fn name() -> &'static str {
                "op_discord_add_member_role"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg1,
                    ) {
                        Ok(t) => t,
                        Err(arg1_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg1_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg2 = args.get(2usize as i32);
                    let arg2 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg2,
                    ) {
                        Ok(t) => t,
                        Err(arg2_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg2_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1, arg2)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        Ok(deno_core::_ops::RustToV8::to_v8(result, scope))
                    },
                ) {
                    match result {
                        Ok(result) => {
                            deno_core::_ops::RustToV8RetVal::to_v8_rv(result, &mut rv)
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state: Rc<RefCell<OpState>>,
                user_id: Id<UserMarker>,
                role_id: Id<RoleMarker>,
            ) -> Result<(), AnyError> {
                let rt_ctx = get_rt_ctx(&state);
                discord_request(
                        &state,
                        async move {
                            rt_ctx
                                .discord_config
                                .client
                                .add_guild_member_role(rt_ctx.guild_id, user_id, role_id)
                                .await
                        },
                    )
                    .await?;
                Ok(())
            }
        }
        #[allow(non_camel_case_types)]
        pub struct op_discord_remove_member_role {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_discord_remove_member_role {
            const NAME: &'static str = "op_discord_remove_member_role";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_discord_remove_member_role"
                        .as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    (
                        "op_discord_remove_member_role",
                        ::deno_core::FastStaticString::new(s),
                    )
                },
                true,
                false,
                4usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_discord_remove_member_role {
            pub const fn name() -> &'static str {
                "op_discord_remove_member_role"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg1,
                    ) {
                        Ok(t) => t,
                        Err(arg1_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg1_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg2 = args.get(2usize as i32);
                    let arg2 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg2,
                    ) {
                        Ok(t) => t,
                        Err(arg2_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg2_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1, arg2)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        Ok(deno_core::_ops::RustToV8::to_v8(result, scope))
                    },
                ) {
                    match result {
                        Ok(result) => {
                            deno_core::_ops::RustToV8RetVal::to_v8_rv(result, &mut rv)
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state: Rc<RefCell<OpState>>,
                user_id: Id<UserMarker>,
                role_id: Id<RoleMarker>,
            ) -> Result<(), AnyError> {
                let rt_ctx = get_rt_ctx(&state);
                discord_request(
                        &state,
                        async move {
                            rt_ctx
                                .discord_config
                                .client
                                .remove_guild_member_role(rt_ctx.guild_id, user_id, role_id)
                                .await
                        },
                    )
                    .await?;
                Ok(())
            }
        }
        #[allow(non_camel_case_types)]
        pub struct op_discord_update_member {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_discord_update_member {
            const NAME: &'static str = "op_discord_update_member";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_discord_update_member".as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    ("op_discord_update_member", ::deno_core::FastStaticString::new(s))
                },
                true,
                false,
                4usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_discord_update_member {
            pub const fn name() -> &'static str {
                "op_discord_update_member"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg1,
                    ) {
                        Ok(t) => t,
                        Err(arg1_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg1_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg2 = args.get(2usize as i32);
                    let arg2 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg2,
                    ) {
                        Ok(t) => t,
                        Err(arg2_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg2_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1, arg2)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                            deno_core::_ops::RustToV8Marker::<
                                deno_core::_ops::SerdeMarker,
                                _,
                            >::from(result),
                            scope,
                        )
                    },
                ) {
                    match result {
                        Ok(result) => {
                            match deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                                deno_core::_ops::RustToV8Marker::<
                                    deno_core::_ops::SerdeMarker,
                                    _,
                                >::from(result),
                                &mut scope,
                            ) {
                                Ok(v) => rv.set(v),
                                Err(rv_err) => {
                                    let msg = deno_core::v8::String::new(
                                            &mut scope,
                                            &{
                                                let res = ::alloc::fmt::format(
                                                    format_args!("{0}", deno_core::anyhow::Error::from(rv_err)),
                                                );
                                                res
                                            },
                                        )
                                        .unwrap();
                                    let exc = deno_core::v8::Exception::type_error(
                                        &mut scope,
                                        msg,
                                    );
                                    scope.throw_exception(exc);
                                    return 1;
                                }
                            }
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state: Rc<RefCell<OpState>>,
                user_id: Id<UserMarker>,
                fields: UpdateGuildMemberFields,
            ) -> Result<runtime_models::internal::member::Member, AnyError> {
                let rt_ctx = get_rt_ctx(&state);
                Ok(
                    discord_request_with_extra_error(
                            &state,
                            async move {
                                let mut builder = rt_ctx
                                    .discord_config
                                    .client
                                    .update_guild_member(rt_ctx.guild_id, user_id);
                                if let Some(maybe_cid) = fields.channel_id {
                                    builder = builder.channel_id(maybe_cid);
                                }
                                if let Some(deaf) = fields.deaf {
                                    builder = builder.deaf(deaf);
                                }
                                if let Some(mute) = fields.mute {
                                    builder = builder.mute(mute);
                                }
                                if let Some(maybe_nick) = &fields.nick {
                                    builder = builder.nick(maybe_nick.as_deref())?;
                                }
                                if let Some(roles) = &fields.roles {
                                    builder = builder.roles(roles);
                                }
                                if let Some(ts) = &fields.communication_disabled_until {
                                    builder = builder
                                        .communication_disabled_until(
                                            ts
                                                .map(|v| twilight_model::util::Timestamp::from_micros(
                                                    v.0 as i64 * 1000,
                                                ))
                                                .transpose()?,
                                        )?;
                                }
                                Ok(builder.await)
                            },
                        )
                        .await?
                        .model()
                        .await?
                        .into(),
                )
            }
        }
        #[allow(non_camel_case_types)]
        pub struct op_discord_create_ban {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_discord_create_ban {
            const NAME: &'static str = "op_discord_create_ban";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_discord_create_ban".as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    ("op_discord_create_ban", ::deno_core::FastStaticString::new(s))
                },
                true,
                false,
                4usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_discord_create_ban {
            pub const fn name() -> &'static str {
                "op_discord_create_ban"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg1,
                    ) {
                        Ok(t) => t,
                        Err(arg1_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg1_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg2 = args.get(2usize as i32);
                    let arg2 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg2,
                    ) {
                        Ok(t) => t,
                        Err(arg2_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg2_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1, arg2)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        Ok(deno_core::_ops::RustToV8::to_v8(result, scope))
                    },
                ) {
                    match result {
                        Ok(result) => {
                            deno_core::_ops::RustToV8RetVal::to_v8_rv(result, &mut rv)
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state: Rc<RefCell<OpState>>,
                user_id: Id<UserMarker>,
                extras: CreateBanFields,
            ) -> Result<(), AnyError> {
                let rt_ctx = get_rt_ctx(&state);
                discord_request_with_extra_error(
                        &state,
                        async move {
                            let mut req = rt_ctx
                                .discord_config
                                .client
                                .create_ban(rt_ctx.guild_id, user_id);
                            if let Some(days) = extras.delete_message_days {
                                req = req.delete_message_seconds(days * 24 * 60 * 60)?;
                            }
                            if let Some(reason) = &extras.audit_log_reason {
                                req = req.reason(reason)?;
                            }
                            Ok(req.await)
                        },
                    )
                    .await?;
                Ok(())
            }
        }
        #[allow(non_camel_case_types)]
        pub struct op_discord_get_ban {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_discord_get_ban {
            const NAME: &'static str = "op_discord_get_ban";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_discord_get_ban".as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    ("op_discord_get_ban", ::deno_core::FastStaticString::new(s))
                },
                true,
                false,
                3usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_discord_get_ban {
            pub const fn name() -> &'static str {
                "op_discord_get_ban"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg1,
                    ) {
                        Ok(t) => t,
                        Err(arg1_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg1_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                            deno_core::_ops::RustToV8Marker::<
                                deno_core::_ops::SerdeMarker,
                                _,
                            >::from(result),
                            scope,
                        )
                    },
                ) {
                    match result {
                        Ok(result) => {
                            match deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                                deno_core::_ops::RustToV8Marker::<
                                    deno_core::_ops::SerdeMarker,
                                    _,
                                >::from(result),
                                &mut scope,
                            ) {
                                Ok(v) => rv.set(v),
                                Err(rv_err) => {
                                    let msg = deno_core::v8::String::new(
                                            &mut scope,
                                            &{
                                                let res = ::alloc::fmt::format(
                                                    format_args!("{0}", deno_core::anyhow::Error::from(rv_err)),
                                                );
                                                res
                                            },
                                        )
                                        .unwrap();
                                    let exc = deno_core::v8::Exception::type_error(
                                        &mut scope,
                                        msg,
                                    );
                                    scope.throw_exception(exc);
                                    return 1;
                                }
                            }
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state: Rc<RefCell<OpState>>,
                user_id: Id<UserMarker>,
            ) -> Result<Ban, AnyError> {
                let rt_ctx = get_rt_ctx(&state);
                Ok(
                    discord_request(
                            &state,
                            async move {
                                rt_ctx
                                    .discord_config
                                    .client
                                    .ban(rt_ctx.guild_id, user_id)
                                    .await
                            },
                        )
                        .await?
                        .model()
                        .await?
                        .into(),
                )
            }
        }
        #[allow(non_camel_case_types)]
        pub struct op_discord_get_bans {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_discord_get_bans {
            const NAME: &'static str = "op_discord_get_bans";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_discord_get_bans".as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    ("op_discord_get_bans", ::deno_core::FastStaticString::new(s))
                },
                true,
                false,
                2usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_discord_get_bans {
            pub const fn name() -> &'static str {
                "op_discord_get_bans"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg0 = opstate.clone();
                    Self::call(arg0)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                            deno_core::_ops::RustToV8Marker::<
                                deno_core::_ops::SerdeMarker,
                                _,
                            >::from(result),
                            scope,
                        )
                    },
                ) {
                    match result {
                        Ok(result) => {
                            match deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                                deno_core::_ops::RustToV8Marker::<
                                    deno_core::_ops::SerdeMarker,
                                    _,
                                >::from(result),
                                &mut scope,
                            ) {
                                Ok(v) => rv.set(v),
                                Err(rv_err) => {
                                    let msg = deno_core::v8::String::new(
                                            &mut scope,
                                            &{
                                                let res = ::alloc::fmt::format(
                                                    format_args!("{0}", deno_core::anyhow::Error::from(rv_err)),
                                                );
                                                res
                                            },
                                        )
                                        .unwrap();
                                    let exc = deno_core::v8::Exception::type_error(
                                        &mut scope,
                                        msg,
                                    );
                                    scope.throw_exception(exc);
                                    return 1;
                                }
                            }
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state: Rc<RefCell<OpState>>,
            ) -> Result<Vec<Ban>, AnyError> {
                let rt_ctx = get_rt_ctx(&state);
                let result = discord_request(
                        &state,
                        async move {
                            rt_ctx.discord_config.client.bans(rt_ctx.guild_id).await
                        },
                    )
                    .await?
                    .model()
                    .await?;
                Ok(result.into_iter().map(Into::into).collect())
            }
        }
        #[allow(non_camel_case_types)]
        pub struct op_discord_delete_ban {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_discord_delete_ban {
            const NAME: &'static str = "op_discord_delete_ban";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_discord_delete_ban".as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    ("op_discord_delete_ban", ::deno_core::FastStaticString::new(s))
                },
                true,
                false,
                4usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_discord_delete_ban {
            pub const fn name() -> &'static str {
                "op_discord_delete_ban"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg1,
                    ) {
                        Ok(t) => t,
                        Err(arg1_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg1_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg2 = args.get(2usize as i32);
                    let arg2 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg2,
                    ) {
                        Ok(t) => t,
                        Err(arg2_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg2_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1, arg2)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        Ok(deno_core::_ops::RustToV8::to_v8(result, scope))
                    },
                ) {
                    match result {
                        Ok(result) => {
                            deno_core::_ops::RustToV8RetVal::to_v8_rv(result, &mut rv)
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state: Rc<RefCell<OpState>>,
                user_id: Id<UserMarker>,
                extras: AuditLogExtras,
            ) -> Result<(), AnyError> {
                let rt_ctx = get_rt_ctx(&state);
                discord_request_with_extra_error(
                        &state,
                        async move {
                            let mut req = rt_ctx
                                .discord_config
                                .client
                                .delete_ban(rt_ctx.guild_id, user_id);
                            if let Some(reason) = &extras.audit_log_reason {
                                req = req.reason(reason)?;
                            }
                            Ok(req.await)
                        },
                    )
                    .await?;
                Ok(())
            }
        }
        #[allow(non_camel_case_types)]
        pub struct op_discord_remove_member {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_discord_remove_member {
            const NAME: &'static str = "op_discord_remove_member";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_discord_remove_member".as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    ("op_discord_remove_member", ::deno_core::FastStaticString::new(s))
                },
                true,
                false,
                4usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_discord_remove_member {
            pub const fn name() -> &'static str {
                "op_discord_remove_member"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg1,
                    ) {
                        Ok(t) => t,
                        Err(arg1_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg1_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg2 = args.get(2usize as i32);
                    let arg2 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg2,
                    ) {
                        Ok(t) => t,
                        Err(arg2_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg2_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1, arg2)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        Ok(deno_core::_ops::RustToV8::to_v8(result, scope))
                    },
                ) {
                    match result {
                        Ok(result) => {
                            deno_core::_ops::RustToV8RetVal::to_v8_rv(result, &mut rv)
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state: Rc<RefCell<OpState>>,
                user_id: Id<UserMarker>,
                extras: AuditLogExtras,
            ) -> Result<(), AnyError> {
                let rt_ctx = get_rt_ctx(&state);
                discord_request_with_extra_error(
                        &state,
                        async move {
                            let mut req = rt_ctx
                                .discord_config
                                .client
                                .remove_guild_member(rt_ctx.guild_id, user_id);
                            if let Some(reason) = &extras.audit_log_reason {
                                req = req.reason(reason)?;
                            }
                            Ok(req.await)
                        },
                    )
                    .await?;
                Ok(())
            }
        }
        #[allow(non_camel_case_types)]
        pub struct op_discord_get_member_permissions {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_discord_get_member_permissions {
            const NAME: &'static str = "op_discord_get_member_permissions";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_discord_get_member_permissions"
                        .as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    (
                        "op_discord_get_member_permissions",
                        ::deno_core::FastStaticString::new(s),
                    )
                },
                true,
                false,
                4usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_discord_get_member_permissions {
            pub const fn name() -> &'static str {
                "op_discord_get_member_permissions"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg1,
                    ) {
                        Ok(t) => t,
                        Err(arg1_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg1_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg2 = args.get(2usize as i32);
                    let arg2 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg2,
                    ) {
                        Ok(t) => t,
                        Err(arg2_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg2_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1, arg2)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                            deno_core::_ops::RustToV8Marker::<
                                deno_core::_ops::SerdeMarker,
                                _,
                            >::from(result),
                            scope,
                        )
                    },
                ) {
                    match result {
                        Ok(result) => {
                            match deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                                deno_core::_ops::RustToV8Marker::<
                                    deno_core::_ops::SerdeMarker,
                                    _,
                                >::from(result),
                                &mut scope,
                            ) {
                                Ok(v) => rv.set(v),
                                Err(rv_err) => {
                                    let msg = deno_core::v8::String::new(
                                            &mut scope,
                                            &{
                                                let res = ::alloc::fmt::format(
                                                    format_args!("{0}", deno_core::anyhow::Error::from(rv_err)),
                                                );
                                                res
                                            },
                                        )
                                        .unwrap();
                                    let exc = deno_core::v8::Exception::type_error(
                                        &mut scope,
                                        msg,
                                    );
                                    scope.throw_exception(exc);
                                    return 1;
                                }
                            }
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state: Rc<RefCell<OpState>>,
                user_id: Id<UserMarker>,
                (
                    roles,
                    channel_id,
                ): (Option<Vec<Id<RoleMarker>>>, Option<Id<ChannelMarker>>),
            ) -> Result<(String, Option<String>), AnyError> {
                let rt_ctx = get_rt_ctx(&state);
                let member_roles = if let Some(roles) = roles {
                    roles
                } else {
                    let cloned_discord = rt_ctx.discord_config.clone();
                    let member = discord_request(
                            &state,
                            async move {
                                cloned_discord
                                    .client
                                    .guild_member(rt_ctx.guild_id, user_id)
                                    .await
                            },
                        )
                        .await?
                        .model()
                        .await?;
                    member.roles
                };
                let guild_roles = rt_ctx.bot_state.get_roles(rt_ctx.guild_id).await?;
                let guild = if let Some(guild) = rt_ctx
                    .bot_state
                    .get_guild(rt_ctx.guild_id)
                    .await?
                {
                    guild
                } else {
                    return Err(
                        ::anyhow::__private::must_use({
                            let error = ::anyhow::__private::format_err(
                                format_args!("guild not in state"),
                            );
                            error
                        }),
                    );
                };
                let role_perms_pair = member_roles
                    .iter()
                    .filter_map(|rid| {
                        guild_roles
                            .iter()
                            .find(|r| r.id == *rid)
                            .map(|r| (*rid, r.permissions))
                    })
                    .collect::<Vec<_>>();
                let everyone_role = guild_roles
                    .iter()
                    .find(|v| v.id == rt_ctx.guild_id.cast::<RoleMarker>())
                    .map(|v| v.permissions)
                    .unwrap_or(Permissions::empty());
                let calc = twilight_util::permission_calculator::PermissionCalculator::new(
                        rt_ctx.guild_id,
                        user_id,
                        everyone_role,
                        role_perms_pair.as_slice(),
                    )
                    .owner_id(guild.owner_id);
                let guild_perms = calc.root();
                let channel_perms = if let Some(channel_id) = channel_id {
                    let channel = get_guild_channel(&state, &rt_ctx, channel_id).await?;
                    match channel.kind {
                        twilight_model::channel::ChannelType::AnnouncementThread
                        | twilight_model::channel::ChannelType::PublicThread
                        | twilight_model::channel::ChannelType::PrivateThread => {
                            let real_channel = get_guild_channel(
                                    &state,
                                    &rt_ctx,
                                    channel
                                        .parent_id
                                        .ok_or_else(|| ::anyhow::__private::must_use({
                                            let error = ::anyhow::__private::format_err(
                                                format_args!("thread has no parent??"),
                                            );
                                            error
                                        }))?,
                                )
                                .await?;
                            Some(
                                calc
                                    .in_channel(
                                        real_channel.kind,
                                        real_channel
                                            .permission_overwrites
                                            .as_deref()
                                            .unwrap_or_default(),
                                    ),
                            )
                        }
                        _ => {
                            Some(
                                calc
                                    .in_channel(
                                        channel.kind,
                                        channel.permission_overwrites.as_deref().unwrap_or_default(),
                                    ),
                            )
                        }
                    }
                } else {
                    None
                };
                Ok((
                    guild_perms.bits().to_string(),
                    channel_perms.map(|v| v.bits().to_string()),
                ))
            }
        }
    }
    pub mod httpclient {
        use std::{
            borrow::Cow, cell::RefCell, collections::HashMap, pin::Pin, rc::Rc,
            str::FromStr, time::Duration,
        };
        use deno_core::{
            op2, AsyncRefCell, AsyncResult, BufView, CancelFuture, CancelHandle,
            CancelTryFuture, OpState, RcRef, Resource, ResourceId, WriteOutcome,
        };
        use futures::Stream;
        use reqwest::Body;
        use runtime_models::internal::httpclient::{
            ClientHttpRequest, ClientHttpResponse,
        };
        use tokio::{io::AsyncReadExt, sync::mpsc};
        use tokio_stream::{wrappers::ReceiverStream, StreamExt};
        use tokio_util::io::StreamReader;
        use tracing::info;
        use url::Url;
        use vm::AnyError;
        use crate::limits::RateLimiters;
        ///
        /// An extension for use with the Deno JS runtime.
        /// To use it, provide it as an argument when instantiating your runtime:
        ///
        /// ```rust,ignore
        /// use deno_core::{ JsRuntime, RuntimeOptions };
        ///
        ///let mut extensions = vec![bl_http::init_ops_and_esm()];
        /// let mut js_runtime = JsRuntime::new(RuntimeOptions {
        ///   extensions,
        ///   ..Default::default()
        /// });
        /// ```
        ///
        #[allow(non_camel_case_types)]
        pub struct bl_http {}
        impl bl_http {
            fn ext() -> ::deno_core::Extension {
                #[allow(unused_imports)]
                use ::deno_core::Op;
                ::deno_core::Extension {
                    name: "bl_http",
                    deps: &[],
                    js_files: {
                        const JS: &'static [::deno_core::ExtensionFileSource] = &[];
                        ::std::borrow::Cow::Borrowed(JS)
                    },
                    esm_files: {
                        const JS: &'static [::deno_core::ExtensionFileSource] = &[];
                        ::std::borrow::Cow::Borrowed(JS)
                    },
                    lazy_loaded_esm_files: {
                        const JS: &'static [::deno_core::ExtensionFileSource] = &[];
                        ::std::borrow::Cow::Borrowed(JS)
                    },
                    esm_entry_point: {
                        const V: ::std::option::Option<&'static ::std::primitive::str> = ::std::option::Option::None;
                        V
                    },
                    ops: ::std::borrow::Cow::Borrowed(
                        &[op_bl_http_client_stream::DECL, op_bl_http_request_send::DECL],
                    ),
                    external_references: ::std::borrow::Cow::Borrowed(&[]),
                    global_template_middleware: ::std::option::Option::None,
                    global_object_middleware: ::std::option::Option::None,
                    op_state_fn: ::std::option::Option::None,
                    middleware_fn: ::std::option::Option::None,
                    enabled: true,
                }
            }
            #[inline(always)]
            #[allow(unused_variables)]
            fn with_ops_fn(ext: &mut ::deno_core::Extension) {}
            #[inline(always)]
            #[allow(unused_variables)]
            fn with_state_and_middleware(ext: &mut ::deno_core::Extension) {}
            #[inline(always)]
            #[allow(unused_variables)]
            #[allow(clippy::redundant_closure_call)]
            fn with_customizer(ext: &mut ::deno_core::Extension) {}
            #[allow(dead_code)]
            /// Initialize this extension for runtime or snapshot creation. Use this
            /// function if the runtime or snapshot is not created from a (separate)
            /// snapshot, or that snapshot does not contain this extension. Otherwise
            /// use `init_ops()` instead.
            ///
            /// # Returns
            /// an Extension object that can be used during instantiation of a JsRuntime
            pub fn init_ops_and_esm() -> ::deno_core::Extension {
                let mut ext = Self::ext();
                Self::with_ops_fn(&mut ext);
                Self::with_state_and_middleware(&mut ext);
                Self::with_customizer(&mut ext);
                ext
            }
            #[allow(dead_code)]
            /// Initialize this extension for runtime or snapshot creation, excluding
            /// its JavaScript sources and evaluation. This is used when the runtime
            /// or snapshot is created from a (separate) snapshot which includes this
            /// extension in order to avoid evaluating the JavaScript twice.
            ///
            /// # Returns
            /// an Extension object that can be used during instantiation of a JsRuntime
            pub fn init_ops() -> ::deno_core::Extension {
                let mut ext = Self::ext();
                Self::with_ops_fn(&mut ext);
                Self::with_state_and_middleware(&mut ext);
                Self::with_customizer(&mut ext);
                ext.js_files = ::std::borrow::Cow::Borrowed(&[]);
                ext.esm_files = ::std::borrow::Cow::Borrowed(&[]);
                ext.esm_entry_point = ::std::option::Option::None;
                ext
            }
        }
        #[allow(non_camel_case_types)]
        pub struct op_bl_http_client_stream {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_bl_http_client_stream {
            const NAME: &'static str = "op_bl_http_client_stream";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_bl_http_client_stream".as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    ("op_bl_http_client_stream", ::deno_core::FastStaticString::new(s))
                },
                false,
                false,
                1usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                Some({
                    use deno_core::v8::fast_api::Type;
                    use deno_core::v8::fast_api::CType;
                    deno_core::v8::fast_api::FastFunction::new_with_bigint(
                        &[Type::V8Value, Type::CallbackOptions],
                        CType::Int32,
                        Self::v8_fn_ptr_fast as *const ::std::ffi::c_void,
                    )
                }),
                Some({
                    use deno_core::v8::fast_api::Type;
                    use deno_core::v8::fast_api::CType;
                    deno_core::v8::fast_api::FastFunction::new_with_bigint(
                        &[Type::V8Value, Type::CallbackOptions],
                        CType::Int32,
                        Self::v8_fn_ptr_fast_metrics as *const ::std::ffi::c_void,
                    )
                }),
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_bl_http_client_stream {
            pub const fn name() -> &'static str {
                "op_bl_http_client_stream"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[allow(clippy::too_many_arguments)]
            fn v8_fn_ptr_fast_metrics(
                this: deno_core::v8::Local<deno_core::v8::Object>,
                fast_api_callback_options: *mut deno_core::v8::fast_api::FastApiCallbackOptions,
            ) -> i32 {
                let fast_api_callback_options = unsafe {
                    &mut *fast_api_callback_options
                };
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<
                        deno_core::v8::External,
                    >::cast(unsafe { fast_api_callback_options.data.data })
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_fast(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::v8_fn_ptr_fast(this, fast_api_callback_options);
                deno_core::_ops::dispatch_metrics_fast(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Completed,
                );
                res
            }
            #[allow(clippy::too_many_arguments)]
            fn v8_fn_ptr_fast(
                _: deno_core::v8::Local<deno_core::v8::Object>,
                fast_api_callback_options: *mut deno_core::v8::fast_api::FastApiCallbackOptions,
            ) -> i32 {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let fast_api_callback_options = unsafe {
                    &mut *fast_api_callback_options
                };
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<
                        deno_core::v8::External,
                    >::cast(unsafe { fast_api_callback_options.data.data })
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let result = {
                    let arg0 = &mut ::std::cell::RefCell::borrow_mut(&opctx.state);
                    Self::call(arg0)
                };
                let result = match result {
                    Ok(result) => result,
                    Err(err) => {
                        let err = err.into();
                        unsafe {
                            opctx.unsafely_set_last_error_for_ops_only(err);
                        }
                        fast_api_callback_options.fallback = true;
                        return unsafe { std::mem::zeroed() };
                    }
                };
                result as _
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                if let Some(err) = unsafe {
                    opctx.unsafely_take_last_error_for_ops_only()
                } {
                    let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                    let err = err.into();
                    let exception = deno_core::error::to_v8_error(
                        &mut scope,
                        opctx.get_error_class_fn,
                        &err,
                    );
                    scope.throw_exception(exception);
                    return 1;
                }
                let result = {
                    let arg0 = &mut ::std::cell::RefCell::borrow_mut(&opstate);
                    Self::call(arg0)
                };
                match result {
                    Ok(result) => {
                        deno_core::_ops::RustToV8RetVal::to_v8_rv(
                            deno_core::_ops::RustToV8Marker::<
                                deno_core::_ops::SmiMarker,
                                _,
                            >::from(result),
                            &mut rv,
                        )
                    }
                    Err(err) => {
                        let mut scope = unsafe {
                            deno_core::v8::CallbackScope::new(&*info)
                        };
                        let err = err.into();
                        let exception = deno_core::error::to_v8_error(
                            &mut scope,
                            opctx.get_error_class_fn,
                            &err,
                        );
                        scope.throw_exception(exception);
                        return 1;
                    }
                };
                return 0;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_slow(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_slow(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else {
                    deno_core::_ops::dispatch_metrics_slow(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub fn call(state: &mut OpState) -> Result<ResourceId, AnyError> {
                let (tx, rx) = mpsc::channel(2);
                let resource = RequestBodyResource {
                    cancel: CancelHandle::new(),
                    tx,
                    rx: RefCell::new(Some(rx)),
                };
                crate::try_insert_resource_table(&mut state.resource_table, resource)
            }
        }
        #[allow(non_camel_case_types)]
        pub struct op_bl_http_request_send {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_bl_http_request_send {
            const NAME: &'static str = "op_bl_http_request_send";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_bl_http_request_send".as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    ("op_bl_http_request_send", ::deno_core::FastStaticString::new(s))
                },
                true,
                false,
                3usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_bl_http_request_send {
            pub const fn name() -> &'static str {
                "op_bl_http_request_send"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg1,
                    ) {
                        Ok(t) => t,
                        Err(arg1_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg1_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                            deno_core::_ops::RustToV8Marker::<
                                deno_core::_ops::SerdeMarker,
                                _,
                            >::from(result),
                            scope,
                        )
                    },
                ) {
                    match result {
                        Ok(result) => {
                            match deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                                deno_core::_ops::RustToV8Marker::<
                                    deno_core::_ops::SerdeMarker,
                                    _,
                                >::from(result),
                                &mut scope,
                            ) {
                                Ok(v) => rv.set(v),
                                Err(rv_err) => {
                                    let msg = deno_core::v8::String::new(
                                            &mut scope,
                                            &{
                                                let res = ::alloc::fmt::format(
                                                    format_args!("{0}", deno_core::anyhow::Error::from(rv_err)),
                                                );
                                                res
                                            },
                                        )
                                        .unwrap();
                                    let exc = deno_core::v8::Exception::type_error(
                                        &mut scope,
                                        msg,
                                    );
                                    scope.throw_exception(exc);
                                    return 1;
                                }
                            }
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state_rc: Rc<RefCell<OpState>>,
                args: ClientHttpRequest,
            ) -> Result<ClientHttpResponse, AnyError> {
                RateLimiters::user_http(&state_rc).await;
                let req_resource = if let Some(rid) = args.body_resource_id {
                    let state = state_rc.borrow();
                    Some(state.resource_table.get::<RequestBodyResource>(rid)?)
                } else {
                    None
                };
                let parsed_url = Url::parse(&args.path)?;
                let client = {
                    state_rc.borrow_mut().borrow::<reqwest::Client>().clone()
                };
                let mut builder = client
                    .request(reqwest::Method::from_str(&args.method)?, parsed_url);
                for (k, v) in args.headers {
                    builder = builder.header(k, v);
                }
                if let Some(req_resource) = req_resource {
                    let rx = req_resource
                        .rx
                        .borrow_mut()
                        .take()
                        .ok_or_else(|| ::anyhow::__private::must_use({
                            let error = ::anyhow::__private::format_err(
                                format_args!("failed retrieving body resource stream"),
                            );
                            error
                        }))?;
                    builder = builder.body(Body::wrap_stream(ReceiverStream::new(rx)));
                }
                let res = builder.send().await;
                if let Some(rid) = args.body_resource_id {
                    if let Ok(r) = state_rc
                        .borrow_mut()
                        .resource_table
                        .take::<RequestBodyResource>(rid)
                    {
                        r.close()
                    }
                }
                handle_response(state_rc, res?)
            }
        }
        fn handle_response(
            state_rc: Rc<RefCell<OpState>>,
            resp: reqwest::Response,
        ) -> Result<ClientHttpResponse, AnyError> {
            let mut resp_headers = HashMap::<String, String>::new();
            for (k, v) in resp.headers() {
                let header_value = String::from_utf8(v.as_bytes().to_owned())?;
                resp_headers.insert(k.to_string(), header_value);
            }
            let status_code = resp.status();
            let stream: BytesStream = Box::pin(
                resp
                    .bytes_stream()
                    .map(|r| {
                        r
                            .map_err(|err| std::io::Error::new(
                                std::io::ErrorKind::Other,
                                err,
                            ))
                    }),
            );
            let stream_reader = StreamReader::new(stream);
            let rid = state_rc
                .borrow_mut()
                .resource_table
                .add(RequestReponseBodyResource {
                    body: AsyncRefCell::new(stream_reader),
                    cancel: CancelHandle::default(),
                });
            deno_core::unsync::spawn(async move {
                tokio::time::sleep(Duration::from_secs(30)).await;
                let mut borrowed = state_rc.borrow_mut();
                if borrowed.resource_table.has(rid) {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event components/runtime/src/extensions/httpclient.rs:132",
                                    "runtime::extensions::httpclient",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some(
                                        "components/runtime/src/extensions/httpclient.rs",
                                    ),
                                    ::core::option::Option::Some(132u32),
                                    ::core::option::Option::Some(
                                        "runtime::extensions::httpclient",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message", "rid"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if match ::tracing::Level::INFO {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                } <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match ::tracing::Level::INFO {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let meta = __CALLSITE.metadata();
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(meta.target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    ::tracing::__macro_support::__tracing_log(
                                                        meta,
                                                        logger,
                                                        log_meta,
                                                        &value_set,
                                                    )
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("closing resource") as &dyn Value,
                                                ),
                                            ),
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(&display(&rid) as &dyn Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if match ::tracing::Level::INFO {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            } <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match ::tracing::Level::INFO {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let meta = __CALLSITE.metadata();
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(meta.target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                ::tracing::__macro_support::__tracing_log(
                                                    meta,
                                                    logger,
                                                    log_meta,
                                                    &{
                                                        #[allow(unused_imports)]
                                                        use ::tracing::field::{debug, display, Value};
                                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                                        __CALLSITE
                                                            .metadata()
                                                            .fields()
                                                            .value_set(
                                                                &[
                                                                    (
                                                                        &::core::iter::Iterator::next(&mut iter)
                                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                                        ::core::option::Option::Some(
                                                                            &format_args!("closing resource") as &dyn Value,
                                                                        ),
                                                                    ),
                                                                    (
                                                                        &::core::iter::Iterator::next(&mut iter)
                                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                                        ::core::option::Option::Some(&display(&rid) as &dyn Value),
                                                                    ),
                                                                ],
                                                            )
                                                    },
                                                )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    if let Ok(r) = borrowed
                        .resource_table
                        .take::<RequestReponseBodyResource>(rid)
                    {
                        r.close()
                    }
                }
            });
            Ok(ClientHttpResponse {
                body_resource_id: rid,
                headers: resp_headers,
                status_code: status_code.as_u16() as i32,
            })
        }
        struct RequestBodyResource {
            tx: mpsc::Sender<std::io::Result<Vec<u8>>>,
            rx: RefCell<Option<mpsc::Receiver<std::io::Result<Vec<u8>>>>>,
            cancel: CancelHandle,
        }
        impl Resource for RequestBodyResource {
            fn name(&self) -> Cow<str> {
                "requestBodyResource".into()
            }
            fn write(self: Rc<Self>, buf: BufView) -> AsyncResult<WriteOutcome> {
                Box::pin(async move {
                    let data = buf.to_vec();
                    let len = data.len();
                    let body = RcRef::map(&self, |r| &r.tx);
                    let cancel = RcRef::map(self, |r| &r.cancel);
                    body.send(Ok(data))
                        .or_cancel(cancel)
                        .await?
                        .map_err(|_| ::anyhow::__private::must_use({
                            let error = ::anyhow::__private::format_err(
                                format_args!("body is closed"),
                            );
                            error
                        }))?;
                    Ok(WriteOutcome::Full {
                        nwritten: len,
                    })
                })
            }
            fn close(self: Rc<Self>) {
                self.cancel.cancel()
            }
        }
        type BytesStream = Pin<
            Box<dyn Stream<Item = Result<bytes::Bytes, std::io::Error>> + Unpin>,
        >;
        struct RequestReponseBodyResource {
            body: AsyncRefCell<StreamReader<BytesStream, bytes::Bytes>>,
            cancel: CancelHandle,
        }
        impl Resource for RequestReponseBodyResource {
            fn name(&self) -> Cow<str> {
                "requestReponseBodyResource".into()
            }
            fn read(self: Rc<Self>, limit: usize) -> AsyncResult<BufView> {
                Box::pin(async move {
                    let mut reader = RcRef::map(&self, |r| &r.body).borrow_mut().await;
                    let cancel = RcRef::map(self, |r| &r.cancel);
                    let buf_size = if limit < 1024 { limit } else { 1024 };
                    let mut buf = ::alloc::vec::from_elem(0, buf_size);
                    let read = reader.read(&mut buf).try_or_cancel(cancel).await?;
                    buf.truncate(read);
                    Ok(buf.into())
                })
            }
            fn read_byob(
                self: Rc<Self>,
                mut buf: deno_core::BufMutView,
            ) -> AsyncResult<(usize, deno_core::BufMutView)> {
                Box::pin(async move {
                    let mut reader = RcRef::map(&self, |r| &r.body).borrow_mut().await;
                    let cancel = RcRef::map(self, |r| &r.cancel);
                    let read = reader.read(&mut buf).try_or_cancel(cancel).await?;
                    Ok((read, buf))
                })
            }
            fn close(self: Rc<Self>) {
                self.cancel.cancel()
            }
        }
    }
    pub mod storage {
        use std::{cell::RefCell, rc::Rc, time::Duration};
        use anyhow::anyhow;
        use deno_core::{op2, OpState};
        use runtime_models::{
            internal::storage::{
                OpStorageBucketEntry, OpStorageBucketEntryId, OpStorageBucketIncr,
                OpStorageBucketList, OpStorageBucketSetIf, OpStorageBucketSetValue,
                OpStorageBucketSortedList, OpStorageBucketValue,
            },
            util::PluginId,
        };
        use tracing::{info, instrument};
        use twilight_model::id::{marker::GuildMarker, Id};
        use vm::AnyError;
        use crate::RuntimeContext;
        ///
        /// An extension for use with the Deno JS runtime.
        /// To use it, provide it as an argument when instantiating your runtime:
        ///
        /// ```rust,ignore
        /// use deno_core::{ JsRuntime, RuntimeOptions };
        ///
        ///let mut extensions = vec![bl_storage::init_ops_and_esm()];
        /// let mut js_runtime = JsRuntime::new(RuntimeOptions {
        ///   extensions,
        ///   ..Default::default()
        /// });
        /// ```
        ///
        #[allow(non_camel_case_types)]
        pub struct bl_storage {}
        impl bl_storage {
            fn ext() -> ::deno_core::Extension {
                #[allow(unused_imports)]
                use ::deno_core::Op;
                ::deno_core::Extension {
                    name: "bl_storage",
                    deps: &[],
                    js_files: {
                        const JS: &'static [::deno_core::ExtensionFileSource] = &[];
                        ::std::borrow::Cow::Borrowed(JS)
                    },
                    esm_files: {
                        const JS: &'static [::deno_core::ExtensionFileSource] = &[];
                        ::std::borrow::Cow::Borrowed(JS)
                    },
                    lazy_loaded_esm_files: {
                        const JS: &'static [::deno_core::ExtensionFileSource] = &[];
                        ::std::borrow::Cow::Borrowed(JS)
                    },
                    esm_entry_point: {
                        const V: ::std::option::Option<&'static ::std::primitive::str> = ::std::option::Option::None;
                        V
                    },
                    ops: ::std::borrow::Cow::Borrowed(
                        &[
                            op_botloader_bucket_storage_set::DECL,
                            op_botloader_bucket_storage_set_if::DECL,
                            op_botloader_bucket_storage_get::DECL,
                            op_botloader_bucket_storage_del::DECL,
                            op_botloader_bucket_storage_del_many::DECL,
                            op_botloader_bucket_storage_list::DECL,
                            op_botloader_bucket_storage_count::DECL,
                            op_botloader_bucket_storage_incr::DECL,
                            op_botloader_bucket_storage_sorted_list::DECL,
                        ],
                    ),
                    external_references: ::std::borrow::Cow::Borrowed(&[]),
                    global_template_middleware: ::std::option::Option::None,
                    global_object_middleware: ::std::option::Option::None,
                    op_state_fn: ::std::option::Option::None,
                    middleware_fn: ::std::option::Option::None,
                    enabled: true,
                }
            }
            #[inline(always)]
            #[allow(unused_variables)]
            fn with_ops_fn(ext: &mut ::deno_core::Extension) {}
            #[inline(always)]
            #[allow(unused_variables)]
            fn with_state_and_middleware(ext: &mut ::deno_core::Extension) {
                ext
                    .op_state_fn = ::std::option::Option::Some(
                    ::std::boxed::Box::new(|state| {
                        state
                            .put(StorageState {
                                doing_limit_check: false,
                                hit_limit: false,
                                requests_until_limit_check: 0,
                            });
                    }),
                );
            }
            #[inline(always)]
            #[allow(unused_variables)]
            #[allow(clippy::redundant_closure_call)]
            fn with_customizer(ext: &mut ::deno_core::Extension) {}
            #[allow(dead_code)]
            /// Initialize this extension for runtime or snapshot creation. Use this
            /// function if the runtime or snapshot is not created from a (separate)
            /// snapshot, or that snapshot does not contain this extension. Otherwise
            /// use `init_ops()` instead.
            ///
            /// # Returns
            /// an Extension object that can be used during instantiation of a JsRuntime
            pub fn init_ops_and_esm() -> ::deno_core::Extension {
                let mut ext = Self::ext();
                Self::with_ops_fn(&mut ext);
                Self::with_state_and_middleware(&mut ext);
                Self::with_customizer(&mut ext);
                ext
            }
            #[allow(dead_code)]
            /// Initialize this extension for runtime or snapshot creation, excluding
            /// its JavaScript sources and evaluation. This is used when the runtime
            /// or snapshot is created from a (separate) snapshot which includes this
            /// extension in order to avoid evaluating the JavaScript twice.
            ///
            /// # Returns
            /// an Extension object that can be used during instantiation of a JsRuntime
            pub fn init_ops() -> ::deno_core::Extension {
                let mut ext = Self::ext();
                Self::with_ops_fn(&mut ext);
                Self::with_state_and_middleware(&mut ext);
                Self::with_customizer(&mut ext);
                ext.js_files = ::std::borrow::Cow::Borrowed(&[]);
                ext.esm_files = ::std::borrow::Cow::Borrowed(&[]);
                ext.esm_entry_point = ::std::option::Option::None;
                ext
            }
        }
        struct StorageState {
            requests_until_limit_check: u32,
            doing_limit_check: bool,
            hit_limit: bool,
        }
        #[allow(non_camel_case_types)]
        pub struct op_botloader_bucket_storage_set {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_botloader_bucket_storage_set {
            const NAME: &'static str = "op_botloader_bucket_storage_set";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_botloader_bucket_storage_set"
                        .as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    (
                        "op_botloader_bucket_storage_set",
                        ::deno_core::FastStaticString::new(s),
                    )
                },
                true,
                false,
                3usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_botloader_bucket_storage_set {
            pub const fn name() -> &'static str {
                "op_botloader_bucket_storage_set"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg1,
                    ) {
                        Ok(t) => t,
                        Err(arg1_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg1_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                            deno_core::_ops::RustToV8Marker::<
                                deno_core::_ops::SerdeMarker,
                                _,
                            >::from(result),
                            scope,
                        )
                    },
                ) {
                    match result {
                        Ok(result) => {
                            match deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                                deno_core::_ops::RustToV8Marker::<
                                    deno_core::_ops::SerdeMarker,
                                    _,
                                >::from(result),
                                &mut scope,
                            ) {
                                Ok(v) => rv.set(v),
                                Err(rv_err) => {
                                    let msg = deno_core::v8::String::new(
                                            &mut scope,
                                            &{
                                                let res = ::alloc::fmt::format(
                                                    format_args!("{0}", deno_core::anyhow::Error::from(rv_err)),
                                                );
                                                res
                                            },
                                        )
                                        .unwrap();
                                    let exc = deno_core::v8::Exception::type_error(
                                        &mut scope,
                                        msg,
                                    );
                                    scope.throw_exception(exc);
                                    return 1;
                                }
                            }
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state: Rc<RefCell<OpState>>,
                args: OpStorageBucketSetValue,
            ) -> Result<OpStorageBucketEntry, AnyError> {
                let rt_ctx = {
                    let state = state.borrow();
                    state.borrow::<RuntimeContext>().clone()
                };
                check_validate_value_len(&args.value)?;
                check_validate_key_len(&args.key)?;
                check_validate_storage_usage(rt_ctx.guild_id, &rt_ctx, state.clone())
                    .await?;
                let entry = rt_ctx
                    .db
                    .set(
                        rt_ctx.guild_id,
                        args.plugin_id.map(Into::into),
                        args.bucket_name,
                        args.key,
                        args.value,
                        args.ttl.map(|ttl| Duration::from_secs(ttl as u64)),
                    )
                    .await?;
                Ok(entry.into())
            }
        }
        #[allow(non_camel_case_types)]
        pub struct op_botloader_bucket_storage_set_if {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_botloader_bucket_storage_set_if {
            const NAME: &'static str = "op_botloader_bucket_storage_set_if";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_botloader_bucket_storage_set_if"
                        .as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    (
                        "op_botloader_bucket_storage_set_if",
                        ::deno_core::FastStaticString::new(s),
                    )
                },
                true,
                false,
                3usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_botloader_bucket_storage_set_if {
            pub const fn name() -> &'static str {
                "op_botloader_bucket_storage_set_if"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg1,
                    ) {
                        Ok(t) => t,
                        Err(arg1_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg1_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                            deno_core::_ops::RustToV8Marker::<
                                deno_core::_ops::SerdeMarker,
                                _,
                            >::from(result),
                            scope,
                        )
                    },
                ) {
                    match result {
                        Ok(result) => {
                            match deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                                deno_core::_ops::RustToV8Marker::<
                                    deno_core::_ops::SerdeMarker,
                                    _,
                                >::from(result),
                                &mut scope,
                            ) {
                                Ok(v) => rv.set(v),
                                Err(rv_err) => {
                                    let msg = deno_core::v8::String::new(
                                            &mut scope,
                                            &{
                                                let res = ::alloc::fmt::format(
                                                    format_args!("{0}", deno_core::anyhow::Error::from(rv_err)),
                                                );
                                                res
                                            },
                                        )
                                        .unwrap();
                                    let exc = deno_core::v8::Exception::type_error(
                                        &mut scope,
                                        msg,
                                    );
                                    scope.throw_exception(exc);
                                    return 1;
                                }
                            }
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state: Rc<RefCell<OpState>>,
                args: OpStorageBucketSetIf,
            ) -> Result<Option<OpStorageBucketEntry>, AnyError> {
                let rt_ctx = {
                    let state = state.borrow();
                    state.borrow::<RuntimeContext>().clone()
                };
                check_validate_value_len(&args.value)?;
                check_validate_key_len(&args.key)?;
                check_validate_storage_usage(rt_ctx.guild_id, &rt_ctx, state.clone())
                    .await?;
                let entry = rt_ctx
                    .db
                    .set_if(
                        rt_ctx.guild_id,
                        args.plugin_id.map(Into::into),
                        args.bucket_name,
                        args.key,
                        args.value,
                        args.ttl.map(|ttl| Duration::from_secs(ttl as u64)),
                        args.cond,
                    )
                    .await?;
                Ok(entry.map(Into::into))
            }
        }
        #[allow(non_camel_case_types)]
        pub struct op_botloader_bucket_storage_get {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_botloader_bucket_storage_get {
            const NAME: &'static str = "op_botloader_bucket_storage_get";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_botloader_bucket_storage_get"
                        .as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    (
                        "op_botloader_bucket_storage_get",
                        ::deno_core::FastStaticString::new(s),
                    )
                },
                true,
                false,
                3usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_botloader_bucket_storage_get {
            pub const fn name() -> &'static str {
                "op_botloader_bucket_storage_get"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg1,
                    ) {
                        Ok(t) => t,
                        Err(arg1_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg1_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                            deno_core::_ops::RustToV8Marker::<
                                deno_core::_ops::SerdeMarker,
                                _,
                            >::from(result),
                            scope,
                        )
                    },
                ) {
                    match result {
                        Ok(result) => {
                            match deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                                deno_core::_ops::RustToV8Marker::<
                                    deno_core::_ops::SerdeMarker,
                                    _,
                                >::from(result),
                                &mut scope,
                            ) {
                                Ok(v) => rv.set(v),
                                Err(rv_err) => {
                                    let msg = deno_core::v8::String::new(
                                            &mut scope,
                                            &{
                                                let res = ::alloc::fmt::format(
                                                    format_args!("{0}", deno_core::anyhow::Error::from(rv_err)),
                                                );
                                                res
                                            },
                                        )
                                        .unwrap();
                                    let exc = deno_core::v8::Exception::type_error(
                                        &mut scope,
                                        msg,
                                    );
                                    scope.throw_exception(exc);
                                    return 1;
                                }
                            }
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state: Rc<RefCell<OpState>>,
                args: OpStorageBucketEntryId,
            ) -> Result<Option<OpStorageBucketEntry>, AnyError> {
                let rt_ctx = {
                    let state = state.borrow();
                    state.borrow::<RuntimeContext>().clone()
                };
                let entry = rt_ctx
                    .db
                    .get(
                        rt_ctx.guild_id,
                        args.plugin_id.map(Into::into),
                        args.bucket_name,
                        args.key,
                    )
                    .await?;
                Ok(entry.map(Into::into))
            }
        }
        #[allow(non_camel_case_types)]
        pub struct op_botloader_bucket_storage_del {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_botloader_bucket_storage_del {
            const NAME: &'static str = "op_botloader_bucket_storage_del";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_botloader_bucket_storage_del"
                        .as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    (
                        "op_botloader_bucket_storage_del",
                        ::deno_core::FastStaticString::new(s),
                    )
                },
                true,
                false,
                3usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_botloader_bucket_storage_del {
            pub const fn name() -> &'static str {
                "op_botloader_bucket_storage_del"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg1,
                    ) {
                        Ok(t) => t,
                        Err(arg1_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg1_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                            deno_core::_ops::RustToV8Marker::<
                                deno_core::_ops::SerdeMarker,
                                _,
                            >::from(result),
                            scope,
                        )
                    },
                ) {
                    match result {
                        Ok(result) => {
                            match deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                                deno_core::_ops::RustToV8Marker::<
                                    deno_core::_ops::SerdeMarker,
                                    _,
                                >::from(result),
                                &mut scope,
                            ) {
                                Ok(v) => rv.set(v),
                                Err(rv_err) => {
                                    let msg = deno_core::v8::String::new(
                                            &mut scope,
                                            &{
                                                let res = ::alloc::fmt::format(
                                                    format_args!("{0}", deno_core::anyhow::Error::from(rv_err)),
                                                );
                                                res
                                            },
                                        )
                                        .unwrap();
                                    let exc = deno_core::v8::Exception::type_error(
                                        &mut scope,
                                        msg,
                                    );
                                    scope.throw_exception(exc);
                                    return 1;
                                }
                            }
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state: Rc<RefCell<OpState>>,
                args: OpStorageBucketEntryId,
            ) -> Result<Option<OpStorageBucketEntry>, AnyError> {
                let rt_ctx = {
                    let state = state.borrow();
                    state.borrow::<RuntimeContext>().clone()
                };
                let entry = rt_ctx
                    .db
                    .del(
                        rt_ctx.guild_id,
                        args.plugin_id.map(Into::into),
                        args.bucket_name,
                        args.key,
                    )
                    .await?;
                if entry.is_some() {
                    let mut state = state.borrow_mut();
                    let storage_ctx = state.borrow_mut::<StorageState>();
                    storage_ctx.hit_limit = false;
                }
                Ok(entry.map(Into::into))
            }
        }
        #[allow(non_camel_case_types)]
        pub struct op_botloader_bucket_storage_del_many {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_botloader_bucket_storage_del_many {
            const NAME: &'static str = "op_botloader_bucket_storage_del_many";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_botloader_bucket_storage_del_many"
                        .as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    (
                        "op_botloader_bucket_storage_del_many",
                        ::deno_core::FastStaticString::new(s),
                    )
                },
                true,
                false,
                5usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_botloader_bucket_storage_del_many {
            pub const fn name() -> &'static str {
                "op_botloader_bucket_storage_del_many"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg1,
                    ) {
                        Ok(t) => t,
                        Err(arg1_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg1_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg2 = args.get(2usize as i32);
                    let arg2 = deno_core::_ops::to_string(&mut scope, &arg2);
                    let arg3 = args.get(3usize as i32);
                    let arg3 = deno_core::_ops::to_string(&mut scope, &arg3);
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1, arg2, arg3)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        Ok(
                            deno_core::_ops::RustToV8::to_v8(
                                deno_core::_ops::RustToV8Marker::<
                                    deno_core::_ops::NumberMarker,
                                    _,
                                >::from(result),
                                scope,
                            ),
                        )
                    },
                ) {
                    match result {
                        Ok(result) => {
                            deno_core::_ops::RustToV8RetVal::to_v8_rv(
                                deno_core::_ops::RustToV8Marker::<
                                    deno_core::_ops::NumberMarker,
                                    _,
                                >::from(result),
                                &mut rv,
                            )
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state: Rc<RefCell<OpState>>,
                plugin_id: Option<PluginId>,
                bucket_name: String,
                key_pattern: String,
            ) -> Result<u64, AnyError> {
                let rt_ctx = {
                    let state = state.borrow();
                    state.borrow::<RuntimeContext>().clone()
                };
                let res = rt_ctx
                    .db
                    .del_many(
                        rt_ctx.guild_id,
                        plugin_id.map(Into::into),
                        bucket_name,
                        key_pattern,
                    )
                    .await?;
                if res > 0 {
                    let mut state = state.borrow_mut();
                    let storage_ctx = state.borrow_mut::<StorageState>();
                    storage_ctx.hit_limit = false;
                }
                Ok(res)
            }
        }
        #[allow(non_camel_case_types)]
        pub struct op_botloader_bucket_storage_list {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_botloader_bucket_storage_list {
            const NAME: &'static str = "op_botloader_bucket_storage_list";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_botloader_bucket_storage_list"
                        .as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    (
                        "op_botloader_bucket_storage_list",
                        ::deno_core::FastStaticString::new(s),
                    )
                },
                true,
                false,
                3usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_botloader_bucket_storage_list {
            pub const fn name() -> &'static str {
                "op_botloader_bucket_storage_list"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg1,
                    ) {
                        Ok(t) => t,
                        Err(arg1_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg1_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                            deno_core::_ops::RustToV8Marker::<
                                deno_core::_ops::SerdeMarker,
                                _,
                            >::from(result),
                            scope,
                        )
                    },
                ) {
                    match result {
                        Ok(result) => {
                            match deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                                deno_core::_ops::RustToV8Marker::<
                                    deno_core::_ops::SerdeMarker,
                                    _,
                                >::from(result),
                                &mut scope,
                            ) {
                                Ok(v) => rv.set(v),
                                Err(rv_err) => {
                                    let msg = deno_core::v8::String::new(
                                            &mut scope,
                                            &{
                                                let res = ::alloc::fmt::format(
                                                    format_args!("{0}", deno_core::anyhow::Error::from(rv_err)),
                                                );
                                                res
                                            },
                                        )
                                        .unwrap();
                                    let exc = deno_core::v8::Exception::type_error(
                                        &mut scope,
                                        msg,
                                    );
                                    scope.throw_exception(exc);
                                    return 1;
                                }
                            }
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state: Rc<RefCell<OpState>>,
                args: OpStorageBucketList,
            ) -> Result<Vec<OpStorageBucketEntry>, AnyError> {
                let rt_ctx = {
                    let state = state.borrow();
                    state.borrow::<RuntimeContext>().clone()
                };
                let limit = if let Some(limit) = args.limit {
                    if limit < 100 { limit } else { 100 }
                } else {
                    25
                };
                let entries = rt_ctx
                    .db
                    .get_many(
                        rt_ctx.guild_id,
                        args.plugin_id.map(Into::into),
                        args.bucket_name,
                        args.key_pattern.unwrap_or_else(|| "%".to_string()),
                        args.after.unwrap_or_default(),
                        limit,
                    )
                    .await?;
                Ok(entries.into_iter().map(Into::into).collect())
            }
        }
        #[allow(non_camel_case_types)]
        pub struct op_botloader_bucket_storage_count {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_botloader_bucket_storage_count {
            const NAME: &'static str = "op_botloader_bucket_storage_count";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_botloader_bucket_storage_count"
                        .as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    (
                        "op_botloader_bucket_storage_count",
                        ::deno_core::FastStaticString::new(s),
                    )
                },
                true,
                false,
                5usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_botloader_bucket_storage_count {
            pub const fn name() -> &'static str {
                "op_botloader_bucket_storage_count"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg1,
                    ) {
                        Ok(t) => t,
                        Err(arg1_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg1_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg2 = args.get(2usize as i32);
                    let arg2 = deno_core::_ops::to_string(&mut scope, &arg2);
                    let arg3 = args.get(3usize as i32);
                    let arg3 = deno_core::_ops::to_string(&mut scope, &arg3);
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1, arg2, arg3)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        Ok(
                            deno_core::_ops::RustToV8::to_v8(
                                deno_core::_ops::RustToV8Marker::<
                                    deno_core::_ops::NumberMarker,
                                    _,
                                >::from(result),
                                scope,
                            ),
                        )
                    },
                ) {
                    match result {
                        Ok(result) => {
                            deno_core::_ops::RustToV8RetVal::to_v8_rv(
                                deno_core::_ops::RustToV8Marker::<
                                    deno_core::_ops::NumberMarker,
                                    _,
                                >::from(result),
                                &mut rv,
                            )
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state: Rc<RefCell<OpState>>,
                plugin_id: Option<PluginId>,
                bucket_name: String,
                key_pattern: String,
            ) -> Result<u64, AnyError> {
                let rt_ctx = {
                    let state = state.borrow();
                    state.borrow::<RuntimeContext>().clone()
                };
                let res = rt_ctx
                    .db
                    .count(
                        rt_ctx.guild_id,
                        plugin_id.map(Into::into),
                        bucket_name,
                        key_pattern,
                    )
                    .await?;
                Ok(res)
            }
        }
        #[allow(non_camel_case_types)]
        pub struct op_botloader_bucket_storage_incr {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_botloader_bucket_storage_incr {
            const NAME: &'static str = "op_botloader_bucket_storage_incr";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_botloader_bucket_storage_incr"
                        .as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    (
                        "op_botloader_bucket_storage_incr",
                        ::deno_core::FastStaticString::new(s),
                    )
                },
                true,
                false,
                3usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_botloader_bucket_storage_incr {
            pub const fn name() -> &'static str {
                "op_botloader_bucket_storage_incr"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg1,
                    ) {
                        Ok(t) => t,
                        Err(arg1_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg1_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                            deno_core::_ops::RustToV8Marker::<
                                deno_core::_ops::SerdeMarker,
                                _,
                            >::from(result),
                            scope,
                        )
                    },
                ) {
                    match result {
                        Ok(result) => {
                            match deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                                deno_core::_ops::RustToV8Marker::<
                                    deno_core::_ops::SerdeMarker,
                                    _,
                                >::from(result),
                                &mut scope,
                            ) {
                                Ok(v) => rv.set(v),
                                Err(rv_err) => {
                                    let msg = deno_core::v8::String::new(
                                            &mut scope,
                                            &{
                                                let res = ::alloc::fmt::format(
                                                    format_args!("{0}", deno_core::anyhow::Error::from(rv_err)),
                                                );
                                                res
                                            },
                                        )
                                        .unwrap();
                                    let exc = deno_core::v8::Exception::type_error(
                                        &mut scope,
                                        msg,
                                    );
                                    scope.throw_exception(exc);
                                    return 1;
                                }
                            }
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state: Rc<RefCell<OpState>>,
                args: OpStorageBucketIncr,
            ) -> Result<OpStorageBucketEntry, AnyError> {
                let rt_ctx = {
                    let state = state.borrow();
                    state.borrow::<RuntimeContext>().clone()
                };
                check_validate_key_len(&args.key)?;
                check_validate_storage_usage(rt_ctx.guild_id, &rt_ctx, state.clone())
                    .await?;
                let entry = rt_ctx
                    .db
                    .incr(
                        rt_ctx.guild_id,
                        args.plugin_id.map(Into::into),
                        args.bucket_name,
                        args.key,
                        args.amount,
                    )
                    .await?;
                Ok(entry.into())
            }
        }
        #[allow(non_camel_case_types)]
        pub struct op_botloader_bucket_storage_sorted_list {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_botloader_bucket_storage_sorted_list {
            const NAME: &'static str = "op_botloader_bucket_storage_sorted_list";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_botloader_bucket_storage_sorted_list"
                        .as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    (
                        "op_botloader_bucket_storage_sorted_list",
                        ::deno_core::FastStaticString::new(s),
                    )
                },
                true,
                false,
                3usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_botloader_bucket_storage_sorted_list {
            pub const fn name() -> &'static str {
                "op_botloader_bucket_storage_sorted_list"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg1,
                    ) {
                        Ok(t) => t,
                        Err(arg1_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg1_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                            deno_core::_ops::RustToV8Marker::<
                                deno_core::_ops::SerdeMarker,
                                _,
                            >::from(result),
                            scope,
                        )
                    },
                ) {
                    match result {
                        Ok(result) => {
                            match deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                                deno_core::_ops::RustToV8Marker::<
                                    deno_core::_ops::SerdeMarker,
                                    _,
                                >::from(result),
                                &mut scope,
                            ) {
                                Ok(v) => rv.set(v),
                                Err(rv_err) => {
                                    let msg = deno_core::v8::String::new(
                                            &mut scope,
                                            &{
                                                let res = ::alloc::fmt::format(
                                                    format_args!("{0}", deno_core::anyhow::Error::from(rv_err)),
                                                );
                                                res
                                            },
                                        )
                                        .unwrap();
                                    let exc = deno_core::v8::Exception::type_error(
                                        &mut scope,
                                        msg,
                                    );
                                    scope.throw_exception(exc);
                                    return 1;
                                }
                            }
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            pub async fn call(
                state: Rc<RefCell<OpState>>,
                args: OpStorageBucketSortedList,
            ) -> Result<Vec<OpStorageBucketEntry>, AnyError> {
                let rt_ctx = {
                    let state = state.borrow();
                    state.borrow::<RuntimeContext>().clone()
                };
                let limit = if let Some(limit) = args.limit {
                    if limit < 100 { limit } else { 100 }
                } else {
                    25
                };
                let entries = rt_ctx
                    .db
                    .sorted_entries(
                        rt_ctx.guild_id,
                        args.plugin_id.map(Into::into),
                        args.bucket_name,
                        args.order,
                        args.offset.unwrap_or_default(),
                        limit,
                    )
                    .await?;
                Ok(entries.into_iter().map(Into::into).collect())
            }
        }
        fn check_validate_value_len(val: &OpStorageBucketValue) -> Result<(), AnyError> {
            match val {
                OpStorageBucketValue::Json(json) => {
                    let serialized = serde_json::to_string(json).unwrap();
                    if serialized.len() > 1_000_000 {
                        Err(
                            ::anyhow::__private::must_use({
                                let error = ::anyhow::__private::format_err(
                                    format_args!("value too big, max value size is 1MB"),
                                );
                                error
                            }),
                        )
                    } else {
                        Ok(())
                    }
                }
                OpStorageBucketValue::Double(_) => Ok(()),
            }
        }
        fn check_validate_key_len(key: &str) -> Result<(), AnyError> {
            if key.len() > 256 {
                Err(
                    ::anyhow::__private::must_use({
                        let error = ::anyhow::__private::format_err(
                            format_args!("key too long (max 256 bytes)"),
                        );
                        error
                    }),
                )
            } else {
                Ok(())
            }
        }
        async fn check_validate_storage_usage(
            guild_id: Id<GuildMarker>,
            ctx: &RuntimeContext,
            state_rc: Rc<RefCell<OpState>>,
        ) -> Result<(), AnyError> {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "check_validate_storage_usage",
                            "runtime::extensions::storage",
                            tracing::Level::INFO,
                            ::core::option::Option::Some(
                                "components/runtime/src/extensions/storage.rs",
                            ),
                            ::core::option::Option::Some(372u32),
                            ::core::option::Option::Some("runtime::extensions::storage"),
                            ::tracing_core::field::FieldSet::new(
                                &["guild_id"],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = __CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(
                        __CALLSITE.metadata(),
                        interest,
                    )
                {
                    let meta = __CALLSITE.metadata();
                    ::tracing::Span::new(
                        meta,
                        &{
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = meta.fields().iter();
                            meta.fields()
                                .value_set(
                                    &[
                                        (
                                            &::core::iter::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::core::option::Option::Some(
                                                &tracing::field::debug(&guild_id) as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        },
                    )
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(
                        __CALLSITE.metadata(),
                    );
                    if match tracing::Level::INFO {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                span.record_all(
                                    &{
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &tracing::field::debug(&guild_id) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    },
                                );
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                    span
                }
            };
            let __tracing_instrument_future = async move {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: Result<(), AnyError> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    let do_check = {
                        let mut state = state_rc.borrow_mut();
                        let storage_ctx = state.borrow_mut::<StorageState>();
                        if !storage_ctx.doing_limit_check {
                            if storage_ctx.hit_limit {
                                return Err(
                                    ::anyhow::__private::must_use({
                                        let error = ::anyhow::__private::format_err(
                                            format_args!("hit storage limit, delete some entries"),
                                        );
                                        error
                                    }),
                                );
                            } else if storage_ctx.requests_until_limit_check >= 1 {
                                storage_ctx.requests_until_limit_check -= 1;
                                return Ok(());
                            }
                            storage_ctx.doing_limit_check = true;
                            true
                        } else {
                            false
                        }
                    };
                    if do_check {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event components/runtime/src/extensions/storage.rs:401",
                                        "runtime::extensions::storage",
                                        ::tracing::Level::INFO,
                                        ::core::option::Option::Some(
                                            "components/runtime/src/extensions/storage.rs",
                                        ),
                                        ::core::option::Option::Some(401u32),
                                        ::core::option::Option::Some(
                                            "runtime::extensions::storage",
                                        ),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::INFO
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::INFO
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                    if match ::tracing::Level::INFO {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                use ::tracing::log;
                                                let level = match ::tracing::Level::INFO {
                                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                    _ => ::tracing::log::Level::Trace,
                                                };
                                                if level <= log::max_level() {
                                                    let meta = __CALLSITE.metadata();
                                                    let log_meta = log::Metadata::builder()
                                                        .level(level)
                                                        .target(meta.target())
                                                        .build();
                                                    let logger = log::logger();
                                                    if logger.enabled(&log_meta) {
                                                        ::tracing::__macro_support::__tracing_log(
                                                            meta,
                                                            logger,
                                                            log_meta,
                                                            &value_set,
                                                        )
                                                    }
                                                }
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("doing a storage check") as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                                if match ::tracing::Level::INFO {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                } <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match ::tracing::Level::INFO {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let meta = __CALLSITE.metadata();
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(meta.target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    ::tracing::__macro_support::__tracing_log(
                                                        meta,
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                                            __CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &::core::iter::Iterator::next(&mut iter)
                                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                                            ::core::option::Option::Some(
                                                                                &format_args!("doing a storage check") as &dyn Value,
                                                                            ),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            }
                        };
                        let limit = crate::limits::storage_total_size(&state_rc);
                        let used_storage = ctx
                            .db
                            .guild_storage_usage_bytes(guild_id)
                            .await;
                        let mut state = state_rc.borrow_mut();
                        let storage_ctx = state.borrow_mut::<StorageState>();
                        storage_ctx.doing_limit_check = false;
                        let used = used_storage?;
                        if used >= limit {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event components/runtime/src/extensions/storage.rs:411",
                                            "runtime::extensions::storage",
                                            ::tracing::Level::INFO,
                                            ::core::option::Option::Some(
                                                "components/runtime/src/extensions/storage.rs",
                                            ),
                                            ::core::option::Option::Some(411u32),
                                            ::core::option::Option::Some(
                                                "runtime::extensions::storage",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::INFO
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::INFO
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                        if match ::tracing::Level::INFO {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::INFO {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &value_set,
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("completed a storage check, hit limit")
                                                                as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                    if match ::tracing::Level::INFO {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                use ::tracing::log;
                                                let level = match ::tracing::Level::INFO {
                                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                    _ => ::tracing::log::Level::Trace,
                                                };
                                                if level <= log::max_level() {
                                                    let meta = __CALLSITE.metadata();
                                                    let log_meta = log::Metadata::builder()
                                                        .level(level)
                                                        .target(meta.target())
                                                        .build();
                                                    let logger = log::logger();
                                                    if logger.enabled(&log_meta) {
                                                        ::tracing::__macro_support::__tracing_log(
                                                            meta,
                                                            logger,
                                                            log_meta,
                                                            &{
                                                                #[allow(unused_imports)]
                                                                use ::tracing::field::{debug, display, Value};
                                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                                __CALLSITE
                                                                    .metadata()
                                                                    .fields()
                                                                    .value_set(
                                                                        &[
                                                                            (
                                                                                &::core::iter::Iterator::next(&mut iter)
                                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                                ::core::option::Option::Some(
                                                                                    &format_args!("completed a storage check, hit limit")
                                                                                        as &dyn Value,
                                                                                ),
                                                                            ),
                                                                        ],
                                                                    )
                                                            },
                                                        )
                                                    }
                                                }
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                }
                            };
                            storage_ctx.hit_limit = true;
                            Err(
                                ::anyhow::__private::must_use({
                                    let error = ::anyhow::__private::format_err(
                                        format_args!("hit storage limit, delete some entries"),
                                    );
                                    error
                                }),
                            )
                        } else {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event components/runtime/src/extensions/storage.rs:415",
                                            "runtime::extensions::storage",
                                            ::tracing::Level::INFO,
                                            ::core::option::Option::Some(
                                                "components/runtime/src/extensions/storage.rs",
                                            ),
                                            ::core::option::Option::Some(415u32),
                                            ::core::option::Option::Some(
                                                "runtime::extensions::storage",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::INFO
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::INFO
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                        if match ::tracing::Level::INFO {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::INFO {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &value_set,
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("completed a storage check, clear")
                                                                as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                    if match ::tracing::Level::INFO {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                use ::tracing::log;
                                                let level = match ::tracing::Level::INFO {
                                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                    _ => ::tracing::log::Level::Trace,
                                                };
                                                if level <= log::max_level() {
                                                    let meta = __CALLSITE.metadata();
                                                    let log_meta = log::Metadata::builder()
                                                        .level(level)
                                                        .target(meta.target())
                                                        .build();
                                                    let logger = log::logger();
                                                    if logger.enabled(&log_meta) {
                                                        ::tracing::__macro_support::__tracing_log(
                                                            meta,
                                                            logger,
                                                            log_meta,
                                                            &{
                                                                #[allow(unused_imports)]
                                                                use ::tracing::field::{debug, display, Value};
                                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                                __CALLSITE
                                                                    .metadata()
                                                                    .fields()
                                                                    .value_set(
                                                                        &[
                                                                            (
                                                                                &::core::iter::Iterator::next(&mut iter)
                                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                                ::core::option::Option::Some(
                                                                                    &format_args!("completed a storage check, clear")
                                                                                        as &dyn Value,
                                                                                ),
                                                                            ),
                                                                        ],
                                                                    )
                                                            },
                                                        )
                                                    }
                                                }
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                }
                            };
                            storage_ctx.requests_until_limit_check = 10;
                            Ok(())
                        }
                    } else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event components/runtime/src/extensions/storage.rs:420",
                                        "runtime::extensions::storage",
                                        ::tracing::Level::INFO,
                                        ::core::option::Option::Some(
                                            "components/runtime/src/extensions/storage.rs",
                                        ),
                                        ::core::option::Option::Some(420u32),
                                        ::core::option::Option::Some(
                                            "runtime::extensions::storage",
                                        ),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::INFO
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::INFO
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                    if match ::tracing::Level::INFO {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                use ::tracing::log;
                                                let level = match ::tracing::Level::INFO {
                                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                    _ => ::tracing::log::Level::Trace,
                                                };
                                                if level <= log::max_level() {
                                                    let meta = __CALLSITE.metadata();
                                                    let log_meta = log::Metadata::builder()
                                                        .level(level)
                                                        .target(meta.target())
                                                        .build();
                                                    let logger = log::logger();
                                                    if logger.enabled(&log_meta) {
                                                        ::tracing::__macro_support::__tracing_log(
                                                            meta,
                                                            logger,
                                                            log_meta,
                                                            &value_set,
                                                        )
                                                    }
                                                }
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("waiting for result of storage check")
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                                if match ::tracing::Level::INFO {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                } <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match ::tracing::Level::INFO {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let meta = __CALLSITE.metadata();
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(meta.target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    ::tracing::__macro_support::__tracing_log(
                                                        meta,
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                                            __CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &::core::iter::Iterator::next(&mut iter)
                                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                                            ::core::option::Option::Some(
                                                                                &format_args!("waiting for result of storage check")
                                                                                    as &dyn Value,
                                                                            ),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            }
                        };
                        loop {
                            tokio::time::sleep(Duration::from_millis(100)).await;
                            let mut state = state_rc.borrow_mut();
                            let storage_ctx = state.borrow_mut::<StorageState>();
                            if !storage_ctx.doing_limit_check {
                                if storage_ctx.hit_limit {
                                    return Err(
                                        ::anyhow::__private::must_use({
                                            let error = ::anyhow::__private::format_err(
                                                format_args!("hit storage limit, delete some entries"),
                                            );
                                            error
                                        }),
                                    );
                                } else {
                                    return Ok(());
                                }
                            }
                        }
                    }
                }
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(
                        __tracing_instrument_future,
                        __tracing_attr_span,
                    )
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
    }
    pub mod tasks {
        use std::{cell::RefCell, rc::Rc};
        use chrono::TimeZone;
        use deno_core::{op2, OpState};
        use runtime_models::{
            internal::tasks::{CreateScheduledTask, GetGuildTasksFilter, ScheduledTask},
            util::PluginId,
        };
        use vm::AnyError;
        use crate::{get_rt_ctx, limits::RateLimiters, RuntimeEvent};
        ///
        /// An extension for use with the Deno JS runtime.
        /// To use it, provide it as an argument when instantiating your runtime:
        ///
        /// ```rust,ignore
        /// use deno_core::{ JsRuntime, RuntimeOptions };
        ///
        ///let mut extensions = vec![bl_tasks::init_ops_and_esm()];
        /// let mut js_runtime = JsRuntime::new(RuntimeOptions {
        ///   extensions,
        ///   ..Default::default()
        /// });
        /// ```
        ///
        #[allow(non_camel_case_types)]
        pub struct bl_tasks {}
        impl bl_tasks {
            fn ext() -> ::deno_core::Extension {
                #[allow(unused_imports)]
                use ::deno_core::Op;
                ::deno_core::Extension {
                    name: "bl_tasks",
                    deps: &[],
                    js_files: {
                        const JS: &'static [::deno_core::ExtensionFileSource] = &[];
                        ::std::borrow::Cow::Borrowed(JS)
                    },
                    esm_files: {
                        const JS: &'static [::deno_core::ExtensionFileSource] = &[];
                        ::std::borrow::Cow::Borrowed(JS)
                    },
                    lazy_loaded_esm_files: {
                        const JS: &'static [::deno_core::ExtensionFileSource] = &[];
                        ::std::borrow::Cow::Borrowed(JS)
                    },
                    esm_entry_point: {
                        const V: ::std::option::Option<&'static ::std::primitive::str> = ::std::option::Option::None;
                        V
                    },
                    ops: ::std::borrow::Cow::Borrowed(
                        &[
                            op_bl_schedule_task::DECL,
                            op_bl_del_task::DECL,
                            op_bl_del_task_by_key::DECL,
                            op_bl_del_all_tasks::DECL,
                            op_bl_get_task::DECL,
                            op_bl_get_task_by_key::DECL,
                            op_bl_get_all_tasks::DECL,
                        ],
                    ),
                    external_references: ::std::borrow::Cow::Borrowed(&[]),
                    global_template_middleware: ::std::option::Option::None,
                    global_object_middleware: ::std::option::Option::None,
                    op_state_fn: ::std::option::Option::None,
                    middleware_fn: ::std::option::Option::None,
                    enabled: true,
                }
            }
            #[inline(always)]
            #[allow(unused_variables)]
            fn with_ops_fn(ext: &mut ::deno_core::Extension) {}
            #[inline(always)]
            #[allow(unused_variables)]
            fn with_state_and_middleware(ext: &mut ::deno_core::Extension) {}
            #[inline(always)]
            #[allow(unused_variables)]
            #[allow(clippy::redundant_closure_call)]
            fn with_customizer(ext: &mut ::deno_core::Extension) {}
            #[allow(dead_code)]
            /// Initialize this extension for runtime or snapshot creation. Use this
            /// function if the runtime or snapshot is not created from a (separate)
            /// snapshot, or that snapshot does not contain this extension. Otherwise
            /// use `init_ops()` instead.
            ///
            /// # Returns
            /// an Extension object that can be used during instantiation of a JsRuntime
            pub fn init_ops_and_esm() -> ::deno_core::Extension {
                let mut ext = Self::ext();
                Self::with_ops_fn(&mut ext);
                Self::with_state_and_middleware(&mut ext);
                Self::with_customizer(&mut ext);
                ext
            }
            #[allow(dead_code)]
            /// Initialize this extension for runtime or snapshot creation, excluding
            /// its JavaScript sources and evaluation. This is used when the runtime
            /// or snapshot is created from a (separate) snapshot which includes this
            /// extension in order to avoid evaluating the JavaScript twice.
            ///
            /// # Returns
            /// an Extension object that can be used during instantiation of a JsRuntime
            pub fn init_ops() -> ::deno_core::Extension {
                let mut ext = Self::ext();
                Self::with_ops_fn(&mut ext);
                Self::with_state_and_middleware(&mut ext);
                Self::with_customizer(&mut ext);
                ext.js_files = ::std::borrow::Cow::Borrowed(&[]);
                ext.esm_files = ::std::borrow::Cow::Borrowed(&[]);
                ext.esm_entry_point = ::std::option::Option::None;
                ext
            }
        }
        #[allow(non_camel_case_types)]
        struct op_bl_schedule_task {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_bl_schedule_task {
            const NAME: &'static str = "op_bl_schedule_task";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_bl_schedule_task".as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    ("op_bl_schedule_task", ::deno_core::FastStaticString::new(s))
                },
                true,
                false,
                3usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_bl_schedule_task {
            pub const fn name() -> &'static str {
                "op_bl_schedule_task"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg1,
                    ) {
                        Ok(t) => t,
                        Err(arg1_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg1_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                            deno_core::_ops::RustToV8Marker::<
                                deno_core::_ops::SerdeMarker,
                                _,
                            >::from(result),
                            scope,
                        )
                    },
                ) {
                    match result {
                        Ok(result) => {
                            match deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                                deno_core::_ops::RustToV8Marker::<
                                    deno_core::_ops::SerdeMarker,
                                    _,
                                >::from(result),
                                &mut scope,
                            ) {
                                Ok(v) => rv.set(v),
                                Err(rv_err) => {
                                    let msg = deno_core::v8::String::new(
                                            &mut scope,
                                            &{
                                                let res = ::alloc::fmt::format(
                                                    format_args!("{0}", deno_core::anyhow::Error::from(rv_err)),
                                                );
                                                res
                                            },
                                        )
                                        .unwrap();
                                    let exc = deno_core::v8::Exception::type_error(
                                        &mut scope,
                                        msg,
                                    );
                                    scope.throw_exception(exc);
                                    return 1;
                                }
                            }
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            async fn call(
                state: Rc<RefCell<OpState>>,
                opts: CreateScheduledTask,
            ) -> Result<ScheduledTask, AnyError> {
                let rt_ctx = get_rt_ctx(&state);
                RateLimiters::task_ops(&state).await;
                let seconds = (opts.execute_at.0 as f64 / 1000f64).floor() as i64;
                let millis = opts.execute_at.0 as i64 - (seconds * 1000);
                let t = chrono::Utc
                    .timestamp_opt(seconds, millis as u32 * 1_000_000)
                    .unwrap();
                let data_serialized = serde_json::to_string(&opts.data)?;
                let limit_data_len = crate::limits::tasks_data_size(&state);
                if data_serialized.len() as u64 > limit_data_len {
                    return Err(
                        ::anyhow::__private::must_use({
                            let error = ::anyhow::__private::format_err(
                                format_args!(
                                    "data cannot be over {0}bytes on your guild\'s plan",
                                    limit_data_len,
                                ),
                            );
                            error
                        }),
                    );
                }
                let current = rt_ctx.db.get_task_count(rt_ctx.guild_id).await?;
                let limit_num_tasks = crate::limits::tasks_scheduled_count(&state);
                if current > limit_num_tasks {
                    return Err(
                        ::anyhow::__private::must_use({
                            let error = ::anyhow::__private::format_err(
                                format_args!(
                                    "max {0} can be scheduled on this guild\'s plan",
                                    limit_num_tasks,
                                ),
                            );
                            error
                        }),
                    );
                }
                let res = rt_ctx
                    .db
                    .create_task(
                        rt_ctx.guild_id,
                        opts.plugin_id.map(Into::into),
                        opts.namespace,
                        opts.unique_key,
                        opts.data,
                        t,
                    )
                    .await?
                    .into();
                let _ = rt_ctx.event_tx.send(RuntimeEvent::NewTaskScheduled);
                Ok(res)
            }
        }
        #[allow(non_camel_case_types)]
        struct op_bl_del_task {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_bl_del_task {
            const NAME: &'static str = "op_bl_del_task";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_bl_del_task".as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    ("op_bl_del_task", ::deno_core::FastStaticString::new(s))
                },
                true,
                false,
                3usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_bl_del_task {
            pub const fn name() -> &'static str {
                "op_bl_del_task"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let Some(arg1) = deno_core::_ops::to_f64_option(&arg1) else {
                        let mut scope = unsafe {
                            deno_core::v8::CallbackScope::new(&*info)
                        };
                        let msg = deno_core::v8::String::new_from_one_byte(
                                &mut scope,
                                "expected f64".as_bytes(),
                                deno_core::v8::NewStringType::Normal,
                            )
                            .unwrap();
                        let exc = deno_core::v8::Exception::type_error(&mut scope, msg);
                        scope.throw_exception(exc);
                        return 1;
                    };
                    let arg1 = arg1 as _;
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        Ok(deno_core::_ops::RustToV8::to_v8(result, scope))
                    },
                ) {
                    match result {
                        Ok(result) => {
                            deno_core::_ops::RustToV8RetVal::to_v8_rv(result, &mut rv)
                        }
                        Err(err) => {
                            let mut scope = unsafe {
                                deno_core::v8::CallbackScope::new(&*info)
                            };
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            async fn call(
                state: Rc<RefCell<OpState>>,
                task_id: u64,
            ) -> Result<bool, AnyError> {
                let rt_ctx = get_rt_ctx(&state);
                RateLimiters::task_ops(&state).await;
                let del = rt_ctx.db.del_task_by_id(rt_ctx.guild_id, task_id).await?;
                Ok(del > 0)
            }
        }
        #[allow(non_camel_case_types)]
        struct op_bl_del_task_by_key {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_bl_del_task_by_key {
            const NAME: &'static str = "op_bl_del_task_by_key";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_bl_del_task_by_key".as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    ("op_bl_del_task_by_key", ::deno_core::FastStaticString::new(s))
                },
                true,
                false,
                5usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_bl_del_task_by_key {
            pub const fn name() -> &'static str {
                "op_bl_del_task_by_key"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg1,
                    ) {
                        Ok(t) => t,
                        Err(arg1_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg1_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg2 = args.get(2usize as i32);
                    let arg2 = deno_core::_ops::to_string(&mut scope, &arg2);
                    let arg3 = args.get(3usize as i32);
                    let arg3 = deno_core::_ops::to_string(&mut scope, &arg3);
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1, arg2, arg3)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        Ok(deno_core::_ops::RustToV8::to_v8(result, scope))
                    },
                ) {
                    match result {
                        Ok(result) => {
                            deno_core::_ops::RustToV8RetVal::to_v8_rv(result, &mut rv)
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            async fn call(
                state: Rc<RefCell<OpState>>,
                plugin_id: Option<PluginId>,
                name: String,
                key: String,
            ) -> Result<bool, AnyError> {
                let rt_ctx = get_rt_ctx(&state);
                RateLimiters::task_ops(&state).await;
                let del = rt_ctx
                    .db
                    .del_task_by_key(
                        rt_ctx.guild_id,
                        plugin_id.map(Into::into),
                        name,
                        key,
                    )
                    .await?;
                Ok(del > 0)
            }
        }
        #[allow(non_camel_case_types)]
        struct op_bl_del_all_tasks {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_bl_del_all_tasks {
            const NAME: &'static str = "op_bl_del_all_tasks";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_bl_del_all_tasks".as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    ("op_bl_del_all_tasks", ::deno_core::FastStaticString::new(s))
                },
                true,
                false,
                4usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_bl_del_all_tasks {
            pub const fn name() -> &'static str {
                "op_bl_del_all_tasks"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg1,
                    ) {
                        Ok(t) => t,
                        Err(arg1_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg1_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg2 = args.get(2usize as i32);
                    let arg2 = deno_core::_ops::to_string(&mut scope, &arg2);
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1, arg2)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        Ok(
                            deno_core::_ops::RustToV8::to_v8(
                                deno_core::_ops::RustToV8Marker::<
                                    deno_core::_ops::NumberMarker,
                                    _,
                                >::from(result),
                                scope,
                            ),
                        )
                    },
                ) {
                    match result {
                        Ok(result) => {
                            deno_core::_ops::RustToV8RetVal::to_v8_rv(
                                deno_core::_ops::RustToV8Marker::<
                                    deno_core::_ops::NumberMarker,
                                    _,
                                >::from(result),
                                &mut rv,
                            )
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            async fn call(
                state: Rc<RefCell<OpState>>,
                plugin_id: Option<PluginId>,
                name: String,
            ) -> Result<u64, AnyError> {
                let rt_ctx = get_rt_ctx(&state);
                RateLimiters::task_ops(&state).await;
                let del = rt_ctx
                    .db
                    .del_all_tasks(
                        rt_ctx.guild_id,
                        plugin_id.map(Into::into),
                        Some(name),
                    )
                    .await?;
                Ok(del)
            }
        }
        #[allow(non_camel_case_types)]
        struct op_bl_get_task {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_bl_get_task {
            const NAME: &'static str = "op_bl_get_task";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_bl_get_task".as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    ("op_bl_get_task", ::deno_core::FastStaticString::new(s))
                },
                true,
                false,
                3usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_bl_get_task {
            pub const fn name() -> &'static str {
                "op_bl_get_task"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let Some(arg1) = deno_core::_ops::to_f64_option(&arg1) else {
                        let mut scope = unsafe {
                            deno_core::v8::CallbackScope::new(&*info)
                        };
                        let msg = deno_core::v8::String::new_from_one_byte(
                                &mut scope,
                                "expected f64".as_bytes(),
                                deno_core::v8::NewStringType::Normal,
                            )
                            .unwrap();
                        let exc = deno_core::v8::Exception::type_error(&mut scope, msg);
                        scope.throw_exception(exc);
                        return 1;
                    };
                    let arg1 = arg1 as _;
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                            deno_core::_ops::RustToV8Marker::<
                                deno_core::_ops::SerdeMarker,
                                _,
                            >::from(result),
                            scope,
                        )
                    },
                ) {
                    match result {
                        Ok(result) => {
                            match deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                                deno_core::_ops::RustToV8Marker::<
                                    deno_core::_ops::SerdeMarker,
                                    _,
                                >::from(result),
                                &mut scope,
                            ) {
                                Ok(v) => rv.set(v),
                                Err(rv_err) => {
                                    let msg = deno_core::v8::String::new(
                                            &mut scope,
                                            &{
                                                let res = ::alloc::fmt::format(
                                                    format_args!("{0}", deno_core::anyhow::Error::from(rv_err)),
                                                );
                                                res
                                            },
                                        )
                                        .unwrap();
                                    let exc = deno_core::v8::Exception::type_error(
                                        &mut scope,
                                        msg,
                                    );
                                    scope.throw_exception(exc);
                                    return 1;
                                }
                            }
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            async fn call(
                state: Rc<RefCell<OpState>>,
                id: u64,
            ) -> Result<Option<ScheduledTask>, AnyError> {
                let rt_ctx = get_rt_ctx(&state);
                RateLimiters::task_ops(&state).await;
                Ok(rt_ctx.db.get_task_by_id(rt_ctx.guild_id, id).await?.map(Into::into))
            }
        }
        #[allow(non_camel_case_types)]
        struct op_bl_get_task_by_key {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_bl_get_task_by_key {
            const NAME: &'static str = "op_bl_get_task_by_key";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_bl_get_task_by_key".as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    ("op_bl_get_task_by_key", ::deno_core::FastStaticString::new(s))
                },
                true,
                false,
                5usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_bl_get_task_by_key {
            pub const fn name() -> &'static str {
                "op_bl_get_task_by_key"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg1,
                    ) {
                        Ok(t) => t,
                        Err(arg1_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg1_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg2 = args.get(2usize as i32);
                    let arg2 = deno_core::_ops::to_string(&mut scope, &arg2);
                    let arg3 = args.get(3usize as i32);
                    let arg3 = deno_core::_ops::to_string(&mut scope, &arg3);
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1, arg2, arg3)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                            deno_core::_ops::RustToV8Marker::<
                                deno_core::_ops::SerdeMarker,
                                _,
                            >::from(result),
                            scope,
                        )
                    },
                ) {
                    match result {
                        Ok(result) => {
                            match deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                                deno_core::_ops::RustToV8Marker::<
                                    deno_core::_ops::SerdeMarker,
                                    _,
                                >::from(result),
                                &mut scope,
                            ) {
                                Ok(v) => rv.set(v),
                                Err(rv_err) => {
                                    let msg = deno_core::v8::String::new(
                                            &mut scope,
                                            &{
                                                let res = ::alloc::fmt::format(
                                                    format_args!("{0}", deno_core::anyhow::Error::from(rv_err)),
                                                );
                                                res
                                            },
                                        )
                                        .unwrap();
                                    let exc = deno_core::v8::Exception::type_error(
                                        &mut scope,
                                        msg,
                                    );
                                    scope.throw_exception(exc);
                                    return 1;
                                }
                            }
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            async fn call(
                state: Rc<RefCell<OpState>>,
                plugin_id: Option<PluginId>,
                name: String,
                key: String,
            ) -> Result<Option<ScheduledTask>, AnyError> {
                let rt_ctx = get_rt_ctx(&state);
                RateLimiters::task_ops(&state).await;
                Ok(
                    rt_ctx
                        .db
                        .get_task_by_key(
                            rt_ctx.guild_id,
                            plugin_id.map(Into::into),
                            name,
                            key,
                        )
                        .await?
                        .map(Into::into),
                )
            }
        }
        #[allow(non_camel_case_types)]
        struct op_bl_get_all_tasks {
            _unconstructable: ::std::marker::PhantomData<()>,
        }
        impl ::deno_core::_ops::Op for op_bl_get_all_tasks {
            const NAME: &'static str = "op_bl_get_all_tasks";
            const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
                {
                    const LITERAL: &'static [u8] = "op_bl_get_all_tasks".as_bytes();
                    const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                        LITERAL,
                    );
                    let s: &'static ::deno_core::v8::OneByteConst = &STR;
                    ("op_bl_get_all_tasks", ::deno_core::FastStaticString::new(s))
                },
                true,
                false,
                4usize as u8,
                Self::v8_fn_ptr as _,
                Self::v8_fn_ptr_metrics as _,
                None,
                None,
                ::deno_core::OpMetadata {
                    ..::deno_core::OpMetadata::default()
                },
            );
        }
        impl op_bl_get_all_tasks {
            pub const fn name() -> &'static str {
                "op_bl_get_all_tasks"
            }
            #[deprecated(note = "Use the const op::DECL instead")]
            pub const fn decl() -> deno_core::_ops::OpDecl {
                <Self as deno_core::_ops::Op>::DECL
            }
            #[inline(always)]
            fn slow_function_impl(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) -> usize {
                #[cfg(debug_assertions)]
                let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
                    &<Self as deno_core::_ops::Op>::DECL,
                );
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
                    &*info
                });
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let opstate = &opctx.state;
                let result = {
                    let arg1 = args.get(1usize as i32);
                    let arg1 = match deno_core::_ops::serde_v8_to_rust(
                        &mut scope,
                        arg1,
                    ) {
                        Ok(t) => t,
                        Err(arg1_err) => {
                            let msg = deno_core::v8::String::new(
                                    &mut scope,
                                    &{
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                deno_core::anyhow::Error::from(arg1_err),
                                            ),
                                        );
                                        res
                                    },
                                )
                                .unwrap();
                            let exc = deno_core::v8::Exception::type_error(
                                &mut scope,
                                msg,
                            );
                            scope.throw_exception(exc);
                            return 1;
                        }
                    };
                    let arg2 = args.get(2usize as i32);
                    let Some(arg2) = deno_core::_ops::to_f64_option(&arg2) else {
                        let msg = deno_core::v8::String::new_from_one_byte(
                                &mut scope,
                                "expected f64".as_bytes(),
                                deno_core::v8::NewStringType::Normal,
                            )
                            .unwrap();
                        let exc = deno_core::v8::Exception::type_error(&mut scope, msg);
                        scope.throw_exception(exc);
                        return 1;
                    };
                    let arg2 = arg2 as _;
                    let arg0 = opstate.clone();
                    Self::call(arg0, arg1, arg2)
                };
                let promise_id = deno_core::_ops::to_i32_option(&args.get(0))
                    .unwrap_or_default();
                if let Some(result) = deno_core::_ops::map_async_op_fallible(
                    opctx,
                    false,
                    false,
                    promise_id,
                    result,
                    |scope, result| {
                        deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                            deno_core::_ops::RustToV8Marker::<
                                deno_core::_ops::SerdeMarker,
                                _,
                            >::from(result),
                            scope,
                        )
                    },
                ) {
                    match result {
                        Ok(result) => {
                            match deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                                deno_core::_ops::RustToV8Marker::<
                                    deno_core::_ops::SerdeMarker,
                                    _,
                                >::from(result),
                                &mut scope,
                            ) {
                                Ok(v) => rv.set(v),
                                Err(rv_err) => {
                                    let msg = deno_core::v8::String::new(
                                            &mut scope,
                                            &{
                                                let res = ::alloc::fmt::format(
                                                    format_args!("{0}", deno_core::anyhow::Error::from(rv_err)),
                                                );
                                                res
                                            },
                                        )
                                        .unwrap();
                                    let exc = deno_core::v8::Exception::type_error(
                                        &mut scope,
                                        msg,
                                    );
                                    scope.throw_exception(exc);
                                    return 1;
                                }
                            }
                        }
                        Err(err) => {
                            let err = err.into();
                            let exception = deno_core::error::to_v8_error(
                                &mut scope,
                                opctx.get_error_class_fn,
                                &err,
                            );
                            scope.throw_exception(exception);
                            return 1;
                        }
                    };
                    return 0;
                }
                return 2;
            }
            extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
                Self::slow_function_impl(info);
            }
            extern "C" fn v8_fn_ptr_metrics(
                info: *const deno_core::v8::FunctionCallbackInfo,
            ) {
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                deno_core::_ops::dispatch_metrics_async(
                    &opctx,
                    deno_core::_ops::OpMetricsEvent::Dispatched,
                );
                let res = Self::slow_function_impl(info);
                if res == 0 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Completed,
                    );
                } else if res == 1 {
                    deno_core::_ops::dispatch_metrics_async(
                        &opctx,
                        deno_core::_ops::OpMetricsEvent::Error,
                    );
                }
            }
            #[inline(always)]
            async fn call(
                state: Rc<RefCell<OpState>>,
                filter: GetGuildTasksFilter,
                after_id: u64,
            ) -> Result<Vec<ScheduledTask>, AnyError> {
                let rt_ctx = get_rt_ctx(&state);
                RateLimiters::task_ops(&state).await;
                Ok(
                    rt_ctx
                        .db
                        .get_guild_tasks(rt_ctx.guild_id, filter, after_id, 25)
                        .await?
                        .into_iter()
                        .map(Into::into)
                        .collect(),
                )
            }
        }
    }
    pub(crate) fn parse_discord_id<T>(input: &str) -> Result<Id<T>, AnyError> {
        if let Some(id) = Id::new_checked(input.parse()?) {
            Ok(id)
        } else {
            Err(
                ::anyhow::__private::must_use({
                    let error = ::anyhow::__private::format_err(
                        format_args!("invalid discord snowflake"),
                    );
                    error
                }),
            )
        }
    }
    pub(crate) async fn parse_get_guild_channel(
        state: &Rc<RefCell<OpState>>,
        rt_ctx: &RuntimeContext,
        channel_id_str: &str,
    ) -> Result<Channel, AnyError> {
        get_guild_channel(state, rt_ctx, parse_discord_id(channel_id_str)?).await
    }
    pub(crate) async fn get_guild_channel(
        state: &Rc<RefCell<OpState>>,
        rt_ctx: &RuntimeContext,
        channel_id: Id<ChannelMarker>,
    ) -> Result<Channel, AnyError> {
        match rt_ctx.bot_state.get_channel(rt_ctx.guild_id, channel_id).await? {
            Some(c) => {
                if !match c.guild_id {
                    Some(guild_id) if guild_id == rt_ctx.guild_id => true,
                    _ => false,
                } {
                    Err(
                        not_found_error({
                            let res = ::alloc::fmt::format(
                                format_args!("channel `{0} not found`", channel_id),
                            );
                            res
                        }),
                    )
                } else {
                    Ok(c)
                }
            }
            None => {
                let cloned_discord = rt_ctx.discord_config.clone();
                let channel = discord_request(
                        state,
                        async move { cloned_discord.client.channel(channel_id).await },
                    )
                    .await?
                    .model()
                    .await?;
                if match channel.guild_id {
                    Some(guild_id) if guild_id == rt_ctx.guild_id => true,
                    _ => false,
                } {
                    Ok(channel)
                } else {
                    Err(
                        not_found_error({
                            let res = ::alloc::fmt::format(
                                format_args!("channel `{0} not found`", channel_id),
                            );
                            res
                        }),
                    )
                }
            }
        }
    }
    pub(crate) fn parse_str_snowflake_id(
        id_str: &str,
    ) -> Result<Id<GenericMarker>, AnyError> {
        if let Some(id) = Id::new_checked(id_str.parse()?) {
            Ok(id)
        } else {
            Err(
                ::anyhow::__private::must_use({
                    let error = ::anyhow::__private::format_err(
                        format_args!("invalid channel id"),
                    );
                    error
                }),
            )
        }
    }
}
pub mod jsmodules {
    use vm::moduleloader::ModuleEntry;
    #[allow(missing_copy_implementations)]
    #[allow(non_camel_case_types)]
    #[allow(dead_code)]
    pub struct MODULE_MAP {
        __private_field: (),
    }
    #[doc(hidden)]
    pub static MODULE_MAP: MODULE_MAP = MODULE_MAP { __private_field: () };
    impl ::lazy_static::__Deref for MODULE_MAP {
        type Target = [(::url::Url, &'static str); 191];
        fn deref(&self) -> &[(::url::Url, &'static str); 191] {
            #[inline(always)]
            fn __static_ref_initialize() -> [(::url::Url, &'static str); 191] {
                [
                    (
                        ::url::Url::parse("file:///script_globals.js").unwrap(),
                        "export {}",
                    ),
                    (
                        ::url::Url::parse("file:///unstable/streams.js").unwrap(),
                        "/**\n * @internal\n */ export class NativeReaderWriter {\n    rid;\n    constructor(rid){\n        this.rid = rid;\n    }\n    read(buf) {\n        return Deno.core.read(this.rid, buf);\n    }\n    write(data) {\n        return Deno.core.write(this.rid, data);\n    }\n    close() {\n        Deno.core.close(this.rid);\n    }\n}\n/**\n * @internal\n */ export class NativeReader {\n    rid;\n    constructor(rid){\n        this.rid = rid;\n    }\n    read(buf) {\n        return Deno.core.read(this.rid, buf);\n    }\n    close() {\n        Deno.core.close(this.rid);\n    }\n}\n",
                    ),
                    (
                        ::url::Url::parse("file:///unstable/index.js").unwrap(),
                        "export * from \'./streams\';\n",
                    ),
                    (
                        ::url::Url::parse("file:///discord/invite.js").unwrap(),
                        "import { User } from \"./user\";\nexport class Invite {\n    approximateMemberCount;\n    approximatePresenceCount;\n    channel;\n    code;\n    createdAt;\n    expiresAt;\n    guild;\n    inviter;\n    maxAgeSeconds;\n    maxUses;\n    targetType;\n    targetUser;\n    temporary;\n    uses;\n    /** \n    * @internal \n    */ constructor(json){\n        this.approximateMemberCount = json.approximateMemberCount;\n        this.approximatePresenceCount = json.approximatePresenceCount;\n        this.channel = json.channel;\n        this.code = json.code;\n        this.createdAt = json.createdAt;\n        this.expiresAt = json.expiresAt;\n        this.guild = json.guild;\n        this.inviter = json.inviter && new User(json.inviter);\n        this.maxAgeSeconds = json.maxAge;\n        this.maxUses = json.maxUses;\n        this.targetType = json.targetType;\n        this.targetUser = json.targetUser && new User(json.targetUser);\n        this.temporary = json.temporary;\n        this.uses = json.uses;\n    }\n}\n",
                    ),
                    (
                        ::url::Url::parse("file:///discord/user.js").unwrap(),
                        "export class User {\n    avatar;\n    bot;\n    discriminator;\n    id;\n    locale;\n    username;\n    premiumType;\n    publicFlags;\n    system;\n    /**\n     * @internal\n     */ constructor(json){\n        this.avatar = json.avatar;\n        this.bot = json.bot;\n        this.discriminator = json.discriminator;\n        this.id = json.id;\n        this.locale = json.locale;\n        this.username = json.username;\n        this.premiumType = json.premiumType;\n        this.publicFlags = json.publicFlags;\n        this.system = json.system;\n    }\n    mention() {\n        return `<@${this.id}>`;\n    }\n    /**\n     * @returns a url to the user\'s avatar with the desired size (defaults to 256) \n     */ avatarUrl(options) {\n        const base = \"https://cdn.discordapp.com/\";\n        const size = options?.size ?? 128;\n        if (this.avatar) {\n            let format = this.avatar.startsWith(\"a_\") ? \"gif\" : \"png\";\n            return base + `avatars/${this.id}/${this.avatar}.${format}?size=${size}`;\n        }\n        const parsedDiscrim = parseInt(this.discriminator);\n        return base + `embed/avatars/${parsedDiscrim % 5}.png?size=${size}`;\n    }\n    /**\n     * @returns a timestamp for when the user was created\n     */ createdAt() {\n        const snowflake = BigInt(this.id);\n        const unixTime = (snowflake >> 22n) + 1420070400000n;\n        return new Date(Number(unixTime));\n    }\n}\n // export type PremiumType = \"none\" | \"nitroClassic\" | \"nitro\" | \"nitroBasic\";\n",
                    ),
                    (
                        ::url::Url::parse("file:///discord/snowflake.js").unwrap(),
                        "export const DiscordEpoch = 1420070400000n;\n/**\n * Gets the timestamp from a Discord ID.\n * @param id The snowflake to deconstruct.\n * @returns The snowflake timestamp.\n */ export function snowflakeTimestamp(id) {\n    return Number((BigInt(id) >> 22n) + DiscordEpoch);\n}\n",
                    ),
                    (
                        ::url::Url::parse("file:///discord/permissions.js").unwrap(),
                        "import { getCurrentGuildId } from \'./dapi\';\nconst Flags = [\n    [\n        \'CreateInstantInvite\',\n        1n << 0n\n    ],\n    [\n        \'KickMembers\',\n        1n << 1n\n    ],\n    [\n        \'BanMembers\',\n        1n << 2n\n    ],\n    [\n        \'Administrator\',\n        1n << 3n\n    ],\n    [\n        \'ManageChannels\',\n        1n << 4n\n    ],\n    [\n        \'ManageGuild\',\n        1n << 5n\n    ],\n    [\n        \'AddReactions\',\n        1n << 6n\n    ],\n    [\n        \'ViewAuditLog\',\n        1n << 7n\n    ],\n    [\n        \'PrioritySpeaker\',\n        1n << 8n\n    ],\n    [\n        \'Stream\',\n        1n << 9n\n    ],\n    [\n        \'ViewChannel\',\n        1n << 10n\n    ],\n    [\n        \'SendMessages\',\n        1n << 11n\n    ],\n    [\n        \'SendTtsMessages\',\n        1n << 12n\n    ],\n    [\n        \'ManageMessages\',\n        1n << 13n\n    ],\n    [\n        \'EmbedLinks\',\n        1n << 14n\n    ],\n    [\n        \'AttachFiles\',\n        1n << 15n\n    ],\n    [\n        \'ReadMessageHistory\',\n        1n << 16n\n    ],\n    [\n        \'MentionEveryone\',\n        1n << 17n\n    ],\n    [\n        \'UseExternalEmojis\',\n        1n << 18n\n    ],\n    [\n        \'ViewGuildInsights\',\n        1n << 19n\n    ],\n    [\n        \'Connect\',\n        1n << 20n\n    ],\n    [\n        \'Speak\',\n        1n << 21n\n    ],\n    [\n        \'MuteMembers\',\n        1n << 22n\n    ],\n    [\n        \'DeafenMembers\',\n        1n << 23n\n    ],\n    [\n        \'MoveMembers\',\n        1n << 24n\n    ],\n    [\n        \'UseVAD\',\n        1n << 25n\n    ],\n    [\n        \'ChangeNickname\',\n        1n << 26n\n    ],\n    [\n        \'ManageNicknames\',\n        1n << 27n\n    ],\n    [\n        \'ManageRoles\',\n        1n << 28n\n    ],\n    [\n        \'ManageWebhooks\',\n        1n << 29n\n    ],\n    [\n        \'ManageEmojisAndStickers\',\n        1n << 30n\n    ],\n    [\n        \'UseApplicationCommands\',\n        1n << 31n\n    ],\n    [\n        \'RequestToSpeak\',\n        1n << 32n\n    ],\n    [\n        \'ManageEvents\',\n        1n << 33n\n    ],\n    [\n        \'ManageThreads\',\n        1n << 34n\n    ],\n    [\n        \'CreatePublicThreads\',\n        1n << 35n\n    ],\n    [\n        \'CreatePrivateThreads\',\n        1n << 36n\n    ],\n    [\n        \'UseExternalStickers\',\n        1n << 37n\n    ],\n    [\n        \'SendMessagesInThreads\',\n        1n << 38n\n    ],\n    [\n        \'UseEmbeddedActivities\',\n        1n << 39n\n    ],\n    [\n        \'ModerateMembers\',\n        1n << 40n\n    ]\n];\n/**\n * A utility class for interacting with Discord server permissions.\n * This is essentially a wrapper around BigInt.\n * \n * Note: each instance is immutable and can\'t be changed, add/remove operations etc\n * does not change the current instance but instead returns a new instance with the changes applied\n */ export class Permissions {\n    static CreateInstantInvite = new Permissions(1n << 0n);\n    static KickMembers = new Permissions(1n << 1n);\n    static BanMembers = new Permissions(1n << 2n);\n    static Administrator = new Permissions(1n << 3n);\n    static ManageChannels = new Permissions(1n << 4n);\n    static ManageGuild = new Permissions(1n << 5n);\n    static AddReactions = new Permissions(1n << 6n);\n    static ViewAuditLog = new Permissions(1n << 7n);\n    static PrioritySpeaker = new Permissions(1n << 8n);\n    static Stream = new Permissions(1n << 9n);\n    static ViewChannel = new Permissions(1n << 10n);\n    static SendMessages = new Permissions(1n << 11n);\n    static SendTtsMessages = new Permissions(1n << 12n);\n    static ManageMessages = new Permissions(1n << 13n);\n    static EmbedLinks = new Permissions(1n << 14n);\n    static AttachFiles = new Permissions(1n << 15n);\n    static ReadMessageHistory = new Permissions(1n << 16n);\n    static MentionEveryone = new Permissions(1n << 17n);\n    static UseExternalEmojis = new Permissions(1n << 18n);\n    static ViewGuildInsights = new Permissions(1n << 19n);\n    static Connect = new Permissions(1n << 20n);\n    static Speak = new Permissions(1n << 21n);\n    static MuteMembers = new Permissions(1n << 22n);\n    static DeafenMembers = new Permissions(1n << 23n);\n    static MoveMembers = new Permissions(1n << 24n);\n    static UseVAD = new Permissions(1n << 25n);\n    static ChangeNickname = new Permissions(1n << 26n);\n    static ManageNicknames = new Permissions(1n << 27n);\n    static ManageRoles = new Permissions(1n << 28n);\n    static ManageWebhooks = new Permissions(1n << 29n);\n    static ManageEmojisAndStickers = new Permissions(1n << 30n);\n    static UseApplicationCommands = new Permissions(1n << 31n);\n    static RequestToSpeak = new Permissions(1n << 32n);\n    static ManageEvents = new Permissions(1n << 33n);\n    static ManageThreads = new Permissions(1n << 34n);\n    static CreatePublicThreads = new Permissions(1n << 35n);\n    static CreatePrivateThreads = new Permissions(1n << 36n);\n    static UseExternalStickers = new Permissions(1n << 37n);\n    static SendMessagesInThreads = new Permissions(1n << 38n);\n    static UseEmbeddedActivities = new Permissions(1n << 39n);\n    static ModerateMembers = new Permissions(1n << 40n);\n    value;\n    constructor(...data){\n        this.value = Permissions.resolve(...data);\n    }\n    /**\n     * @returns All the Discord permissions as a single bit.\n     */ static get rawAll() {\n        return Flags.reduce((a, b)=>a | b[1], 0n);\n    }\n    /**\n     * @returns An object containing all Discord permissions.\n     */ static entries() {\n        return Flags.reduce((a, b)=>{\n            a[b[0]] = b[1];\n            return a;\n        }, {});\n    }\n    /**\n     * A static method for resolving permissions from strings, numbers and bigints.\n     * @param data The data to resolve permissions from.\n     * @returns The resolved bits.\n     */ static resolve(...data) {\n        let result = 0n;\n        for (let v of data){\n            if (typeof v === \"object\") {\n                result |= v.value;\n            } else {\n                result |= BigInt(v);\n            }\n        }\n        return result;\n    }\n    /**\n     * @param perms The permissions to check for.\n     * @returns True if the current value has any of the given permissions.\n     */ hasAny(...perms) {\n        for (let p of perms){\n            const result = Permissions.resolve(p);\n            if ((this.value & result) === result) return true;\n        }\n        return false;\n    }\n    /**\n     * @param perms The permissions to check for.\n     * @returns True if the current value has all of the given permissions.\n     */ hasAll(...perms) {\n        for (let p of perms){\n            const result = Permissions.resolve(p);\n            if ((this.value & result) !== result) return false;\n        }\n        return true;\n    }\n    /**\n     * Returns a new set of permissions with the provided permissions added on to the current ones\n     * @param perms The permissions to add.\n     * @returns The resulting permissions.\n     */ add(...perms) {\n        return new Permissions(this.value | Permissions.resolve(...perms));\n    }\n    /**\n     * Returns a new set of permissions with the provided permissions removed\n     * @param perms The permissions to remove.\n     * @returns The resulting permissions.\n     */ remove(...perms) {\n        return new Permissions(this.value & ~Permissions.resolve(...perms));\n    }\n    /**\n     * @returns The current permissions value as an array of strings.\n     */ toArray() {\n        return Flags.filter((f)=>this.hasAny(f[1])).map((f)=>f[0]);\n    }\n    /**\n     * @returns The string value of the permissions.\n     */ toString() {\n        return this.value.toString();\n    }\n}\n/**\n * This is a helper class to make creating permission overwrites easier.\n * \n * @example \n * ```ts\n * // create a member overwrite that targets a single member\n * let member_overwrite = PermissionOverwrite.member(\"123\", new Permissions(Permissions.CreateInstantInvite, Permissions.SendMessages), new Permissions())\n * \n * // create a role overwrite that targets a role\n * let role_overwrite = PermissionOverwrite.role(\"123\", new Permissions(Permissions.CreateInstantInvite, Permissions.SendMessages), new Permissions())\n *\n * // create a role overwrite for the everyone role that targets everyone\n * let everyone_overwrite = PermissionOverwrite.everyone(new Permissions(Permissions.CreateInstantInvite, Permissions.SendMessages), new Permissions())\n *  ```\n */ export class PermissionOverwrite {\n    allowRaw;\n    denyRaw;\n    kind;\n    id;\n    constructor(kind, id, allow, deny){\n        this.kind = kind;\n        this.id = id;\n        this.allowRaw = Permissions.resolve(allow).toString();\n        this.denyRaw = Permissions.resolve(deny).toString();\n    }\n    static member(id, allow, deny) {\n        return new PermissionOverwrite(\"Member\", id, allow, deny);\n    }\n    static role(id, allow, deny) {\n        return new PermissionOverwrite(\"Role\", id, allow, deny);\n    }\n    static everyone(allow, deny) {\n        return PermissionOverwrite.role(getCurrentGuildId(), allow, deny);\n    }\n}\n",
                    ),
                    (
                        ::url::Url::parse("file:///discord/channel.js").unwrap(),
                        "import { Member } from \"./member\";\nimport { addThreadMember, createForumThread, createStandaloneThread, createThreadFromMessage, editThread, getPins, removeThreadMember } from \"./dapi\";\n/**\n * @internal\n */ export function guildChannelFromInternal(json) {\n    if (json.kind === \"Voice\" || json.kind === \"StageVoice\") {\n        return new VoiceChannel(json);\n    } else if (json.kind === \"Text\" || json.kind === \"News\" || json.kind === \"Forum\" || json.kind === \"GuildDirectory\") {\n        return new TextChannel(json);\n    } else if (json.kind === \"Category\") {\n        return new CategoryChannel(json);\n    } else if (json.kind === \"NewsThread\") {\n        return new NewsThread(json);\n    } else if (json.kind === \"PrivateThread\") {\n        return new PrivateThread(json);\n    } else if (json.kind === \"PublicThread\") {\n        return new PublicThread(json);\n    } else {\n        return new UnknownChannel(json);\n    }\n}\nexport function threadChannelFromInternal(json) {\n    const channel = guildChannelFromInternal(json);\n    if (channel.isThread()) {\n        return channel;\n    } else {\n        throw new Error(`Channel is not thread: id: ${json.id}, kind: ${json.kind}`);\n    }\n}\nexport class BaseChannel {\n    id;\n    kind;\n    name;\n    permissionOverwrites;\n    /**\n     * @internal\n     */ constructor(json){\n        this.id = json.id;\n        this.kind = json.kind;\n        if (\'name\' in json) {\n            this.name = json.name;\n        } else {\n            this.name = \"\";\n        }\n        if (\'permissionOverwrites\' in json) {\n            this.permissionOverwrites = json.permissionOverwrites;\n        } else {\n            this.permissionOverwrites = [];\n        }\n    }\n    isCategoryChannel() {\n        return this instanceof CategoryChannel;\n    }\n    isNewsThread() {\n        return this instanceof NewsThread;\n    }\n    isPrivateThread() {\n        return this instanceof PrivateThread;\n    }\n    isPublicThread() {\n        return this instanceof PublicThread;\n    }\n    isThread() {\n        return this instanceof Thread;\n    }\n    isTextChannel() {\n        return this instanceof TextChannel;\n    }\n    isVoiceChannel() {\n        return this instanceof VoiceChannel;\n    }\n    isAnyThread() {\n        return this.isThread();\n    }\n    pins() {\n        return getPins(this.id);\n    }\n}\nexport class UnknownChannel extends BaseChannel {\n}\nexport class CategoryChannel extends BaseChannel {\n    kind = \"Category\";\n    position;\n    /**\n     * @internal\n     */ constructor(json){\n        super(json);\n        this.position = json.position;\n    }\n}\nexport class TextChannel extends BaseChannel {\n    kind;\n    lastPinTimestamp;\n    nsfw;\n    parentId;\n    position;\n    rateLimitPerUser;\n    topic;\n    /**\n     * @internal\n     */ constructor(json){\n        super(json);\n        this.kind = json.kind;\n        this.lastPinTimestamp = json.lastPinTimestamp;\n        this.nsfw = json.nsfw;\n        this.parentId = json.parentId;\n        this.position = json.position;\n        this.rateLimitPerUser = json.rateLimitPerUser;\n        this.topic = json.topic;\n    }\n    createForumThread(fields) {\n        if (this.kind !== \"Forum\") {\n            throw new Error(`This channel is not a forum: ${this.id}`);\n        }\n        return createForumThread({\n            ...fields,\n            channelId: this.id\n        });\n    }\n    createStandaloneThread(fields) {\n        if (this.kind === \"Forum\") {\n            throw new Error(`This channel is a forum: ${this.id}`);\n        }\n        return createStandaloneThread({\n            ...fields,\n            channelId: this.id\n        });\n    }\n    createThreadFromMessage(fields) {\n        if (this.kind === \"Forum\") {\n            throw new Error(`This channel is a forum: ${this.id}`);\n        }\n        return createThreadFromMessage({\n            ...fields,\n            channelId: this.id\n        });\n    }\n}\nexport class Thread extends BaseChannel {\n    defaultAutoArchiveDurationMinutes;\n    kind;\n    member;\n    memberCount;\n    messageCount;\n    ownerId;\n    parentId;\n    rateLimitPerUser;\n    threadMetadata;\n    constructor(json){\n        super(json);\n        this.defaultAutoArchiveDurationMinutes = json.defaultAutoArchiveDurationMinutes;\n        this.kind = json.kind;\n        this.member = json.member;\n        this.memberCount = json.memberCount;\n        this.messageCount = json.messageCount;\n        this.ownerId = json.ownerId;\n        this.parentId = json.parentId;\n        this.rateLimitPerUser = json.rateLimitPerUser;\n        this.threadMetadata = json.threadMetadata;\n    }\n    async edit(fields) {\n        return await editThread({\n            ...fields,\n            channelId: this.id\n        });\n    }\n    addMemberToThread(userId) {\n        return addThreadMember(this.id, userId);\n    }\n    removeMemberFromThread(userId) {\n        return removeThreadMember(this.id, userId);\n    }\n    archive() {\n        return this.edit({\n            archived: true\n        });\n    }\n    unArchive() {\n        return this.edit({\n            archived: false\n        });\n    }\n    lock() {\n        return this.edit({\n            locked: true\n        });\n    }\n    unlock() {\n        return this.edit({\n            locked: false\n        });\n    }\n}\nexport class PrivateThread extends Thread {\n    kind = \"PrivateThread\";\n    invitable;\n    /**\n     * @internal\n     */ constructor(json){\n        super(json);\n        this.invitable = json.invitable;\n    }\n}\nexport class PublicThread extends Thread {\n    kind = \"PublicThread\";\n    /**\n     * @internal\n     */ constructor(json){\n        super(json);\n    }\n}\nexport class NewsThread extends BaseChannel {\n    kind = \"NewsThread\";\n    /**\n     * @internal\n     */ constructor(json){\n        super(json);\n    }\n}\nexport class VoiceChannel extends BaseChannel {\n    bitrate;\n    kind;\n    parentId;\n    position;\n    rtcRegion;\n    userLimit;\n    videoQualityMode;\n    /**\n     * @internal\n     */ constructor(json){\n        super(json);\n        this.bitrate = json.bitrate;\n        this.kind = json.kind;\n        this.parentId = json.parentId;\n        this.position = json.position;\n        this.rtcRegion = json.rtcRegion;\n        this.userLimit = json.userLimit;\n        this.videoQualityMode = json.videoQualityMode;\n    }\n}\nexport class SelfThreadMember {\n    /**\n     * When this use joined the thread, in unix milliseconds time\n     */ joinTimestamp;\n    /**\n     * @internal\n     */ constructor(json){\n        this.joinTimestamp = json.joinTimestamp;\n    }\n}\nexport class ThreadMember extends SelfThreadMember {\n    id;\n    member;\n    userId;\n    /**\n     * @internal\n     */ constructor(json){\n        super(json);\n        this.id = json.id;\n        this.member = json.member ? new Member(json.member) : null;\n        this.userId = json.userId;\n    }\n}\n",
                    ),
                    (
                        ::url::Url::parse("file:///discord/message.js").unwrap(),
                        "import { User } from \"./user\";\nimport { createPin, createThreadFromMessage, deleteMessage, deletePin, editMessage, getCurrentGuildId } from \"./dapi\";\nexport class Message {\n    activity;\n    application;\n    attachments;\n    author;\n    channelId;\n    content;\n    components;\n    editedTimestamp;\n    embeds;\n    flags;\n    guildId;\n    id;\n    kind;\n    member;\n    mentionChannels;\n    mentionEveryone;\n    mentionRoles;\n    mentions;\n    pinned;\n    reactions;\n    reference;\n    referencedMessage;\n    timestamp;\n    tts;\n    webhookId;\n    /**\n     * @internal\n     */ constructor(json){\n        this.activity = json.activity;\n        this.application = json.application;\n        this.attachments = json.attachments;\n        this.author = new User(json.author);\n        this.channelId = json.channelId;\n        this.content = json.content;\n        this.components = json.components;\n        this.editedTimestamp = json.editedTimestamp;\n        this.embeds = json.embeds;\n        this.flags = json.flags;\n        this.guildId = json.guildId ?? getCurrentGuildId();\n        this.id = json.id;\n        this.kind = json.kind;\n        this.member = json.member;\n        this.mentionChannels = json.mentionChannels;\n        this.mentionEveryone = json.mentionEveryone;\n        this.mentionRoles = json.mentionRoles;\n        this.mentions = json.mentions.map((v)=>new UserMention(v));\n        this.pinned = json.pinned;\n        this.reactions = json.reactions;\n        this.reference = json.reference;\n        this.referencedMessage = json.referencedMessage ? new Message(json.referencedMessage) : null;\n        this.timestamp = json.timestamp;\n        this.tts = json.tts;\n        this.webhookId = json.webhookId;\n    }\n    hyperlink() {\n        return `https://discord.com/channels/${this.guildId}/${this.channelId}/${this.id}`;\n    }\n    pin() {\n        return createPin(this.channelId, this.id);\n    }\n    unPin() {\n        return deletePin(this.channelId, this.id);\n    }\n    delete() {\n        return deleteMessage(this.channelId, this.id);\n    }\n    edit(fields) {\n        return editMessage(this.channelId, this.id, fields);\n    }\n    createThread(fields) {\n        return createThreadFromMessage({\n            ...fields,\n            channelId: this.channelId,\n            messageId: this.id\n        });\n    }\n}\nexport class UserMention extends User {\n    member;\n    /**\n     * @internal\n     */ constructor(json){\n        super(json.user);\n        this.member = json.member;\n    }\n}\n",
                    ),
                    (
                        ::url::Url::parse("file:///discord/index.js").unwrap(),
                        "export * from \'./dapi\';\nexport * from \'./interaction\';\nexport * from \'./message\';\nexport * from \'./member\';\nexport * from \'./channel\';\nexport * from \'./events\';\nexport * from \'./user\';\nexport * from \'./error\';\nexport * from \'./common\';\nexport * from \'./components\';\nexport * from \'./permissions\';\nexport * from \'./snowflake\';\nexport * from \'../generated/discord/index\';\n",
                    ),
                    (
                        ::url::Url::parse("file:///discord/components.js").unwrap(),
                        "import { encodeInteractionCustomId } from \'./interaction\';\nexport class BaseComponent {\n    kind;\n    constructor(kind){\n        this.kind = kind;\n    }\n}\nexport class ActionRow extends BaseComponent {\n    kind = \"ActionRow\";\n    components;\n    constructor(children){\n        super(\"ActionRow\");\n        this.components = children;\n    }\n}\nexport class Button extends BaseComponent {\n    kind = \"Button\";\n    customId;\n    style;\n    disabled;\n    url;\n    label;\n    emoji;\n    constructor(label, style){\n        super(\"Button\");\n        this.label = label;\n        this.style = style;\n    }\n    setDisabled(disabled) {\n        this.disabled = disabled;\n        return this;\n    }\n    setEmoji(emoji) {\n        if (\"unicode\" in emoji) {\n            this.emoji = emoji;\n        } else {\n            this.emoji = {\n                id: emoji.id,\n                name: emoji.name ?? null,\n                animated: false\n            };\n        }\n        return this;\n    }\n}\nexport class UrlButton extends Button {\n    constructor(label, url){\n        super(label, \"Link\");\n        this.url = url;\n    }\n}\nexport class CustomButton extends Button {\n    constructor(label, name, data){\n        super(label, \"Primary\");\n        this.customId = encodeInteractionCustomId(name, data ?? null);\n    }\n    setStyle(style) {\n        this.style = style;\n        return this;\n    }\n}\nexport class SelectMenu extends BaseComponent {\n    kind = \"SelectMenu\";\n    customId;\n    disabled;\n    minValues;\n    maxValues;\n    options;\n    placeholder;\n    constructor(name, options, data){\n        super(\"SelectMenu\");\n        this.customId = encodeInteractionCustomId(name, data ?? null);\n        this.options = options;\n        this.disabled = false;\n    }\n    setDisabled(disabled) {\n        this.disabled = disabled;\n        return this;\n    }\n    setMinValues(minValues) {\n        this.minValues = minValues;\n        return this;\n    }\n    setMaxValues(maxValues) {\n        this.maxValues = maxValues;\n        return this;\n    }\n    setPlaceHolder(placeholder) {\n        this.placeholder = placeholder;\n        return this;\n    }\n}\nexport class SelectMenuOption {\n    default;\n    description;\n    emoji;\n    label;\n    value;\n    constructor(label, value){\n        this.label = label;\n        this.value = value;\n        this.default = false;\n    }\n    setEmoji(emoji) {\n        if (\"unicode\" in emoji) {\n            this.emoji = emoji;\n        } else {\n            this.emoji = {\n                id: emoji.id,\n                name: emoji.name ?? null,\n                animated: false\n            };\n        }\n        return this;\n    }\n    setDefault(isDefault) {\n        this.default = isDefault;\n        return this;\n    }\n    setDescription(description) {\n        this.description = description;\n        return this;\n    }\n}\nexport class TextInput extends BaseComponent {\n    kind = \"TextInput\";\n    customId;\n    label;\n    maxLength = null;\n    minLength = null;\n    placeholder = null;\n    required = null;\n    style;\n    value = null;\n    constructor(label, style, name, data){\n        super(\"TextInput\");\n        this.label = label;\n        this.style = style;\n        this.customId = encodeInteractionCustomId(name, data ?? null);\n    }\n    setMaxLength(length) {\n        this.maxLength = length;\n        return this;\n    }\n    setMinLength(length) {\n        this.minLength = length;\n        return this;\n    }\n    setPlaceHolder(placeholder) {\n        this.placeholder = placeholder;\n        return this;\n    }\n    setValue(value) {\n        this.value = value;\n        return this;\n    }\n}\nexport class ShortTextInput extends TextInput {\n    kind = \"TextInput\";\n    constructor(label, name, data){\n        super(label, \"Short\", name, data);\n    }\n}\nexport class ParagraphTextInput extends TextInput {\n    kind = \"TextInput\";\n    constructor(label, name, data){\n        super(label, \"Paragraph\", name, data);\n    }\n}\n",
                    ),
                    (
                        ::url::Url::parse("file:///discord/dapi.js").unwrap(),
                        "import { OpWrappers } from \'../op_wrappers\';\nimport { ThreadMember, guildChannelFromInternal, threadChannelFromInternal } from \'./channel\';\nimport { Invite } from \'./invite\';\nimport { Ban, Member } from \'./member\';\nimport { Message } from \'./message\';\nimport { Permissions } from \'./permissions\';\nimport { User } from \'./user\';\n/**\n * @returns Botloader\'s discord user \n */ export function getBotUser() {\n    return new User(OpWrappers.getCurrentUser());\n}\n/**\n * @returns The current guild\'s Id\n */ export function getCurrentGuildId() {\n    return OpWrappers.getCurrentGuildId();\n}\n// Guild functions\nexport function getGuild() {\n    return OpWrappers.callAsyncOp({\n        kind: \"discord_get_guild\",\n        arg: null\n    });\n}\nfunction editGuild() {}\n/**\n * @returns A list of the invites on your server\n */ export async function getGuildInvites() {\n    return (await OpWrappers.getInvites()).map((v)=>new Invite(v));\n}\nexport async function getInvite(code, options) {\n    let result = await OpWrappers.getInvite(code, options?.withCounts ?? false, options?.withExpiration ?? false);\n    return new Invite(result);\n}\nexport async function deleteInvite(code) {\n    await OpWrappers.deleteInvite(code);\n}\n// Message functions\nexport async function getMessage(channelId, messageId) {\n    return new Message(await OpWrappers.callAsyncOp({\n        kind: \"discord_get_message\",\n        arg: [\n            channelId,\n            messageId\n        ]\n    }));\n}\nexport async function getMessages(channelId, options) {\n    return (await OpWrappers.callAsyncOp({\n        kind: \"discord_get_messages\",\n        arg: {\n            channelId,\n            after: options?.after,\n            before: options?.before,\n            limit: options?.limit\n        }\n    })).map((v)=>new Message(v));\n}\n/**\n * @internal\n */ export function toOpMessageFields(fields) {\n    let allowedMentions;\n    if (fields.allowedMentions) {\n        allowedMentions = {\n            parse: fields.allowedMentions.parse,\n            users: fields.allowedMentions.users ?? [],\n            roles: fields.allowedMentions.roles ?? [],\n            repliedUser: fields.allowedMentions.repliedUser ?? false\n        };\n    } else {\n        allowedMentions = {\n            parse: [\n                \"Users\"\n            ],\n            users: [],\n            roles: [],\n            repliedUser: false\n        };\n    }\n    return {\n        ...fields,\n        allowedMentions: allowedMentions\n    };\n}\nexport async function createMessage(channelId, fields) {\n    return new Message(await OpWrappers.callAsyncOp({\n        kind: \"discord_create_message\",\n        arg: {\n            channelId,\n            fields: toOpMessageFields(fields)\n        }\n    }));\n}\nexport async function editMessage(channelId, messageId, fields) {\n    return new Message(await OpWrappers.callAsyncOp({\n        kind: \"discord_edit_message\",\n        arg: {\n            channelId,\n            messageId,\n            fields: toOpMessageFields(fields)\n        }\n    }));\n}\nexport async function crosspostMessage(channelId, messageId) {\n    await OpWrappers.callAsyncOp({\n        kind: \"discord_crosspost_message\",\n        arg: [\n            channelId,\n            messageId\n        ]\n    });\n}\nexport async function deleteMessage(channelId, messageId) {\n    await OpWrappers.callAsyncOp({\n        kind: \"discord_delete_message\",\n        arg: {\n            channelId,\n            messageId\n        }\n    });\n}\nexport async function bulkDeleteMessages(channelId, ...messageIds) {\n    await OpWrappers.callAsyncOp({\n        kind: \"discord_bulk_delete_messages\",\n        arg: {\n            channelId,\n            messageIds\n        }\n    });\n}\n// Role functions\nexport function getRole(roleId) {\n    return OpWrappers.getRole(roleId);\n}\nexport function getRoles() {\n    return OpWrappers.getRoles();\n}\nasync function createRole() {}\nasync function editRole() {}\nasync function deleteRole() {}\n// Channel functions\nexport async function getChannel(channelId) {\n    return guildChannelFromInternal(await OpWrappers.getChannel(channelId));\n}\nexport async function getChannels() {\n    return (await OpWrappers.getChannels()).map((v)=>guildChannelFromInternal(v));\n}\nexport async function createChannel(fields) {\n    return guildChannelFromInternal(await OpWrappers.createChannel(fields));\n}\nexport async function editChannel(channelId, fields) {\n    return guildChannelFromInternal(await OpWrappers.editChannel(channelId, fields));\n}\n/**\n * Edits the positions of multiple channels at the same time\n * \n * Requires `MANAGE_CHANNELS` permission\n */ export async function editChannelPositions(channels) {\n    await OpWrappers.callAsyncOp({\n        kind: \"discord_bulk_edit_channels\",\n        arg: channels\n    });\n}\nexport async function deleteChannel(channelId) {\n    return guildChannelFromInternal(await OpWrappers.deleteChannel(channelId));\n}\nexport async function editChannelPermission(channelId, overwrite) {\n    return OpWrappers.updateChannelPermission(channelId, overwrite);\n}\nexport async function deleteChannelPermission(channelId, kind, id) {\n    return OpWrappers.deleteChannelPermission(channelId, kind, id);\n}\nexport async function getVoiceStates() {\n    return OpWrappers.getVoiceStates();\n}\nexport async function getChannelInvites(channelId) {\n    return (await OpWrappers.getChannelInvites(channelId)).map((v)=>new Invite(v));\n}\nexport async function createChannelInvite(channelId, fields) {\n    const result = await OpWrappers.createChannelInvite(channelId, {\n        max_age: fields.maxAgeSeconds,\n        max_uses: fields.maxUses,\n        temporary: fields.temporary,\n        target_application_id: fields.targetApplicationId,\n        target_user_id: fields.targetUserId,\n        target_type: fields.targetType,\n        unique: fields.unique\n    });\n    return new Invite(result);\n}\n// Pins \nexport async function getPins(channelId) {\n    return (await OpWrappers.op_discord_get_channel_pins(channelId)).map((v)=>new Message(v));\n}\nexport async function createPin(channelId, messageId) {\n    return OpWrappers.op_discord_create_pin(channelId, messageId);\n}\nexport async function deletePin(channelId, messageId) {\n    return OpWrappers.op_discord_delete_pin(channelId, messageId);\n}\n// Emoji functions\nasync function getEmoji() {}\nasync function getEmojis() {}\nasync function createEmoji() {}\nasync function editEmoji() {}\nasync function deleteEmoji() {}\n// Sticker functions\nasync function getSticker() {}\nasync function getStickers() {}\nasync function createSticker() {}\nasync function editSticker() {}\nasync function deleteSticker() {}\nexport async function getMember(id) {\n    const member = (await OpWrappers.getMembers([\n        id\n    ]))[0];\n    if (member) {\n        return new Member(member);\n    }\n    return undefined;\n}\nexport async function getMembers(ids) {\n    return (await OpWrappers.getMembers(ids)).map((v)=>v ? new Member(v) : null);\n}\nexport async function editMember(userId, fields) {\n    return new Member(await OpWrappers.updateMember(userId, fields));\n}\nexport async function setMemberTimeout(userId, time) {\n    return await editMember(userId, {\n        communicationDisabledUntil: time ? time.getTime() : null\n    });\n}\nexport async function addMemberRole(userId, roleId) {\n    return await OpWrappers.addMemberRole(userId, roleId);\n}\nexport async function removeMemberRole(userId, roleId) {\n    return await OpWrappers.removeMemberRole(userId, roleId);\n}\nexport async function removeMember(userId, extras) {\n    return OpWrappers.removeMember(userId, extras ?? {});\n}\n/**\n * Calculates the server permissions of a member\n * \n * This function does not take channel overwrites into account, use {@see getMemberChannelPermissions} for that\n */ export async function getMemberGuildPermissions(memberOrUserId) {\n    let userId = \"\";\n    let memberRoles = null;\n    if (typeof memberOrUserId === \"string\") {\n        userId = memberOrUserId;\n    } else {\n        memberRoles = memberOrUserId.roles;\n        userId = memberOrUserId.user.id;\n    }\n    let [guildPerms, _] = await OpWrappers.getMemberPermissions(userId, memberRoles, null);\n    return new Permissions(guildPerms);\n}\n/**\n * Calculates the server and channel permissions of a member\n * \n */ export async function getMemberChannelPermissions(memberOrUserId, channelId) {\n    let userId = \"\";\n    let memberRoles = null;\n    if (typeof memberOrUserId === \"string\") {\n        userId = memberOrUserId;\n    } else {\n        memberRoles = memberOrUserId.roles;\n        userId = memberOrUserId.user.id;\n    }\n    console.log(\"CHANNEL ID: \", channelId);\n    let [guildPerms, channelPerms] = await OpWrappers.getMemberPermissions(userId, memberRoles, channelId);\n    return {\n        guild: new Permissions(guildPerms),\n        channel: new Permissions(channelPerms ?? 0),\n        channelId\n    };\n}\nexport async function createBan(userId, extras) {\n    return OpWrappers.createBan(userId, extras ?? {});\n}\nexport async function getBan(userID) {\n    return new Ban(await OpWrappers.getBan(userID));\n}\nexport async function getBans() {\n    return (await OpWrappers.getBans()).map((v)=>new Ban(v));\n}\nexport async function deleteBan(userId, extras) {\n    return OpWrappers.removeBan(userId, extras ?? {});\n}\n// Reactions\nexport async function createReaction(channelId, messageId, emoji) {\n    return OpWrappers.discord_create_reaction(channelId, messageId, emoji);\n}\nexport async function deleteOwnReaction(channelId, messageId, emoji) {\n    return OpWrappers.discord_delete_own_reaction(channelId, messageId, emoji);\n}\nexport async function deleteUserReaction(channelId, messageId, userId, emoji) {\n    return OpWrappers.discord_delete_user_reaction(channelId, messageId, userId, emoji);\n}\nexport async function getReactions(channelId, messageId, emoji, extra) {\n    return (await OpWrappers.discord_get_reactions(channelId, messageId, {\n        ...extra,\n        emoji: emoji\n    })).map((v)=>new User(v));\n}\nexport async function deleteAllReactions(channelId, messageId) {\n    return OpWrappers.discord_delete_all_reactions(channelId, messageId);\n}\nexport async function deleteAllEmojiReactions(channelId, messageId, emoji) {\n    return OpWrappers.discord_delete_all_reactions_for_emoji(channelId, messageId, emoji);\n}\n// Interactions\nexport async function getInteractionFollowupMessage(token, messageId) {\n    return new Message(await OpWrappers.getInteractionFollowupMessage(token, messageId));\n}\nexport async function createInteractionFollowupMessage(token, resp) {\n    let flags = {};\n    if (arguments.length === 3) {\n        // legacy support, remove at some point in the future\n        flags = arguments[2];\n    } else {\n        if (typeof resp === \"object\") {\n            if (resp.flags) {\n                flags = resp.flags;\n            }\n        }\n    }\n    if (typeof resp === \"string\") {\n        return new Message(await OpWrappers.createInteractionFollowupMessage({\n            interactionToken: token,\n            fields: {\n                content: resp\n            },\n            flags: flags || {}\n        }));\n    } else {\n        return new Message(await OpWrappers.createInteractionFollowupMessage({\n            interactionToken: token,\n            fields: toOpMessageFields(resp),\n            flags: flags || {}\n        }));\n    }\n}\nexport async function editInteractionFollowupMessage(token, messageId, fields) {\n    return await OpWrappers.editInteractionFollowupMessage(messageId, {\n        interactionToken: token,\n        fields: toOpMessageFields(fields),\n        flags: fields.flags ?? {}\n    });\n}\nexport async function deleteInteractionFollowupMessage(token, id) {\n    return OpWrappers.deleteInteractionFollowupMessage(token, id);\n}\nexport async function getInteractionOriginalResponse(token) {\n    return new Message(await OpWrappers.getInteractionOriginal(token));\n}\nexport async function editInteractionOriginalResponse(token, fields) {\n    return new Message(await OpWrappers.editInteractionOriginal({\n        interactionToken: token,\n        fields: toOpMessageFields(fields),\n        flags: fields.flags ?? {}\n    }));\n}\nexport async function deleteInteractionOriginalResponse(token) {\n    return OpWrappers.deleteInteractionOriginal(token);\n}\nexport async function createStandaloneThread(create) {\n    return threadChannelFromInternal(await OpWrappers.callAsyncOp({\n        kind: \"discord_start_thread_without_message\",\n        arg: create\n    }));\n}\nexport async function createThreadFromMessage(create) {\n    return threadChannelFromInternal(await OpWrappers.callAsyncOp({\n        kind: \"discord_start_thread_from_message\",\n        arg: create\n    }));\n}\nexport async function createForumThread(create) {\n    const opArg = {\n        ...create,\n        message: toOpMessageFields(create.message)\n    };\n    const thread = await OpWrappers.callAsyncOp({\n        kind: \"discord_start_forum_thread\",\n        arg: opArg\n    });\n    return {\n        thread: threadChannelFromInternal(thread.channel),\n        message: new Message(thread.message)\n    };\n}\nexport async function editThread(fields) {\n    return threadChannelFromInternal(await OpWrappers.callAsyncOp({\n        kind: \"discord_edit_thread\",\n        arg: fields\n    }));\n}\nexport async function addThreadMember(channelId, userId) {\n    await OpWrappers.callAsyncOp({\n        kind: \"discord_add_thread_member\",\n        arg: [\n            channelId,\n            userId\n        ]\n    });\n}\nexport async function removeThreadMember(channelId, userId) {\n    await OpWrappers.callAsyncOp({\n        kind: \"discord_remove_thread_member\",\n        arg: [\n            channelId,\n            userId\n        ]\n    });\n}\nexport async function getThreadMembers(options) {\n    let resp = await OpWrappers.callAsyncOp({\n        kind: \"discord_list_thread_members\",\n        arg: options\n    });\n    return resp.map((v)=>new ThreadMember(v));\n}\nexport async function getActiveThreads() {\n    let resp = await OpWrappers.callAsyncOp({\n        kind: \"discord_list_active_threads\",\n        arg: null\n    });\n    return {\n        // hasMore: resp.hasMore,\n        members: resp.members.map((v)=>new ThreadMember(v)),\n        threads: resp.threads.map((v)=>threadChannelFromInternal(v))\n    };\n}\nexport async function getPublicArchivedThreads(options) {\n    let resp = await OpWrappers.callAsyncOp({\n        kind: \"discord_list_public_archived_threads\",\n        arg: options\n    });\n    return {\n        hasMore: resp.hasMore,\n        members: resp.members.map((v)=>new ThreadMember(v)),\n        threads: resp.threads.map((v)=>threadChannelFromInternal(v))\n    };\n}\nexport async function getPrivateArchivedThreads(options) {\n    let resp = await OpWrappers.callAsyncOp({\n        kind: \"discord_list_private_archived_threads\",\n        arg: options\n    });\n    return {\n        hasMore: resp.hasMore,\n        members: resp.members.map((v)=>new ThreadMember(v)),\n        threads: resp.threads.map((v)=>threadChannelFromInternal(v))\n    };\n}\n",
                    ),
                    (
                        ::url::Url::parse("file:///discord/events.js").unwrap(),
                        "import { Member } from \"./member\";\nimport { User } from \"./user\";\nimport { UserMention } from \"./message\";\nimport { ThreadMember, threadChannelFromInternal } from \"./channel\";\nexport class EventMessageReactionAdd {\n    channelId;\n    messageId;\n    emoji;\n    member;\n    userId;\n    /** \n     * @internal \n     */ constructor(json){\n        this.channelId = json.channelId;\n        this.messageId = json.messageId;\n        this.emoji = json.emoji;\n        this.member = new Member(json.member);\n        this.userId = json.userId;\n    }\n}\nexport class EventMessageUpdate {\n    attachments;\n    author;\n    channelId;\n    content;\n    editedTimestamp;\n    embeds;\n    guildId;\n    id;\n    kind;\n    mentionEveryone;\n    mentionRoles;\n    mentions;\n    pinned;\n    timestamp;\n    tts;\n    /** \n     * @internal \n     */ constructor(json){\n        this.attachments = json.attachments;\n        this.author = json.author ? new User(json.author) : undefined;\n        this.channelId = json.channelId;\n        this.content = json.content;\n        this.editedTimestamp = json.editedTimestamp;\n        this.embeds = json.embeds;\n        this.guildId = json.guildId;\n        this.id = json.id;\n        this.kind = json.kind;\n        this.mentionEveryone = json.mentionEveryone;\n        this.mentionRoles = json.mentionRoles;\n        this.mentions = json.mentions?.map((v)=>new UserMention(v));\n        this.pinned = json.pinned;\n        this.timestamp = json.timestamp;\n        this.tts = json.tts;\n    }\n}\nexport class EventMemberRemove {\n    guildId;\n    user;\n    /** \n     * @internal \n     */ constructor(json){\n        this.guildId = json.guildId;\n        this.user = new User(json.user);\n    }\n}\nexport class EventInviteCreate {\n    channelId;\n    code;\n    createdAt;\n    inviter;\n    maxAge;\n    maxUses;\n    targetUserType;\n    targetUser;\n    temporary;\n    uses;\n    /** \n    * @internal \n    */ constructor(json){\n        this.channelId = json.channelId;\n        this.code = json.code;\n        this.createdAt = json.createdAt;\n        this.inviter = json.inviter && new User(json.inviter);\n        this.maxAge = json.maxAge;\n        this.maxUses = json.maxUses;\n        this.targetUserType = json.targetUserType;\n        this.targetUser = json.targetUser;\n        this.temporary = json.temporary;\n        this.uses = json.uses;\n    }\n}\nexport class EventInviteDelete {\n    channelId;\n    code;\n    /** \n    * @internal \n    */ constructor(json){\n        this.channelId = json.channelId;\n        this.code = json.code;\n    }\n}\nexport class VoiceState {\n    channelId;\n    deaf;\n    member;\n    mute;\n    selfDeaf;\n    selfMute;\n    selfStream;\n    selfVideo;\n    sessionId;\n    suppress;\n    userId;\n    requestToSpeakTimestamp;\n    /** \n    * @internal \n    */ constructor(json){\n        this.channelId = json.channelId;\n        this.deaf = json.deaf;\n        this.mute = json.mute;\n        this.selfDeaf = json.selfDeaf;\n        this.selfMute = json.selfMute;\n        this.selfStream = json.selfStream;\n        this.selfVideo = json.selfVideo;\n        this.sessionId = json.sessionId;\n        this.suppress = json.suppress;\n        this.userId = json.userId;\n        this.requestToSpeakTimestamp = json.requestToSpeakTimestamp;\n        if (json.member) {\n            this.member = new Member(json.member);\n        }\n    }\n}\nexport class EventVoiceStateUpdate extends VoiceState {\n    oldState;\n    /** \n    * @internal \n    */ constructor(json){\n        super(json.new);\n        if (json.old) {\n            this.oldState = new VoiceState(json.old);\n            this.oldState.member = this.member;\n        }\n    }\n}\nexport class EventThreadListSync {\n    channelIds;\n    members;\n    threads;\n    /** \n    * @internal \n    */ constructor(json){\n        this.channelIds = json.channelIds;\n        this.members = json.members.map((v)=>new ThreadMember(v));\n        this.threads = json.threads.map((v)=>threadChannelFromInternal(v));\n    }\n}\nexport class EventThreadMembersUpdate {\n    id;\n    addedMembers;\n    memberCount;\n    removedMemberIds;\n    /** \n     * @internal \n     */ constructor(json){\n        this.id = json.id;\n        this.addedMembers = json.addedMembers.map((v)=>new ThreadMember(v));\n        this.memberCount = json.memberCount;\n        this.removedMemberIds = json.removedMemberIds;\n    }\n}\n",
                    ),
                    (
                        ::url::Url::parse("file:///discord/member.js").unwrap(),
                        "import { User } from \"./user\";\nexport class Member {\n    deaf;\n    joinedAt;\n    mute;\n    nick;\n    pending;\n    premiumSince;\n    roles;\n    communicationDisabledUntil;\n    user;\n    /**\n     * @internal\n     */ constructor(json){\n        this.deaf = json.deaf;\n        this.joinedAt = json.joinedAt;\n        this.mute = json.mute;\n        this.nick = json.nick;\n        this.pending = json.pending;\n        this.premiumSince = json.premiumSince;\n        this.roles = json.roles;\n        this.communicationDisabledUntil = json.communicationDisabledUntil;\n        this.user = new User(json.user);\n    }\n    name() {\n        return this.nick ?? this.user.username;\n    }\n}\nexport class Ban {\n    reason;\n    user;\n    /**\n     * @internal\n     */ constructor(json){\n        this.reason = json.reason;\n        this.user = new User(json.user);\n    }\n}\n",
                    ),
                    (
                        ::url::Url::parse("file:///discord/error.js").unwrap(),
                        "export class NotFoundError extends Error {\n    message;\n    constructor(message){\n        super(message);\n        this.message = \"Discord.NotFoundError: \" + message;\n    }\n}\nexport class PermissionsError extends Error {\n    message;\n    constructor(message){\n        super(message);\n        this.message = \"Discord.PermissionsError: \" + message;\n    }\n}\nexport class LimitReachedError extends Error {\n    message;\n    constructor(message){\n        super(message);\n        this.message = \"Discord.LimitReachedError: \" + message;\n    }\n}\nexport class ServerError extends Error {\n    message;\n    constructor(message){\n        super(message);\n        this.message = \"Discord.ServerError: \" + message;\n    }\n}\nexport class GenericError extends Error {\n    message;\n    constructor(message){\n        super(message);\n        this.message = \"Discord.GenericError: \" + message;\n    }\n}\nDeno.core.registerErrorClass(\"DiscordNotFoundError\", NotFoundError);\nDeno.core.registerErrorClass(\"DiscordPermissionsError\", PermissionsError);\nDeno.core.registerErrorClass(\"DiscordLimitReachedError\", LimitReachedError);\nDeno.core.registerErrorClass(\"DiscordServerErrorResponse\", ServerError);\nDeno.core.registerErrorClass(\"DiscordGenericErrorResponse\", GenericError);\n",
                    ),
                    (
                        ::url::Url::parse("file:///discord/interaction.js").unwrap(),
                        "import { createInteractionFollowupMessage, getInteractionFollowupMessage, deleteInteractionOriginalResponse, editInteractionOriginalResponse, getInteractionOriginalResponse, editInteractionFollowupMessage, deleteInteractionFollowupMessage, toOpMessageFields } from \'./dapi\';\nimport { OpWrappers } from \'../op_wrappers\';\nimport { Member } from \'./member\';\nimport { Message } from \'./message\';\n/**\n * Base interaction class, this class should be considered UNSTABLE and may change a lot in the future.\n */ export class Interaction {\n    interactionId;\n    token;\n    /**\n     * The user that started the interaction\n     */ member;\n    _hasSentCallback = false;\n    get hasSentCallback() {\n        return this._hasSentCallback;\n    }\n    constructor(id, token, member){\n        this.interactionId = id;\n        this.member = member;\n        this.token = token;\n    }\n    setCallbackSent() {\n        if (this.hasSentCallback) {\n            throw new Error(\"tried sending a callback when one has already been sent, only one callback per interaction can be sent.\");\n        } else {\n            this._hasSentCallback = true;\n        }\n    }\n    /**\n     * @deprecated use {@link ackWithMessage} \n     */ async sendCallbackWithMessage(fields, flags) {\n        this.ackWithMessage({\n            ...fields,\n            flags: flags\n        });\n    }\n    /**\n     * @deprecated use {@link ackWithDeferredMessage} \n     */ async sendCallbackWithDeferredMessage(fields, flags) {\n        this.ackWithDeferredMessage({\n            ...fields,\n            flags: flags\n        });\n    }\n    /**\n     * Acknowledge this interaction and send a message in response to this interaction\n     */ async ackWithMessage(fields) {\n        this.setCallbackSent();\n        return OpWrappers.interactionCallback({\n            interactionId: this.interactionId,\n            interactionToken: this.token,\n            data: {\n                kind: \"ChannelMessageWithSource\",\n                fields: toOpMessageFields(fields),\n                flags: fields.flags || {}\n            }\n        });\n    }\n    /**\n     * Acknowledge this interaction and display a \"thinking\" state to the user for you to then send a followUp \n     * message later.\n     * \n     * You have to ack interactions within 3 seconds but if you are doing things that can take longer than that you can\n     * use this function first to tell discord that you are processing the interaction then send the message itself later.\n     */ async ackWithDeferredMessage(fields) {\n        this.setCallbackSent();\n        return OpWrappers.interactionCallback({\n            interactionId: this.interactionId,\n            interactionToken: this.token,\n            data: {\n                kind: \"DeferredChannelMessageWithSource\",\n                fields: toOpMessageFields(fields ?? {}),\n                flags: fields?.flags ?? {}\n            }\n        });\n    }\n    /**\n     * @deprecated use {@link createFollowup} instead\n     */ async sendResponse(resp) {\n        return this.createFollowup(resp);\n    }\n    async getOriginalResponse() {\n        return getInteractionOriginalResponse(this.token);\n    }\n    async editOriginalResponse(fields) {\n        return editInteractionOriginalResponse(this.token, fields);\n    }\n    async deleteOriginalResponse() {\n        return deleteInteractionOriginalResponse(this.token);\n    }\n    async getFollowup(messageId) {\n        return getInteractionFollowupMessage(this.token, messageId);\n    }\n    /**\n     * @deprecated use {@link createFollowup} instead\n     */ async sendFollowup(resp) {\n        return createInteractionFollowupMessage(this.token, resp);\n    }\n    async createFollowup(resp) {\n        return createInteractionFollowupMessage(this.token, resp);\n    }\n    async editFollowup(messageId, fields) {\n        return editInteractionFollowupMessage(this.token, messageId, fields);\n    }\n    async deleteFollowup(id) {\n        return deleteInteractionFollowupMessage(this.token, id);\n    }\n}\nexport class ComponentInteraction extends Interaction {\n    customIdRaw;\n    componentType;\n    channelId;\n    message;\n    /**\n     * @internal\n     */ constructor(interaction){\n        super(interaction.id, interaction.token, new Member(interaction.member));\n        this.componentType = interaction.componentType;\n        this.customIdRaw = interaction.customId;\n        this.channelId = interaction.channelId;\n        this.message = new Message(interaction.message);\n    }\n    /**\n     * @deprecated use {@link ackWithUpdateMessage}\n     */ async sendCallbackUpdateMessage(fields, flags) {\n        return this.ackWithUpdateMessage({\n            ...fields,\n            flags: flags\n        });\n    }\n    /**\n     * @deprecated use {@link ackWithDeferredUpdateMessage}\n     */ async sendCallbackDeferredUpdateMessage() {\n        return this.ackWithDeferredUpdateMessage();\n    }\n    /**\n     * Acknowledge this interaction and update the message the component was on\n     * \n     * Use updateOriginalResponse to update the message\n     */ async ackWithUpdateMessage(fields) {\n        this.setCallbackSent();\n        return OpWrappers.interactionCallback({\n            interactionId: this.interactionId,\n            interactionToken: this.token,\n            data: {\n                kind: \"UpdateMessage\",\n                fields: toOpMessageFields(fields),\n                flags: fields.flags || {}\n            }\n        });\n    }\n    /**\n     * Acknowledge this interaction and update the message the component was on at a later time (within 15 mins).\n     * \n     * You have to ack interactions within 3 seconds but if you are doing things that can take longer than that you can\n     * use this function first to tell discord that you are processing the interaction then update the message later.\n     * \n     * Use updateOriginalResponse to update the message\n     */ async ackWithDeferredUpdateMessage() {\n        this.setCallbackSent();\n        return OpWrappers.interactionCallback({\n            interactionId: this.interactionId,\n            interactionToken: this.token,\n            data: {\n                kind: \"DeferredUpdateMessage\"\n            }\n        });\n    }\n    /**\n     * Acknowledge this interaction and open up a modal for the user.\n     * \n     * You have to acknowledge the interaction within 3 seconds, and it can only be done once. \n     */ async ackWithModal(modal) {\n        this.setCallbackSent();\n        return OpWrappers.interactionCallback({\n            interactionId: this.interactionId,\n            interactionToken: this.token,\n            data: {\n                kind: \"Modal\",\n                title: modal.title,\n                customId: modal.customId,\n                components: modal.components\n            }\n        });\n    }\n}\nexport class ModalSubmitInteraction extends Interaction {\n    customIdRaw;\n    channelId;\n    message;\n    values;\n    /**\n     * @internal\n     */ constructor(interaction){\n        super(interaction.id, interaction.token, new Member(interaction.member));\n        this.customIdRaw = interaction.customId;\n        this.channelId = interaction.channelId;\n        this.message = interaction.message ? new Message(interaction.message) : null;\n        this.values = {};\n        for (const elem of interaction.values){\n            const parsed = new ModalSubmitInteractionValue(elem);\n            this.values = {\n                ...this.values,\n                [parsed.name]: parsed\n            };\n        }\n    }\n    /**\n     * @deprecated use {@link ackWithUpdateMessage}\n     */ async sendCallbackUpdateMessage(fields, flags) {\n        return this.ackWithUpdateMessage({\n            ...fields,\n            flags: flags\n        });\n    }\n    /**\n     * @deprecated use {@link ackWithDeferredUpdateMessage}\n     */ async sendCallbackDeferredUpdateMessage() {\n        return this.ackWithDeferredUpdateMessage();\n    }\n    /**\n     * Acknowledge this interaction and update the message the component was on\n     * \n     * Use updateOriginalResponse to update the message\n     */ async ackWithUpdateMessage(fields) {\n        this.setCallbackSent();\n        return OpWrappers.interactionCallback({\n            interactionId: this.interactionId,\n            interactionToken: this.token,\n            data: {\n                kind: \"UpdateMessage\",\n                fields: toOpMessageFields(fields),\n                flags: fields.flags || {}\n            }\n        });\n    }\n    /**\n     * Acknowledge this interaction and update the message the component was on at a later time (within 15 mins).\n     * \n     * You have to ack interactions within 3 seconds but if you are doing things that can take longer than that you can\n     * use this function first to tell discord that you are processing the interaction then update the message later.\n     * \n     * Use updateOriginalResponse to update the message\n     */ async ackWithDeferredUpdateMessage() {\n        this.setCallbackSent();\n        return OpWrappers.interactionCallback({\n            interactionId: this.interactionId,\n            interactionToken: this.token,\n            data: {\n                kind: \"DeferredUpdateMessage\"\n            }\n        });\n    }\n}\nexport class ModalSubmitInteractionValue {\n    customIdRaw;\n    name;\n    value;\n    kind;\n    customData;\n    constructor(from){\n        [this.name, this.customData] = parseInteractionCustomId(from.customId);\n        this.customIdRaw = from.customId;\n        this.kind = from.kind;\n        this.value = from.value;\n    }\n}\nexport class SelectMenuInteraction extends ComponentInteraction {\n    values;\n    constructor(interaction){\n        super(interaction);\n        this.values = interaction.values;\n    }\n}\n/**\n * Creates a \'customId\' for you to use in message component\'s \'customId fields\n * \n * This is needed as otherwise the interaction will not be handled by botloader.\n * \n * DO NOT try to emulate this function yourself, we may change to different techniques entirely in the future and if you try to \n * emulate this function them by implmenting it yourself you WILL break stuff.\n * \n * Note that name + json(data) has to be less than 80 characters\n * \n * @param name Name of the component, this is used when creating listeners using {@link Script.onInteractionButton} and {@link Script.onInteractionSelectMenu}\n * @param data Arbitrary data that will be passed to the interaction handlers, can be used to track a small amount of state.\n * Note that name + json(data) has to be less than 80 characters\n * @returns The customId for use in the customId field\n */ export function encodeInteractionCustomId(name, data) {\n    let res = name + \":\";\n    if (data !== undefined && data !== null) {\n        res += JSON.stringify(data);\n    }\n    // The string iterator that is used here iterates over characters,\n    // not mere code units\n    let length = [\n        ...res\n    ].length;\n    if (res.length >= 95) {\n        throw new Error(\"name + JSON.stringify(data) exceeds 95 characters\");\n    }\n    return \"0:\" + res;\n}\nexport function parseInteractionCustomId(raw) {\n    let customId = raw.slice(2);\n    let nameEnd = customId.indexOf(\":\");\n    let name = \"\";\n    let extras = null;\n    if (nameEnd > -1) {\n        name = customId.slice(0, nameEnd);\n        let extrasStr = customId.slice(nameEnd + 1);\n        if (extrasStr) {\n            extras = JSON.parse(extrasStr);\n        }\n    }\n    return [\n        name,\n        extras\n    ];\n}\n",
                    ),
                    (
                        ::url::Url::parse("file:///discord/common.js").unwrap(),
                        "export { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/IEditGuildChannelPosition.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/InteractionResponse.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/internal/ScopeSelector.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/internal/PremiumType.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/internal/PrivateThread.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/internal/IUserFlags.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/internal/IntervalType.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/internal/SettingsOption.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/EventMemberRemove.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/internal/PublicThread.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/IEventThreadListSync.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/internal/IInvite.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/IEventVoiceStateUpdate.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/internal/Member.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/internal/StorageBucket.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/InteractionCallback.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/EasyOpsReturnTypesASync.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/MentionParseTypes.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/internal/EditChannel.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/CommandInteractionOptionValue.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/StorageBucketList.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/internal/UserMention.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/ExtraCommandOptions.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/SettingsOptionType.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/internal/Ban.js").unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/StorageBucketSetIf.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/InteractionCallbackData.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/internal/IUser.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/internal/GetMessages.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/ClientHttpRequest.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/AllowedMentions.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/CommandInteraction.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/DeleteMessagesBulk.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/IListThreadsRequest.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/internal/ICreateChannel.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/internal/IUpdateThread.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/internal/IntervalTimer.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/IntervalTimerEvent.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/StorageBucketSortedList.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/ClientHttpResponse.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/CreateChannelMessage.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/CreateFollowUpMessage.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/internal/Command.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/StorageBucketIncr.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/CreateBanFields.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/CommandOptionChoiceValue.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/ICreateThreadFromMessage.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/StorageBucketListOrder.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/GetGuildTasksFilter.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/IEventThreadMembersUpdate.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/ICreateForumThread.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/SettingsOptionValue.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/IModalInteraction.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/InteractionPartialMember.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/internal/NewsThread.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/internal/ICreateThread.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/StorageBucketSetValue.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/UpdateGuildMemberFields.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/IEventInviteCreate.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/internal/index.js")
                            .unwrap(),
                        "// generated index file using gen-index.bash\nexport * from \'./AllowedMentions\';\nexport * from \'./Ban\';\nexport * from \'./CategoryChannel\';\nexport * from \'./ClientHttpRequest\';\nexport * from \'./ClientHttpResponse\';\nexport * from \'./CommandGroup\';\nexport * from \'./CommandInteractionDataMaps\';\nexport * from \'./CommandInteractionOption\';\nexport * from \'./CommandInteractionOptionValue\';\nexport * from \'./CommandInteraction\';\nexport * from \'./CommandOptionChoice\';\nexport * from \'./CommandOptionChoiceValue\';\nexport * from \'./CommandOption\';\nexport * from \'./CommandOptionType\';\nexport * from \'./CommandSubGroup\';\nexport * from \'./Command\';\nexport * from \'./CommandType\';\nexport * from \'./ConsoleLogMessage\';\nexport * from \'./CreateBanFields\';\nexport * from \'./CreateChannelMessage\';\nexport * from \'./CreateFollowUpMessage\';\nexport * from \'./CreateMessageFields\';\nexport * from \'./CreateScheduledTask\';\nexport * from \'./DeleteMessagesBulk\';\nexport * from \'./DeleteMessage\';\nexport * from \'./EasyOpsASync\';\nexport * from \'./EasyOpsReturnTypesASync\';\nexport * from \'./EditChannelMessage\';\nexport * from \'./EditChannel\';\nexport * from \'./EventMemberRemove\';\nexport * from \'./EventMessageReactionAdd\';\nexport * from \'./EventMessageUpdate\';\nexport * from \'./ExtraCommandOptions\';\nexport * from \'./GetGuildTasksFilter\';\nexport * from \'./GetMessages\';\nexport * from \'./GetReactions\';\nexport * from \'./GuildChannel\';\nexport * from \'./ICreateChannel\';\nexport * from \'./ICreateForumThread\';\nexport * from \'./ICreateInviteFields\';\nexport * from \'./ICreateThreadFromMessage\';\nexport * from \'./ICreateThread\';\nexport * from \'./IEditGuildChannelPosition\';\nexport * from \'./IEventInviteCreate\';\nexport * from \'./IEventInviteDelete\';\nexport * from \'./IEventThreadListSync\';\nexport * from \'./IEventThreadMembersUpdate\';\nexport * from \'./IEventVoiceStateUpdate\';\nexport * from \'./IForumThreadResponse\';\nexport * from \'./IInvite\';\nexport * from \'./IListThreadMembersRequest\';\nexport * from \'./IListThreadsRequest\';\nexport * from \'./IMessage\';\nexport * from \'./IModalCallbackData\';\nexport * from \'./IModalInteractionDataComponent\';\nexport * from \'./IModalInteraction\';\nexport * from \'./InteractionCallbackData\';\nexport * from \'./InteractionCallback\';\nexport * from \'./InteractionChannel\';\nexport * from \'./InteractionPartialMember\';\nexport * from \'./InteractionResponse\';\nexport * from \'./Interaction\';\nexport * from \'./IntervalTimerEvent\';\nexport * from \'./IntervalTimer\';\nexport * from \'./IntervalType\';\nexport * from \'./ISelfThreadMember\';\nexport * from \'./IThreadsListing\';\nexport * from \'./IUpdateThread\';\nexport * from \'./IUserFlags\';\nexport * from \'./IUser\';\nexport * from \'./IVoiceState\';\nexport * from \'./Member\';\nexport * from \'./MentionParseTypes\';\nexport * from \'./MessageComponentInteraction\';\nexport * from \'./NewsThread\';\nexport * from \'./PremiumType\';\nexport * from \'./PrivateThread\';\nexport * from \'./PublicThread\';\nexport * from \'./ScheduledTask\';\nexport * from \'./ScopeSelector\';\nexport * from \'./ScriptMeta\';\nexport * from \'./ScriptTaskBucketId\';\nexport * from \'./SettingOptionDefinition\';\nexport * from \'./SettingsOptionList\';\nexport * from \'./SettingsOption\';\nexport * from \'./SettingsOptionType\';\nexport * from \'./SettingsOptionValue\';\nexport * from \'./StorageBucketEntryId\';\nexport * from \'./StorageBucketEntry\';\nexport * from \'./StorageBucketIncr\';\nexport * from \'./StorageBucketListOrder\';\nexport * from \'./StorageBucketList\';\nexport * from \'./StorageBucketSetCondition\';\nexport * from \'./StorageBucketSetIf\';\nexport * from \'./StorageBucketSetValue\';\nexport * from \'./StorageBucketSortedList\';\nexport * from \'./StorageBucket\';\nexport * from \'./StorageBucketValue\';\nexport * from \'./TextChannel\';\nexport * from \'./ThreadMember\';\nexport * from \'./UnknownChannel\';\nexport * from \'./UpdateGuildMemberFields\';\nexport * from \'./UserMention\';\nexport * from \'./VoiceChannel\';\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/internal/GetReactions.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/internal/CommandType.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/InteractionChannel.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/internal/CommandOption.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/CommandInteractionOption.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/internal/UnknownChannel.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/internal/Interaction.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/StorageBucketSetCondition.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/SettingOptionDefinition.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/CommandSubGroup.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/internal/IMessage.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/EditChannelMessage.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/internal/TextChannel.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/StorageBucketValue.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/CategoryChannel.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/CreateMessageFields.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/IModalInteractionDataComponent.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/IListThreadMembersRequest.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/CommandOptionChoice.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/internal/ScriptMeta.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/CreateScheduledTask.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/IForumThreadResponse.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/internal/GuildChannel.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/EventMessageUpdate.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/IModalCallbackData.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/ISelfThreadMember.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/StorageBucketEntry.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/SettingsOptionList.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/internal/VoiceChannel.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/internal/EasyOpsASync.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/MessageComponentInteraction.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/ScriptTaskBucketId.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/internal/IVoiceState.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/EventMessageReactionAdd.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/ConsoleLogMessage.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/internal/CommandGroup.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/CommandInteractionDataMaps.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/StorageBucketEntryId.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/internal/ScheduledTask.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/ICreateInviteFields.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/IEventInviteDelete.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/IThreadsListing.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/internal/CommandOptionType.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/internal/ThreadMember.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/internal/DeleteMessage.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/discord/ButtonStyle.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/discord/IPermissionOverwrite.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/discord/EventMessageReactionRemoveAllEmoji.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/discord/IComponent.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/discord/TextInputStyle.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/discord/MessageActivityType.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/discord/EventMessageReactionRemoveAll.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/discord/VideoQualityMode.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/discord/IInviteGuild.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/discord/IButton.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/discord/Guild.js").unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/discord/IUnknownComponent.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/discord/AuditLogExtras.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/discord/ISelectMenu.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/discord/EventMessageDelete.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/discord/EmbedAuthor.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/discord/SendEmoji.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/discord/ReactionType.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/discord/EmbedVideo.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/discord/MessageFlags.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/discord/EmbedThumbnail.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/discord/MessageType.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/discord/ITextInput.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/discord/IActionRow.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/discord/ChannelMention.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/discord/IInviteChannel.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/discord/MessageReference.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/discord/ThreadMetadata.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/discord/ComponentType.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/discord/PremiumTier.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/discord/DefaultMessageNotificationLevel.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/discord/InviteTargetType.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/discord/EmbedProvider.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/discord/SystemChannelFlags.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/discord/Role.js").unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/discord/index.js").unwrap(),
                        "// generated index file using gen-index.bash\nexport * from \'./Attachment\';\nexport * from \'./AuditLogExtras\';\nexport * from \'./ButtonStyle\';\nexport * from \'./ChannelMention\';\nexport * from \'./ChannelType\';\nexport * from \'./ComponentType\';\nexport * from \'./DefaultMessageNotificationLevel\';\nexport * from \'./EmbedAuthor\';\nexport * from \'./EmbedField\';\nexport * from \'./EmbedFooter\';\nexport * from \'./EmbedImage\';\nexport * from \'./EmbedProvider\';\nexport * from \'./EmbedThumbnail\';\nexport * from \'./Embed\';\nexport * from \'./EmbedVideo\';\nexport * from \'./EventMessageDelete\';\nexport * from \'./EventMessageReactionRemoveAllEmoji\';\nexport * from \'./EventMessageReactionRemoveAll\';\nexport * from \'./EventMessageReactionRemove\';\nexport * from \'./ExplicitContentFilter\';\nexport * from \'./Guild\';\nexport * from \'./IActionRow\';\nexport * from \'./IButton\';\nexport * from \'./IComponent\';\nexport * from \'./IEventThreadDelete\';\nexport * from \'./IInviteChannel\';\nexport * from \'./IInviteGuild\';\nexport * from \'./IInviteTargetUser\';\nexport * from \'./InviteTargetType\';\nexport * from \'./IPermissionOverwrite\';\nexport * from \'./ISelectMenuOption\';\nexport * from \'./ISelectMenu\';\nexport * from \'./ITextInput\';\nexport * from \'./IUnknownComponent\';\nexport * from \'./MessageActivity\';\nexport * from \'./MessageActivityType\';\nexport * from \'./MessageApplication\';\nexport * from \'./MessageFlags\';\nexport * from \'./MessageReaction\';\nexport * from \'./MessageReference\';\nexport * from \'./MessageType\';\nexport * from \'./MfaLevel\';\nexport * from \'./NsfwLevel\';\nexport * from \'./PartialMember\';\nexport * from \'./PermissionOverwriteType\';\nexport * from \'./PremiumTier\';\nexport * from \'./ReactionType\';\nexport * from \'./RoleTags\';\nexport * from \'./Role\';\nexport * from \'./SendEmoji\';\nexport * from \'./SystemChannelFlags\';\nexport * from \'./TextInputStyle\';\nexport * from \'./ThreadMetadata\';\nexport * from \'./VerificationLevel\';\nexport * from \'./VideoQualityMode\';\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/discord/EmbedImage.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/discord/RoleTags.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/discord/ISelectMenuOption.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/discord/Embed.js").unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/discord/IInviteTargetUser.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/discord/MessageActivity.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/discord/MfaLevel.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/discord/IEventThreadDelete.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/discord/EventMessageReactionRemove.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/discord/ExplicitContentFilter.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/discord/MessageApplication.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/discord/VerificationLevel.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/discord/Attachment.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/discord/MessageReaction.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/discord/PartialMember.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/discord/EmbedField.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/discord/NsfwLevel.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse(
                                "file:///generated/discord/PermissionOverwriteType.js",
                            )
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/discord/ChannelType.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/discord/EmbedFooter.js")
                            .unwrap(),
                        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\nexport { };\n",
                    ),
                    (
                        ::url::Url::parse("file:///generated/index.js").unwrap(),
                        "// generated index file using gen-index.bash\n",
                    ),
                    (
                        ::url::Url::parse("file:///scheduled_tasks.js").unwrap(),
                        "import { OpWrappers } from \"./op_wrappers\";\nexport var Tasks;\n(function(Tasks) {\n    async function schedule(namespace, execute_at, opts) {\n        const task = await OpWrappers.tasks.scheduleTask({\n            pluginId: null,\n            namespace: namespace,\n            executeAt: execute_at.getTime(),\n            data: opts?.data ?? null,\n            uniqueKey: opts?.key\n        });\n        return convertInternalTask(task);\n    }\n    /**\n     * Create a new scheduled task.\n     * \n     * @deprecated Deprecated in favor of new task bucket API. See {@link Script.createTaskBucket}\n     * \n     * @param namespace The namespace for this task, register a handler for the namespace using {@link Script.registerTaskHandler}\n     * @param execute_at When to execute this task\n     * @param opts Additional optional options, see {@link CreateOptions} for more info.\n     * @returns The scheduled task\n     */ Tasks.schedule = schedule;\n    async function deleteById(id) {\n        return OpWrappers.tasks.delTask(id);\n    }\n    /**\n     * Delete a task by its globally unique ID (NOT key)\n     * @returns true if found and deleted, false otherwise\n     */ Tasks.deleteById = deleteById;\n    async function deleteByKey(namespace, key) {\n        return OpWrappers.tasks.delTaskByKey(null, namespace, key);\n    }\n    /**\n     * Delete a task by its namespaced unique key\n     * @returns true if found and deleted, false otherwise\n     * \n     * @deprecated Deprecated in favor of new task bucket API. See {@link Script.createTaskBucket}\n     */ Tasks.deleteByKey = deleteByKey;\n    async function deleteNamespace(namespace) {\n        return OpWrappers.tasks.delAllTasks(null, namespace);\n    }\n    /**\n     * Delete all tasks within a namespace\n     * @returns the number of tasks deleted\n     * \n     * @deprecated Deprecated in favor of new task bucket API. See {@link Script.createTaskBucket}\n     */ Tasks.deleteNamespace = deleteNamespace;\n    async function getById(id) {\n        const task = await OpWrappers.tasks.getTask(id) ?? undefined;\n        if (task) {\n            return convertInternalTask(task);\n        }\n    }\n    /**\n     * Retrieve a task by its globally unique ID (NOT uniqueKey)\n     * @returns The task if found, or undefined if not found\n     */ Tasks.getById = getById;\n    async function getByKey(namespace, key) {\n        const task = await OpWrappers.tasks.getTaskByKey(null, namespace, key) ?? undefined;\n        if (task) {\n            return convertInternalTask(task);\n        }\n    }\n    /**\n     * Retrieve a task by its namespaced unique key\n     * @returns Either the task if found, or undefined  \n     * \n     * @deprecated Deprecated in favor of new task bucket API. See {@link Script.createTaskBucket}\n     */ Tasks.getByKey = getByKey;\n    async function getMany(options) {\n        const tasks = await OpWrappers.tasks.getAllTasks({\n            namespace: options?.namespace ?? null,\n            scope: {\n                kind: \"Guild\"\n            }\n        }, options?.afterId ?? 0);\n        return tasks.map((v)=>convertInternalTask(v));\n    }\n    /**\n     * Paginate through all scheduled tasks, optionally filtered by namespace\n     * \n     * Note that only a small number is returned each call (25 as of writing, may change) so\n     * if you need to scan through all of them you need to paginate using {@link ListOptions.afterId}\n     * \n     * Entries are sorted by increasing ID\n     * \n     */ Tasks.getMany = getMany;\n    class TaskBucket {\n        pluginId;\n        name;\n        constructor(options){\n            this.pluginId = options.pluginId;\n            this.name = options.name;\n        }\n        /**\n        * Create a new scheduled task.\n        * \n        * @returns The scheduled task\n        */ async schedule(opts) {\n            const task = await OpWrappers.tasks.scheduleTask({\n                pluginId: this.pluginId,\n                namespace: this.name,\n                executeAt: opts.executeAt.getTime(),\n                data: opts.data ?? null,\n                uniqueKey: opts.key\n            });\n            return convertInternalTask(task);\n        }\n        /**\n         * Retrieve a task by its globally unique ID (NOT unique key)\n         * \n         * @returns The task if found, or undefined if not found\n         */ async getById(id) {\n            const task = await OpWrappers.tasks.getTask(id) ?? undefined;\n            if (task) {\n                const converted = convertInternalTask(task);\n                if (converted.namespace !== this.name || converted.pluginId !== this.pluginId) {\n                    throw new Error(\"Retrieved task does not belong to bucket\");\n                }\n                return converted;\n            }\n        }\n        /**\n         * Delete a task by its globally unique ID (NOT key)\n         * \n         * Throws an error if it did not belong to this bucket\n         * \n         * @returns true if found and deleted, false otherwise\n         */ async deleteById(id) {\n            // Ensure this entry is from this bucket\n            await this.getById(id);\n            return OpWrappers.tasks.delTask(id);\n        }\n        /**\n         * Delete a task by its unique key\n         * \n         * @returns true if found and deleted, false otherwise\n         */ async deleteByKey(key) {\n            return OpWrappers.tasks.delTaskByKey(this.pluginId, this.name, key);\n        }\n        /**\n         * Delete all tasks within this bucket\n         * \n         * @returns the number of tasks deleted\n         */ async deleteAll() {\n            return OpWrappers.tasks.delAllTasks(this.pluginId, this.name);\n        }\n        /**\n         * Retrieve a task by its unique key\n         * \n         * @returns Either the task if found, or undefined  \n         */ async getByKey(key) {\n            const task = await OpWrappers.tasks.getTaskByKey(this.pluginId, this.name, key) ?? undefined;\n            if (task) {\n                return convertInternalTask(task);\n            }\n        }\n        /**\n         * Paginate through all scheduled tasks in this bucket\n         * \n         * Note that only a small number is returned each call (25 as of writing, may change) so\n         * if you need to scan through all of them you need to paginate using {@link BucketListOptions.afterId}\n         * \n         * Entries are sorted by increasing ID\n         */ async getMany(options) {\n            const tasks = await OpWrappers.tasks.getAllTasks({\n                namespace: this.name,\n                scope: this.pluginId ? {\n                    kind: \"Plugin\",\n                    plugin_id: this.pluginId\n                } : {\n                    kind: \"Guild\"\n                }\n            }, options?.afterId ?? 0);\n            return tasks.map((v)=>convertInternalTask(v));\n        }\n    }\n    Tasks.TaskBucket = TaskBucket;\n    function convertInternalTask(task) {\n        return {\n            ...task,\n            data: task.data\n        };\n    }\n})(Tasks || (Tasks = {}));\n",
                    ),
                    (
                        ::url::Url::parse("file:///image.js").unwrap(),
                        "import { HttpClient } from \"./httpclient\";\nexport class Image {\n    properties;\n    imageData;\n    static fromBlob(data) {}\n    static async downloadFromUrl(url) {\n        const request = await HttpClient.get(url);\n        const data = await request.readAll();\n        return this.fromBlob(data);\n    }\n    async resize(newWidth, newHeight) {}\n    async transcode(intoFormat) {}\n    async dataUri() {}\n}\n",
                    ),
                    (
                        ::url::Url::parse("file:///docs_index.js").unwrap(),
                        "// Important: core_util provides globals so don\'t remove it\nexport * from \'./core_util\';\n// export * from \'./timers\';\nexport * from \'./commands\';\nexport * from \'./eventsystem\';\nexport * from \'./script\';\nexport * from \'./storage\';\nexport * from \'./httpclient\';\nexport * from \'./scheduled_tasks\';\nexport * as Settings from \'./settings\';\nexport * as Discord from \'./discord/index\';\nexport * as Unstable from \'./unstable/index\';\n",
                    ),
                    (
                        ::url::Url::parse("file:///op_wrappers.js").unwrap(),
                        "// This file contains op wrappers\n// They are used internally and you should NEVER use them in your own scripts\n// if you do so your script WILL break at some point in the future when this gets changed\n// (and this changes a lot)\nconst { op_bl_http_request_send, op_bl_schedule_task, op_bl_del_task, op_bl_del_task_by_key, op_bl_del_all_tasks, op_bl_get_task, op_bl_get_task_by_key, op_bl_get_all_tasks, // op_discord_get_guild,\nop_discord_get_invites, op_discord_get_invite, op_discord_delete_invite, // op_discord_get_message,\n// op_discord_get_messages,\n// op_discord_create_message,\n// op_discord_crosspost_message,\n// op_discord_edit_message,\n// op_discord_delete_message,\n// op_discord_bulk_delete_messages,\nop_discord_interaction_callback, op_discord_interaction_get_followup_message, op_discord_interaction_followup_message, op_discord_interaction_edit_followup_message, op_discord_interaction_delete_followup_message, op_discord_interaction_get_original_response, op_discord_interaction_edit_original_response, op_discord_interaction_delete_original, op_discord_get_role, op_discord_get_roles, op_discord_get_channels, op_discord_get_channel, op_discord_edit_channel, op_discord_create_channel, op_discord_delete_channel, op_discord_update_channel_permission, op_discord_delete_channel_permission, op_discord_get_channel_pins: _op_discord_get_channel_pins, op_discord_create_pin: _op_discord_create_pin, op_discord_delete_pin: _op_discord_delete_pin, op_discord_get_voice_states, op_discord_get_members, op_discord_update_member, op_discord_add_member_role, op_discord_remove_member_role, op_discord_remove_member, op_discord_get_member_permissions, op_botloader_bucket_storage_set, op_botloader_bucket_storage_get, op_botloader_bucket_storage_del, op_botloader_bucket_storage_del_many, op_botloader_bucket_storage_list, op_botloader_bucket_storage_count, op_botloader_bucket_storage_incr, op_botloader_bucket_storage_sorted_list, op_botloader_bucket_storage_set_if, op_discord_create_ban, op_discord_get_ban, op_discord_get_bans, op_discord_delete_ban, op_discord_create_reaction, op_discord_delete_own_reaction, op_discord_delete_user_reaction, op_discord_get_reactions, op_discord_delete_all_reactions, op_discord_delete_all_reactions_for_emoji, op_discord_get_channel_invites, op_discord_create_channel_invite, op_easyops_async } = Deno.core.ops;\nexport var OpWrappers;\n(function(OpWrappers) {\n    let utils;\n    (function(utils) {\n        function encodeText(s) {\n            return Deno.core.ops.op_bl_encode_text(s);\n        }\n        utils.encodeText = encodeText;\n        function decodeText(u) {\n            return Deno.core.ops.op_bl_decode_text(u);\n        }\n        utils.decodeText = decodeText;\n    })(utils = OpWrappers.utils || (OpWrappers.utils = {}));\n    let http;\n    (function(http) {\n        function createRequestStream() {\n            return Deno.core.ops.op_bl_http_client_stream();\n        }\n        http.createRequestStream = createRequestStream;\n        function requestSend(args) {\n            return op_bl_http_request_send(args);\n        }\n        http.requestSend = requestSend;\n    })(http = OpWrappers.http || (OpWrappers.http = {}));\n    let tasks;\n    (function(tasks) {\n        function scheduleTask(data) {\n            return op_bl_schedule_task(data);\n        }\n        tasks.scheduleTask = scheduleTask;\n        function delTask(taskId) {\n            return op_bl_del_task(taskId);\n        }\n        tasks.delTask = delTask;\n        function delTaskByKey(pluginId, name, key) {\n            return op_bl_del_task_by_key(pluginId, name, key);\n        }\n        tasks.delTaskByKey = delTaskByKey;\n        function delAllTasks(pluginId, name) {\n            return op_bl_del_all_tasks(pluginId, name);\n        }\n        tasks.delAllTasks = delAllTasks;\n        function getTask(taskId) {\n            return op_bl_get_task(taskId);\n        }\n        tasks.getTask = getTask;\n        function getTaskByKey(pluginId, name, key) {\n            return op_bl_get_task_by_key(pluginId, name, key);\n        }\n        tasks.getTaskByKey = getTaskByKey;\n        function getAllTasks(filter, after_id) {\n            return op_bl_get_all_tasks(filter, after_id);\n        }\n        tasks.getAllTasks = getAllTasks;\n    })(tasks = OpWrappers.tasks || (OpWrappers.tasks = {}));\n    function scriptStarted(meta) {\n        Deno.core.ops.op_botloader_script_start(meta);\n    }\n    OpWrappers.scriptStarted = scriptStarted;\n    function getSettings(scriptId) {\n        return Deno.core.ops.op_get_settings(scriptId);\n    }\n    OpWrappers.getSettings = getSettings;\n    function consoleLog(args) {\n        Deno.core.ops.op_botloader_log(args);\n    }\n    OpWrappers.consoleLog = consoleLog;\n    async function callAsyncOp(call) {\n        return await op_easyops_async(call);\n    }\n    OpWrappers.callAsyncOp = callAsyncOp;\n    async function getInvites() {\n        return await op_discord_get_invites();\n    }\n    // export async function getGuild(): Promise<Discord.Guild> {\n    //     return op_discord_get_guild();\n    // }\n    OpWrappers.getInvites = getInvites;\n    async function getInvite(code, with_counts, with_expiration) {\n        return await op_discord_get_invite(code, with_counts, with_expiration);\n    }\n    OpWrappers.getInvite = getInvite;\n    async function deleteInvite(code) {\n        return await op_discord_delete_invite(code);\n    }\n    OpWrappers.deleteInvite = deleteInvite;\n    function getCurrentUser() {\n        return Deno.core.ops.op_get_current_bot_user();\n    }\n    OpWrappers.getCurrentUser = getCurrentUser;\n    function getCurrentGuildId() {\n        return Deno.core.ops.op_get_current_guild_id();\n    }\n    OpWrappers.getCurrentGuildId = getCurrentGuildId;\n    async function interactionCallback(args) {\n        return await op_discord_interaction_callback(args);\n    }\n    // Messages\n    // export async function getMessage(channelId: string, messageId: string): Promise<Internal.IMessage> {\n    //     return await op_discord_get_message(\n    //         channelId,\n    //         messageId,\n    //     );\n    // }\n    // export async function getMessages(args: Internal.OpGetMessages): Promise<Internal.IMessage[]> {\n    //     return await op_discord_get_messages(\n    //         args\n    //     );\n    // }\n    // export async function createChannelMessage(args: Internal.OpCreateChannelMessage): Promise<Internal.IMessage> {\n    //     return await op_discord_create_message(\n    //         args\n    //     );\n    // }\n    // export async function crosspostChannelMessage(channelId: string, messageId: string): Promise<void> {\n    //     return await op_discord_crosspost_message(\n    //         channelId,\n    //         messageId\n    //     );\n    // }\n    // export async function editChannelMessage(args: Internal.OpEditChannelMessage): Promise<Internal.IMessage> {\n    //     return await op_discord_edit_message(\n    //         args\n    //     );\n    // }\n    // export async function deleteChannelMessage(args: Internal.OpDeleteMessage): Promise<void> {\n    //     await op_discord_delete_message(\n    //         args\n    //     );\n    // }\n    // export async function deleteChannelMessagesBulk(args: Internal.OpDeleteMessagesBulk): Promise<void> {\n    //     await op_discord_bulk_delete_messages(\n    //         args\n    //     );\n    // }\n    // Interactions\n    OpWrappers.interactionCallback = interactionCallback;\n    async function getInteractionFollowupMessage(token, messageId) {\n        return await op_discord_interaction_get_followup_message(token, messageId);\n    }\n    OpWrappers.getInteractionFollowupMessage = getInteractionFollowupMessage;\n    async function createInteractionFollowupMessage(args) {\n        return await op_discord_interaction_followup_message(args);\n    }\n    OpWrappers.createInteractionFollowupMessage = createInteractionFollowupMessage;\n    async function editInteractionFollowupMessage(messageId, args) {\n        return await op_discord_interaction_edit_followup_message(messageId, args);\n    }\n    OpWrappers.editInteractionFollowupMessage = editInteractionFollowupMessage;\n    async function deleteInteractionFollowupMessage(token, messageId) {\n        return await op_discord_interaction_delete_followup_message(token, messageId);\n    }\n    OpWrappers.deleteInteractionFollowupMessage = deleteInteractionFollowupMessage;\n    async function getInteractionOriginal(token) {\n        return await op_discord_interaction_get_original_response(token);\n    }\n    OpWrappers.getInteractionOriginal = getInteractionOriginal;\n    async function editInteractionOriginal(args) {\n        return await op_discord_interaction_edit_original_response(args);\n    }\n    OpWrappers.editInteractionOriginal = editInteractionOriginal;\n    async function deleteInteractionOriginal(token) {\n        return await op_discord_interaction_delete_original(token);\n    }\n    OpWrappers.deleteInteractionOriginal = deleteInteractionOriginal;\n    async function getRole(roleId) {\n        return await op_discord_get_role(roleId);\n    }\n    // Roles\n    OpWrappers.getRole = getRole;\n    async function getRoles() {\n        return await op_discord_get_roles();\n    }\n    OpWrappers.getRoles = getRoles;\n    async function getChannels() {\n        return await op_discord_get_channels();\n    }\n    // Channels\n    OpWrappers.getChannels = getChannels;\n    async function getChannel(channelId) {\n        return await op_discord_get_channel(channelId);\n    }\n    OpWrappers.getChannel = getChannel;\n    async function editChannel(channelId, fields) {\n        return await op_discord_edit_channel(channelId, fields);\n    }\n    OpWrappers.editChannel = editChannel;\n    async function createChannel(fields) {\n        return await op_discord_create_channel(fields);\n    }\n    OpWrappers.createChannel = createChannel;\n    async function deleteChannel(channelId) {\n        return await op_discord_delete_channel(channelId);\n    }\n    OpWrappers.deleteChannel = deleteChannel;\n    async function updateChannelPermission(channelId, overwrite) {\n        return await op_discord_update_channel_permission(channelId, overwrite);\n    }\n    OpWrappers.updateChannelPermission = updateChannelPermission;\n    async function deleteChannelPermission(channelId, kind, id) {\n        return await op_discord_delete_channel_permission(channelId, [\n            kind,\n            id\n        ]);\n    }\n    OpWrappers.deleteChannelPermission = deleteChannelPermission;\n    async function getChannelInvites(channelId) {\n        return await op_discord_get_channel_invites(channelId);\n    }\n    OpWrappers.getChannelInvites = getChannelInvites;\n    async function createChannelInvite(channelId, fields) {\n        return await op_discord_create_channel_invite(channelId, fields);\n    }\n    OpWrappers.createChannelInvite = createChannelInvite;\n    async function op_discord_get_channel_pins(channelId) {\n        return await _op_discord_get_channel_pins(channelId);\n    }\n    // Pins\n    OpWrappers.op_discord_get_channel_pins = op_discord_get_channel_pins;\n    async function op_discord_create_pin(channelId, messageId) {\n        return await _op_discord_create_pin(channelId, messageId);\n    }\n    OpWrappers.op_discord_create_pin = op_discord_create_pin;\n    async function op_discord_delete_pin(channelId, messageId) {\n        return await _op_discord_delete_pin(channelId, messageId);\n    }\n    OpWrappers.op_discord_delete_pin = op_discord_delete_pin;\n    async function getVoiceStates() {\n        return await op_discord_get_voice_states();\n    }\n    OpWrappers.getVoiceStates = getVoiceStates;\n    async function getMembers(ids) {\n        return await op_discord_get_members(ids);\n    }\n    // Members\n    OpWrappers.getMembers = getMembers;\n    async function updateMember(userId, fields) {\n        return await op_discord_update_member(userId, fields);\n    }\n    OpWrappers.updateMember = updateMember;\n    async function addMemberRole(userId, roleId) {\n        return await op_discord_add_member_role(userId, roleId);\n    }\n    OpWrappers.addMemberRole = addMemberRole;\n    async function removeMemberRole(userId, roleId) {\n        return await op_discord_remove_member_role(userId, roleId);\n    }\n    OpWrappers.removeMemberRole = removeMemberRole;\n    async function removeMember(userId, extras) {\n        return await op_discord_remove_member(userId, extras);\n    }\n    OpWrappers.removeMember = removeMember;\n    async function getMemberPermissions(userId, roles, channelId) {\n        return await op_discord_get_member_permissions(userId, [\n            roles,\n            channelId\n        ]);\n    }\n    OpWrappers.getMemberPermissions = getMemberPermissions;\n    async function bucketStorageSet(opts) {\n        return await op_botloader_bucket_storage_set(opts);\n    }\n    // Storage\n    OpWrappers.bucketStorageSet = bucketStorageSet;\n    async function bucketStorageSetIf(opts) {\n        return await op_botloader_bucket_storage_set_if({\n            ...opts\n        });\n    }\n    OpWrappers.bucketStorageSetIf = bucketStorageSetIf;\n    async function bucketStorageGet(opts) {\n        return await op_botloader_bucket_storage_get(opts);\n    }\n    OpWrappers.bucketStorageGet = bucketStorageGet;\n    async function bucketStorageDel(opts) {\n        return await op_botloader_bucket_storage_del(opts);\n    }\n    OpWrappers.bucketStorageDel = bucketStorageDel;\n    async function bucketStorageDelMany(pluginId, bucketName, keyPattern) {\n        return await op_botloader_bucket_storage_del_many(pluginId, bucketName, keyPattern);\n    }\n    OpWrappers.bucketStorageDelMany = bucketStorageDelMany;\n    async function bucketStorageList(opts) {\n        return await op_botloader_bucket_storage_list(opts);\n    }\n    OpWrappers.bucketStorageList = bucketStorageList;\n    async function bucketStorageCount(pluginId, bucketName, keyPattern) {\n        return await op_botloader_bucket_storage_count(pluginId, bucketName, keyPattern);\n    }\n    OpWrappers.bucketStorageCount = bucketStorageCount;\n    async function bucketStorageIncr(opts) {\n        return await op_botloader_bucket_storage_incr(opts);\n    }\n    OpWrappers.bucketStorageIncr = bucketStorageIncr;\n    async function bucketStorageSortedList(opts) {\n        return await op_botloader_bucket_storage_sorted_list(opts);\n    }\n    OpWrappers.bucketStorageSortedList = bucketStorageSortedList;\n    async function createBan(userId, extras) {\n        return await op_discord_create_ban(userId, extras);\n    }\n    // Bans\n    OpWrappers.createBan = createBan;\n    async function getBan(userId) {\n        return op_discord_get_ban(userId);\n    }\n    OpWrappers.getBan = getBan;\n    async function getBans() {\n        return op_discord_get_bans();\n    }\n    OpWrappers.getBans = getBans;\n    async function removeBan(userId, extras) {\n        return await op_discord_delete_ban(userId, extras);\n    }\n    OpWrappers.removeBan = removeBan;\n    async function discord_create_reaction(channelId, messageId, emoji) {\n        return op_discord_create_reaction([\n            channelId,\n            messageId\n        ], emoji);\n    }\n    // Reactions\n    OpWrappers.discord_create_reaction = discord_create_reaction;\n    async function discord_delete_own_reaction(channelId, messageId, emoji) {\n        return op_discord_delete_own_reaction([\n            channelId,\n            messageId\n        ], emoji);\n    }\n    OpWrappers.discord_delete_own_reaction = discord_delete_own_reaction;\n    async function discord_delete_user_reaction(channelId, messageId, userId, emoji) {\n        return op_discord_delete_user_reaction([\n            channelId,\n            messageId,\n            userId\n        ], emoji);\n    }\n    OpWrappers.discord_delete_user_reaction = discord_delete_user_reaction;\n    async function discord_get_reactions(channelId, messageId, fields) {\n        return op_discord_get_reactions([\n            channelId,\n            messageId\n        ], fields);\n    }\n    OpWrappers.discord_get_reactions = discord_get_reactions;\n    async function discord_delete_all_reactions(channelId, messageId) {\n        return op_discord_delete_all_reactions([\n            channelId,\n            messageId\n        ]);\n    }\n    OpWrappers.discord_delete_all_reactions = discord_delete_all_reactions;\n    async function discord_delete_all_reactions_for_emoji(channelId, messageId, emoji) {\n        return op_discord_delete_all_reactions_for_emoji([\n            channelId,\n            messageId\n        ], emoji);\n    }\n    OpWrappers.discord_delete_all_reactions_for_emoji = discord_delete_all_reactions_for_emoji;\n})(OpWrappers || (OpWrappers = {}));\n",
                    ),
                    (
                        ::url::Url::parse("file:///eventsystem.js").unwrap(),
                        "import { Commands } from \'./commands\';\nimport { ComponentInteraction, ModalSubmitInteraction, EventMemberRemove, EventMessageReactionAdd, guildChannelFromInternal, EventMessageUpdate, Member, Message, SelectMenuInteraction, parseInteractionCustomId, EventInviteCreate, EventInviteDelete, EventVoiceStateUpdate, ThreadMember, EventThreadListSync, EventThreadMembersUpdate, threadChannelFromInternal } from \'./discord/index\';\nexport var EventSystem;\n(function(EventSystem) {\n    const buttonComponentListeners = [];\n    const selectMenuListeners = [];\n    const modalSubmitListeners = [];\n    /**\n     * @internal\n     */ EventSystem.commandSystem = new Commands.System();\n    const eventMuxers = [];\n    function registerEventMuxer(muxer) {\n        eventMuxers.push(muxer);\n    }\n    /**\n     * @internal\n     */ EventSystem.registerEventMuxer = registerEventMuxer;\n    function dispatchEvent(evt) {\n        let data = evt.data;\n        if (evt.name in converters) {\n            const converter = converters[evt.name];\n            data = converter(evt.data);\n        }\n        if (evt.name === \"BOTLOADER_COMPONENT_INTERACTION_CREATE\") {\n            handleComponentInteraction(data);\n        } else if (evt.name === \"BOTLOADER_COMMAND_INTERACTION_CREATE\") {\n            EventSystem.commandSystem.handleInteractionCreate(data);\n        } else if (evt.name == \"BOTLOADER_MODAL_SUBMIT_INTERACTION_CREATE\") {\n            handleModalSubmitInteraction(data);\n        } else {\n            for (let muxer of eventMuxers){\n                muxer.handleEvent(evt.name, data);\n            }\n        }\n    }\n    /**\n     * @internal\n     */ EventSystem.dispatchEvent = dispatchEvent;\n    BotloaderCore.dispatchEvent = dispatchEvent;\n    class Muxer {\n        listeners = {};\n        /**\n         * @internal\n         */ async handleEvent(name, data) {\n            let handlers = this.listeners[name];\n            if (handlers) {\n                for (let handler of handlers){\n                    handler(data);\n                }\n            }\n        }\n        /**\n         * @internal\n         */ on(eventType, cb) {\n            let handlers = this.listeners[eventType];\n            // we cast to any since typescript isn\'t able to handle this\n            if (handlers) {\n                handlers.push(cb);\n            } else {\n                this.listeners[eventType] = [\n                    cb\n                ];\n            }\n        }\n    }\n    /**\n     * @internal\n     */ EventSystem.Muxer = Muxer;\n    function onInteractionButton(name, cb) {\n        buttonComponentListeners.push({\n            name: name,\n            cb: cb\n        });\n    }\n    /**\n     * @internal\n     */ EventSystem.onInteractionButton = onInteractionButton;\n    function onInteractionSelectMenu(name, cb) {\n        selectMenuListeners.push({\n            name: name,\n            cb: cb\n        });\n    }\n    /**\n     * @internal\n     */ EventSystem.onInteractionSelectMenu = onInteractionSelectMenu;\n    function onInteractionModalSubmit(name, cb) {\n        modalSubmitListeners.push({\n            name: name,\n            cb: cb\n        });\n    }\n    /**\n     * @internal\n     */ EventSystem.onInteractionModalSubmit = onInteractionModalSubmit;\n    async function handleComponentInteraction(interaction) {\n        if (!interaction.customId.startsWith(\"0:\")) {\n            return;\n        }\n        let [name, extras] = parseInteractionCustomId(interaction.customId);\n        if (interaction.componentType === \"Button\") {\n            let listener = buttonComponentListeners.find((elem)=>elem.name === name);\n            if (listener) {\n                let convInteraction = new ComponentInteraction(interaction);\n                handleInteractionCallback(convInteraction, async ()=>{\n                    await listener.cb(convInteraction, extras);\n                });\n            }\n        } else if (interaction.componentType === \"SelectMenu\") {\n            let listener = selectMenuListeners.find((elem)=>elem.name === name);\n            if (listener) {\n                let convInteraction = new SelectMenuInteraction(interaction);\n                handleInteractionCallback(convInteraction, async ()=>{\n                    await listener.cb(convInteraction, extras);\n                });\n            }\n        }\n    }\n    async function handleModalSubmitInteraction(interaction) {\n        if (!interaction.customId.startsWith(\"0:\")) {\n            return;\n        }\n        let [name, extras] = parseInteractionCustomId(interaction.customId);\n        let listener = modalSubmitListeners.find((elem)=>elem.name === name);\n        if (listener) {\n            let convInteraction = new ModalSubmitInteraction(interaction);\n            handleInteractionCallback(convInteraction, async ()=>{\n                await listener.cb(convInteraction, extras);\n            });\n        }\n    }\n    async function handleInteractionCallback(interaction, inner) {\n        try {\n            await inner();\n        } catch (e) {\n            if (!interaction.hasSentCallback) {\n                await interaction.ackWithMessage({\n                    content: \"An error occured handling the interaction: \" + e,\n                    flags: {\n                        ephemeral: true\n                    }\n                });\n            } else {\n                await interaction.sendFollowup({\n                    content: \"An error occured handling the interaction: \" + e,\n                    flags: {\n                        ephemeral: true\n                    }\n                });\n            }\n        } finally{\n            // send no response message if needed\n            if (!interaction.hasSentCallback) {\n                await interaction.ackWithMessage({\n                    content: \"No response for interaction, this is probably a bug in the script\",\n                    flags: {\n                        ephemeral: true\n                    }\n                });\n            }\n        }\n    }\n    const converters = {\n        MESSAGE_CREATE: (v)=>new Message(v),\n        MESSAGE_UPDATE: (v)=>new EventMessageUpdate(v),\n        MESSAGE_REACTION_ADD: (v)=>new EventMessageReactionAdd(v),\n        CHANNEL_CREATE: (v)=>guildChannelFromInternal(v),\n        CHANNEL_UPDATE: (v)=>guildChannelFromInternal(v),\n        CHANNEL_DELETE: (v)=>guildChannelFromInternal(v),\n        MEMBER_ADD: (v)=>new Member(v),\n        MEMBER_UPDATE: (v)=>new Member(v),\n        MEMBER_REMOVE: (v)=>new EventMemberRemove(v),\n        VOICE_STATE_UPDATE: (v)=>new EventVoiceStateUpdate(v),\n        THREAD_CREATE: (v)=>threadChannelFromInternal(v),\n        THREAD_UPDATE: (v)=>threadChannelFromInternal(v),\n        THREAD_LIST_SYNC: (v)=>new EventThreadListSync(v),\n        THREAD_MEMBER_UPDATE: (v)=>new ThreadMember(v),\n        THREAD_MEMBERS_UPDATE: (v)=>new EventThreadMembersUpdate(v),\n        INVITE_CREATE: (v)=>new EventInviteCreate(v),\n        INVITE_DELETE: (v)=>new EventInviteDelete(v)\n    };\n})(EventSystem || (EventSystem = {}));\n",
                    ),
                    (
                        ::url::Url::parse("file:///index.js").unwrap(),
                        "// Important: core_util provides globals so don\'t remove it\nexport * from \'./core_util\';\n// export * from \'./timers\';\nexport * from \'./commands\';\nexport * from \'./eventsystem\';\nexport * from \'./script\';\nexport * as Settings from \'./settings\';\nexport * from \'./storage\';\nexport * from \'./httpclient\';\nexport * from \'./scheduled_tasks\';\nexport * as Discord from \'./discord/index\';\nexport * as Unstable from \'./unstable/index\';\n",
                    ),
                    (
                        ::url::Url::parse("file:///script.js").unwrap(),
                        "// imports for side effects, making them available in scripts always\nimport \"./core_util\";\nimport { Commands } from \"./commands\";\nimport { EventSystem } from \"./eventsystem\";\nimport { OpWrappers } from \"./op_wrappers\";\nimport { Storage } from \"./storage\";\nimport { Tasks } from \"./scheduled_tasks\";\nimport { SettingsManager } from \"./settings\";\n/**\n * The script class is the main way you interact with botloader and discord.\n */ export class Script {\n    scriptId;\n    name;\n    description;\n    pluginId;\n    events = new EventSystem.Muxer();\n    commandSystem = new Commands.System();\n    intervalTimers = [];\n    storageBuckets = [];\n    taskHandlers = [];\n    commands = [];\n    settings;\n    runCalled = false;\n    customStorageScope;\n    /**\n     * @internal\n     */ constructor(name, id, pluginId){\n        this.description = `script id ${id}`;\n        this.name = name;\n        this.scriptId = id;\n        this.pluginId = pluginId;\n        this.settings = new SettingsManager(id);\n    }\n    setCustomStorageScope(scope) {\n        this.customStorageScope = scope;\n    }\n    /**\n     * Creates or updates a command \n     * \n     * See {@link Commands.slashCommand}, {@link Commands.messageCommand} and {@link Commands.userCommand}\n     * for more info on defining the commands themselves\n     */ createCommand(command) {\n        this.commands.push(command);\n        EventSystem.commandSystem.addCommand(command);\n    }\n    storagePluginId() {\n        if (this.customStorageScope) {\n            if (this.customStorageScope.kind === \"Guild\") {\n                return null;\n            } else {\n                return this.customStorageScope.pluginId;\n            }\n        } else {\n            return this.pluginId;\n        }\n    }\n    /**\n     * @deprecated use {@link createStorageJson}\n     */ createGuildStorageJson(namespace) {\n        let bucket = new Storage.JsonBucket(namespace, this.storagePluginId());\n        this.storageBuckets.push(bucket);\n        return bucket;\n    }\n    /**\n     * Create new json storage buckets for persistent storage\n     * \n     * @param namespace a \"name\" or \"id\" for the bucket. \n     * This is not script scoped and the same storage bucket can be registered in multiple scripts to have access to the same data, this is perfectly safe.\n     * \n     * @example \n     * ```ts\n     * interface Data{\n     *     key: string,\n     * }\n     * let funStorage = script.createStorageJson(new Storage.JsonBucket<Data>(\"fun-data\"));\n     * ```\n     *\n     */ createStorageJson(namespace) {\n        let bucket = new Storage.JsonBucket(namespace, this.storagePluginId());\n        this.storageBuckets.push(bucket);\n        return bucket;\n    }\n    /**\n     * @deprecated use {@\u{142}ink createStorageNumber}\n     */ createGuildStorageNumber(namespace) {\n        let bucket = new Storage.NumberBucket(namespace, this.storagePluginId());\n        this.storageBuckets.push(bucket);\n        return bucket;\n    }\n    /**\n     * Creates a new number storage bucket for persistent storage.\n     * \n     * This is the same as {@link createStorageJson} except that this bucket can only store number values, the upside of this is that it can be sorted.\n     * \n     * An example use case could be storing the scores of users in a leveling system with the key being their user ID and the value being their score\n     * this way you can use {@link Storage.NumberBucket.sortedList} to get a sorted list of entries.\n     * \n     * See {@link createStorageJson} for more general info on storage buckets\n     */ createStorageNumber(namespace) {\n        let bucket = new Storage.NumberBucket(namespace, this.storagePluginId());\n        this.storageBuckets.push(bucket);\n        return bucket;\n    }\n    /**\n     * Create a new persistent variable.\n     * \n     * This is built on top of storage buckets so you can think of it as a single entry inside a storage bucket.\n     * \n     * @param key Key for the variable inside the storage bucket, the same key in another script will refer to the same entry\n     * @param options Additional options\n     * @returns \n     */ createStorageVarJson(key, options) {\n        const namespace = options?.namespace ?? \"bl:vars_json\";\n        return new Storage.JsonVar(namespace, key, this.storagePluginId());\n    }\n    /**\n     * Create a new persistent variable.\n     * \n     * This is built on top of storage buckets so you can think of it as a single entry inside a storage bucket.\n     * \n     * @param key Key for the variable inside the storage bucket, the same key in another script will refer to the same entry\n     * @param options Additional options\n     * @returns \n     */ createStorageVarNumber(key, options) {\n        const namespace = options?.namespace ?? \"bl:vars_number\";\n        return new Storage.NumberVar(namespace, key, this.storagePluginId());\n    }\n    /**\n     * Register a scheduled task handler for the provided namespace.\n     * \n     * See {@link Tasks} for more info about scheduled tasks and how to schedule a new one.\n     * \n     * @param namespace The task namespace to handle tasks from\n     * @param cb The callback function to run, with the type of the data passed to the task when scheduled\n     * \n     * @deprecated Use {@link createTaskBucket} instead.\n     * \n     * @example \n     * ```ts\n     * interface Data{\n     *     key: string,\n     * }\n     * script.onTask<Data>(\"fun-tasks\", (task) => {\n     *      console.log(\"hello world\");\n     * });\n     * ```\n     */ async onTask(namespace, cb) {\n        this.taskHandlers.push({\n            name: namespace,\n            pluginId: null\n        });\n        this.events.on(\"BOTLOADER_SCHEDULED_TASK_FIRED\", async (evt)=>{\n            if (evt.namespace === namespace && evt.pluginId == null) {\n                await cb({\n                    ...evt,\n                    pluginId: evt.pluginId,\n                    data: evt.data\n                });\n            }\n        });\n    }\n    createTaskBucket(options, cb) {\n        const pluginId = options.customScope ? options.customScope.kind === \"Guild\" ? null : options.customScope.pluginId : this.pluginId;\n        this.taskHandlers.push({\n            name: options.name,\n            pluginId: pluginId\n        });\n        this.events.on(\"BOTLOADER_SCHEDULED_TASK_FIRED\", async (evt)=>{\n            if (evt.namespace === options.name && evt.pluginId === pluginId) {\n                await cb({\n                    ...evt,\n                    pluginId: pluginId,\n                    data: evt.data\n                });\n            }\n        });\n        return new Tasks.TaskBucket({\n            name: options.name,\n            pluginId\n        });\n    }\n    onInteractionButton(name, cb) {\n        EventSystem.onInteractionButton(name, cb);\n    }\n    onInteractionSelectMenu(name, cb) {\n        EventSystem.onInteractionSelectMenu(name, cb);\n    }\n    onInteractionModalSubmit(name, cb) {\n        EventSystem.onInteractionModalSubmit(name, cb);\n    }\n    // onInteractionModalSubmit<T>(name: string, cb: (ctx: InteractionContext, submittedValues: SubmittedComponentValue[], data: T) => any) { }\n    /**\n     * Creates or resumes a interval timer.\n     * \n     * @param name The name of the timer, this is not namespaced to the current script. You could overwrite a timer from another script with the same name.\n     * @param interval The interval, either in minutes for running the callback at every x minutes, or a cron style timer. \n     * \n     * https://crontab.guru/ is a neat helper for making cron intervals \n     * \n     * @param callback Callback to run at every interval\n     * \n     * @example \n     * ```ts\n     *  script.onInterval(\"gaming\", \"*\\/5 * * * *\", () => {\n     *     // do stuff here\n     * });\n     * ```\n     */ onInterval(name, interval, callback) {\n        let timerType;\n        if (typeof interval === \"number\") {\n            timerType = {\n                minutes: interval\n            };\n        } else {\n            timerType = {\n                cron: interval\n            };\n        }\n        this.intervalTimers.push({\n            callback,\n            timer: {\n                name: name,\n                interval: timerType\n            }\n        });\n    }\n    /**\n     * Register a general event handler such as for arbitrary discord events like when a new message is sent in the server (MESSAGE_CREATE)\n     */ on(eventType, cb) {\n        this.events.on(eventType, cb);\n    }\n    /**\n     * @internal\n     */ run() {\n        if (this.runCalled) {\n            throw new Error(\"run already called\");\n        }\n        this.runCalled = true;\n        const [cmds, groups] = this.genCommandsBinding();\n        OpWrappers.scriptStarted({\n            description: this.description,\n            commands: cmds,\n            commandGroups: groups,\n            scriptId: this.scriptId,\n            intervalTimers: this.intervalTimers.map((inner)=>inner.timer),\n            taskBuckets: this.taskHandlers,\n            pluginId: this.pluginId,\n            settings: this.settings.toInternalOptions()\n        });\n        EventSystem.registerEventMuxer(this.events);\n        this.events.on(\"BOTLOADER_INTERVAL_TIMER_FIRED\", this.handleIntervalEvent.bind(this));\n    }\n    async handleIntervalEvent(evt) {\n        const timer = this.intervalTimers.find((timer)=>timer.timer.name === evt.name && this.pluginId === evt.pluginId);\n        if (timer) {\n            await timer.callback();\n        }\n    }\n    /**\n     * @internal\n     */ genCommandsBinding() {\n        const commands = this.commands.map((cmd)=>{\n            const options = [];\n            for(let prop in cmd.options){\n                if (Object.prototype.hasOwnProperty.call(cmd.options, prop)) {\n                    let entry = cmd.options[prop];\n                    options.push({\n                        name: prop,\n                        description: entry.description,\n                        kind: entry.kind,\n                        required: entry.required || false,\n                        extraOptions: entry.extraOptions\n                    });\n                }\n            }\n            let group = undefined;\n            let subGroup = undefined;\n            if (cmd.group) {\n                if (cmd.group.parent) {\n                    group = cmd.group.parent.name;\n                    subGroup = cmd.group.name;\n                } else {\n                    group = cmd.group.name;\n                }\n            }\n            return {\n                name: cmd.name,\n                description: cmd.description,\n                options: options,\n                kind: cmd.kind,\n                group,\n                subGroup\n            };\n        });\n        // collect all the groups\n        const groups = [];\n        OUTER: for (let cmd of this.commands){\n            if (cmd.group) {\n                if (cmd.group.parent) {\n                    // this is a subgroup\n                    let parent = groups.find((g)=>g.name === cmd.group?.parent?.name);\n                    if (!parent) {\n                        // parent did not exist\n                        parent = {\n                            name: cmd.group.parent.name,\n                            description: cmd.group.description,\n                            subGroups: []\n                        };\n                        groups.push(parent);\n                    }\n                    if (parent.subGroups.some((sg)=>sg.name === cmd.group?.name)) {\n                        continue OUTER;\n                    }\n                    parent.subGroups.push({\n                        name: cmd.group.name,\n                        description: cmd.group.description\n                    });\n                } else {\n                    // Top level group\n                    if (groups.some((g)=>g.name === cmd.group?.name)) {\n                        continue OUTER;\n                    }\n                    // new group\n                    groups.push({\n                        name: cmd.group.name,\n                        description: cmd.group.description,\n                        // we cannot have both commands and subgroups, unless im mistaken?\n                        subGroups: []\n                    });\n                }\n            }\n        }\n        return [\n            commands,\n            groups\n        ];\n    }\n}\n",
                    ),
                    (
                        ::url::Url::parse("file:///storage.js").unwrap(),
                        "import { OpWrappers } from \"./op_wrappers\";\nexport var Storage;\n(function(Storage) {\n    class Bucket {\n        pluginId;\n        name;\n        /**\n         * This constructor is unstable, you should use the related script methods.\n         * \n         * @internal\n         */ constructor(name, pluginId){\n            this.name = name;\n            this.pluginId = pluginId ?? null;\n        }\n        entryFromInternal(entry) {\n            let val = this.fromInternalValue(entry.value);\n            if (val == undefined) {\n                throw new Error(\"failed converting from internal value, incorrect type. This can happen if you changed the bucket type from say number to json, don\'t do that.\");\n            }\n            return {\n                pluginId: entry.pluginId,\n                bucket: this.name,\n                key: entry.key,\n                value: val,\n                expiresAt: entry.expiresAt ? new Date(entry.expiresAt) : undefined\n            };\n        }\n        entryFromInternalOptional(entry) {\n            if (entry) {\n                return this.entryFromInternal(entry);\n            } else {\n                return undefined;\n            }\n        }\n        /**\n         * Store a value at the provided key in the bucket, this will overwrite the previous value stored there, if any.\n         * \n         * @param key The key that you\'re storing the value in \n         * @param value The value you\'re storing, for objects this will be converted to json behind the scenes\n         * @param options Optional options\n         * @returns The storage entry\n         */ async set(key, value, options) {\n            return this.entryFromInternal(await OpWrappers.bucketStorageSet({\n                pluginId: this.pluginId,\n                bucketName: this.name,\n                key: key,\n                value: this.intoInternalValue(value),\n                ttl: options?.ttl\n            }));\n        }\n        /**\n         * Similar to {@link set} but stores the value conditionally.\n         * \n         * @param key The key where you\'re storing the value\n         * @param value The value you\'re storing, for objects this will be converted to json behind the scenes\n         * @param cond The condition that has to pass to store the value.\n         *  - IfExists: will only store the value if the key existed beforehand. \n         *  - IfNotExists: will only store the value if the key did not exist. \n         * @param options Optional options\n         * @returns Either the new entry, or undefined if the condition failed. \n         */ async setIf(key, value, cond, options) {\n            return this.entryFromInternalOptional(await OpWrappers.bucketStorageSetIf({\n                pluginId: this.pluginId,\n                bucketName: this.name,\n                key,\n                value: this.intoInternalValue(value),\n                ttl: options?.ttl,\n                cond\n            }));\n        }\n        /**\n         * Fetches a entry from the bucket.\n         * \n         * @param key The key for the value you want returned\n         * @returns The entry, or undefined if it did not exist\n         */ async get(key) {\n            return this.entryFromInternalOptional(await OpWrappers.bucketStorageGet({\n                pluginId: this.pluginId,\n                bucketName: this.name,\n                key: key\n            }));\n        }\n        /**\n         * Deletes an entry from the bucket permanently.\n         * \n         * @param key The key to delete\n         * @returns The deleted entry, or undefined if none\n         */ async delete(key) {\n            return this.entryFromInternalOptional(await OpWrappers.bucketStorageDel({\n                pluginId: this.pluginId,\n                bucketName: this.name,\n                key: key\n            }));\n        }\n        /**\n         * Deletes all entries (optionally filtering by pattern) permanently.\n         * \n         * @param keyPattern Optional key pattern to filter by\n         * \n         *  - `%`: A percent sign (%) matches any sequence of zero or more characters.\n         *  - `_`: An underscore (_) matches any single character.\n         * \n         * To match _ and % as literals escape them with backslash (`\\_` and `\\%`).\n         * \n         * @returns Number of deleted entries\n         */ async deleteAll(keyPattern) {\n            return OpWrappers.bucketStorageDelMany(this.pluginId, this.name, keyPattern || \"%\");\n        }\n        /**\n         * Retrieve a list of entries from the database, you can use `after` to paginate through all the items in the bucket.\n         * \n         * @param options Pagination options\n         * @returns A list of entries\n         */ async list(options) {\n            const res = await OpWrappers.bucketStorageList({\n                pluginId: this.pluginId,\n                bucketName: this.name,\n                after: options.after,\n                keyPattern: options.keyPattern,\n                limit: options.limit\n            });\n            return res.map((v)=>this.entryFromInternal(v));\n        }\n        /**\n         * Counts the number of entries in a bucket (optionally filtering by pattern).\n         * \n         * @param keyPattern Optional key pattern to filter by\n         * \n         *  - `%`: A percent sign (%) matches any sequence of zero or more characters.\n         *  - `_`: An underscore (_) matches any single character.\n         * \n         * To match _ and % as literals escape them with backslash (`\\_` and `\\%`).\n         * \n         * @returns Number of entries\n         */ async count(keyPattern) {\n            return OpWrappers.bucketStorageCount(this.pluginId, this.name, keyPattern || \"%\");\n        }\n    }\n    /**\n     * \n     * A Bucket provides persistent storage to botloader, using this you can store data and have it persist across vm reloads and bot restarts.\n     * \n     * Buckets are namespaces, A Bucket with the name `a` holds different values from another Bucket with the name `b` even though the keys might be the same.\n     * \n     * @remark this bucket should be registered with your script or plugin (example: `script.registerStorageBucket(...)`).\n     * \n     * @typeParam T - The type of values stored in this bucket\n     */ Storage.Bucket = Bucket;\n    class NumberBucket extends Bucket {\n        intoInternalValue(v) {\n            return {\n                double: v\n            };\n        }\n        fromInternalValue(v) {\n            if (\'double\' in v) {\n                return v.double;\n            }\n            return undefined;\n        }\n        /**\n         * Atomically increments the value stored at key. If the entry did not exist beforehand a new one is created and set to `amount`\n         * \n         * @param key The key whose value to increment\n         * @param amount The amount to increment the value by\n         * @returns The entry after incrementing the value\n         */ async incr(key, amount) {\n            return this.entryFromInternal(await OpWrappers.bucketStorageIncr({\n                pluginId: this.pluginId,\n                bucketName: this.name,\n                key: key,\n                amount: amount\n            }));\n        }\n        /**\n         * Returns a list of entries in the bucket sorted by values\n         * \n         * @param order The order of which you want the entries in the bucket sorted by\n         * @param options Pagination options\n         */ async sortedList(order, options) {\n            const res = await OpWrappers.bucketStorageSortedList({\n                pluginId: this.pluginId,\n                bucketName: this.name,\n                limit: options?.limit,\n                offset: options?.offset,\n                order: order\n            });\n            return res.map((v)=>this.entryFromInternal(v));\n        }\n    }\n    /**\n     * A Bucket holding number values\n     * \n     * The values being numbers allows them to be sorted easily giving you access to {@link incr} and {@link sortedList}.\n     * \n     * {@see} {@link Bucket} for more info on buckets.\n     */ Storage.NumberBucket = NumberBucket;\n    class JsonBucket extends Bucket {\n        intoInternalValue(v) {\n            return {\n                // json is handled on the rust side and opcall side\n                json: v\n            };\n        }\n        fromInternalValue(v) {\n            if (\'json\' in v) {\n                // json is handled on the rust side and opcall side\n                return v.json;\n            }\n            return undefined;\n        }\n    }\n    /**\n     * A Bucket holding json objects\n     * \n     * {@see} {@link Bucket} for more info on buckets.\n     */ Storage.JsonBucket = JsonBucket;\n    class Var {\n        bucket;\n        key;\n        /**\n         * @internal\n         */ constructor(b, key){\n            this.key = key;\n            this.bucket = b;\n        }\n        /**\n         * Store a value at the provided key in the bucket, this will overwrite the previous value stored there, if any.\n         * \n         * @param value The value you\'re storing, for objects this will be converted to json behind the scenes\n         * @param options Optional options\n         * @returns The storage entry\n         */ async set(value, options) {\n            return this.bucket.set(this.key, value, options);\n        }\n        /**\n         * Similar to {@link set} but stores the value conditionally.\n         * \n         * @param value The value you\'re storing, for objects this will be converted to json behind the scenes\n         * @param cond The condition that has to pass to store the value.\n         *  - IfExists: will only store the value if the key existed beforehand. \n         *  - IfNotExists: will only store the value if the key did not exist. \n         * @param options Optional options\n         * @returns Either the new entry, or undefined if the condition failed. \n         */ async setIf(value, cond, options) {\n            return this.bucket.setIf(this.key, value, cond, options);\n        }\n        /**\n         * Fetches the current value\n         * \n         * @returns The entry, or undefined if it did not exist\n         */ async get() {\n            return this.bucket.get(this.key);\n        }\n        /**\n         * Deletes the key from the database\n         * \n         * @returns The deleted entry, or undefined if none\n         */ async delete() {\n            return this.bucket.delete(this.key);\n        }\n    }\n    /**\n     * A single persistent variable.\n     * \n     * This internally just uses a storage bucket so the functionality is identical to storage buckets.\n     * \n     * You can think of this as just a single entry inside a storage bucket\n     */ Storage.Var = Var;\n    class NumberVar extends Var {\n        bucket;\n        /**\n         * This constructor is unstable, you should use the related script methods.\n         * \n         * @internal\n         */ constructor(namespace, key, pluginId){\n            const bucket = new NumberBucket(namespace, pluginId);\n            super(bucket, key);\n            this.bucket = bucket;\n        }\n        /**\n         * Atomically increments the value stored at key. If the entry did not exist beforehand a new one is created and set to `amount`\n         * \n         * @param amount The amount to increment the value by\n         * @returns The entry after incrementing the value\n         */ async incr(amount) {\n            return this.bucket.incr(this.key, amount);\n        }\n    }\n    Storage.NumberVar = NumberVar;\n    class JsonVar extends Var {\n        bucket;\n        /**\n         * This constructor is unstable, you should use the related script methods.\n         * \n         * @internal\n         */ constructor(namespace, key, pluginId){\n            const bucket = new JsonBucket(namespace, pluginId);\n            super(bucket, key);\n            this.bucket = bucket;\n        }\n    }\n    Storage.JsonVar = JsonVar;\n})(Storage || (Storage = {}));\n",
                    ),
                    (
                        ::url::Url::parse("file:///commands.js").unwrap(),
                        "import { Interaction, Message } from \"./discord/index\";\nimport { User } from \"./discord/user\";\nimport { Member } from \"./discord/member\";\nimport { OpWrappers } from \"./op_wrappers\";\nexport var Commands;\n(function(Commands) {\n    class System {\n        commands = [];\n        addCommand(cmd) {\n            if (this.commands.find((v)=>matchesCommand(cmd, v.name, v.group?.name, v.group?.parent?.name))) {\n                throw new Error(`Duplicate commands registered! Cmd: ${cmd.name}, parent: ${cmd.group?.name}, parent of parent: ${cmd.group?.parent?.name}`);\n            }\n            this.commands.push(cmd);\n        }\n        /**\n         * @internal\n         */ async handleInteractionCreate(interaction) {\n            let command = this.commands.find((cmd)=>matchesCommand(cmd, interaction.name, interaction.parentName, interaction.parentParentName));\n            if (!command) {\n                return;\n            }\n            let ctx = new ExecutedCommandContext(interaction);\n            if (command.ackMode === \"DeferredMessage\") {\n                await ctx.ackWithDeferredMessage({\n                    flags: command.ackMessageFlags\n                });\n            }\n            if (interaction.kind === \"Chat\") {\n                let optionsMap = {};\n                for (let opt of interaction.options){\n                    optionsMap[opt.name] = this.resolveOption(interaction.dataMap, opt.value);\n                }\n                await command.cb(ctx, optionsMap);\n            } else if (interaction.kind === \"Message\") {\n                if (interaction.targetId) {\n                    let message = interaction.dataMap.messages[interaction.targetId];\n                    await command.cb(ctx, new Message(message));\n                } else {\n                    throw new Error(\"message not found in datamap\");\n                }\n            } else if (interaction.kind === \"User\") {\n                if (interaction.targetId) {\n                    let member = interaction.dataMap.members[interaction.targetId];\n                    let user = interaction.dataMap.users[interaction.targetId];\n                    let args = {\n                        user: new User(user),\n                        member\n                    };\n                    await command.cb(ctx, args);\n                } else {\n                    throw new Error(\"member not found in datamap\");\n                }\n            } else {\n                throw new Error(\"Unknown command type\");\n            }\n        }\n        resolveOption(map, opt) {\n            switch(opt.kind){\n                case \"user\":\n                    const user = map.users[opt.value];\n                    if (user === undefined) {\n                        throw new Error(\"interaction user not found in data map\");\n                    }\n                    const ret = {\n                        user: new User(user),\n                        member: map.members[opt.value]\n                    };\n                    return ret;\n                case \"role\":\n                    const role = map.roles[opt.value];\n                    if (role === undefined) {\n                        throw new Error(\"interaction role not found in data map\");\n                    }\n                    return role;\n                case \"mentionable\":\n                    let metionableRet;\n                    const mentionableUser = map.users[opt.value];\n                    if (mentionableUser) {\n                        metionableRet = {\n                            kind: \"User\",\n                            value: {\n                                user: new User(mentionableUser),\n                                member: map.members[opt.value]\n                            }\n                        };\n                    } else {\n                        let mentionableRole = map.roles[opt.value];\n                        if (!mentionableRole) {\n                            throw new Error(\"interaction mentionable (role or user) not found in data map\");\n                        }\n                        metionableRet = {\n                            kind: \"Role\",\n                            value: mentionableRole\n                        };\n                    }\n                    return metionableRet;\n                case \"channel\":\n                    const channel = map.channels[opt.value];\n                    if (channel === undefined) {\n                        throw new Error(\"interaction channel not found in data map\");\n                    }\n                    return channel;\n                default:\n                    return opt.value;\n            }\n        }\n    }\n    /**\n     * @internal\n     */ Commands.System = System;\n    function matchesCommand(cmd, name, parentName, parentParentName) {\n        if (parentParentName) {\n            if (cmd.group && cmd.group.parent) {\n                return cmd.name === name && cmd.group.name === parentName && cmd.group.parent.name === parentParentName;\n            }\n        } else if (parentName) {\n            if (cmd.group && !cmd.group.parent) {\n                return cmd.name === name && cmd.group.name === parentName;\n            }\n        } else {\n            if (!cmd.group) {\n                return cmd.name === name;\n            }\n        }\n        return false;\n    }\n    class ExecutedCommandContext extends Interaction {\n        channelId;\n        /**\n         * Name of the command triggered\n         * \n         * Thie field is UNSTABLE and might change later\n         * \n         * @internal\n         */ commandName;\n        /**\n         * Parent group of the command that triggered\n         * \n         * Thie field is UNSTABLE and might change later\n         * \n         * @internal\n         */ parentName;\n        /**\n         * Parent group of the parent group of the command that triggered \n         * \n         * Thie field is UNSTABLE and might change later\n         * \n         * @internal\n         */ parentParentName;\n        constructor(interaction){\n            super(interaction.id, interaction.token, new Member(interaction.member));\n            this.channelId = interaction.channelId;\n            this.commandName = interaction.name;\n            this.parentName = interaction.parentName ?? undefined;\n            this.parentParentName = interaction.parentParentName ?? undefined;\n        }\n        /**\n         * Acknowledge this interaction and open up a modal for the user.\n         * \n         * You have to acknowledge the interaction within 3 seconds, and it can only be done once. \n         */ async ackWithModal(modal) {\n            this.setCallbackSent();\n            return OpWrappers.interactionCallback({\n                interactionId: this.interactionId,\n                interactionToken: this.token,\n                data: {\n                    kind: \"Modal\",\n                    title: modal.title,\n                    customId: modal.customId,\n                    components: modal.components\n                }\n            });\n        }\n    }\n    /**\n     * Context information about a command being run\n     */ Commands.ExecutedCommandContext = ExecutedCommandContext;\n    class Group {\n        name;\n        description;\n        parent;\n        isSubGroup = false;\n        subGroups = [];\n        /**\n         * @param name name of the group as it shows in discord, 1-32 characters (no symbols except - and _)\n         * @param description description of the group, 1-100 characters\n         */ constructor(name, description){\n            this.name = name;\n            this.description = description;\n        }\n        /**\n         * Create a subgroup from this group.\n         * \n         * Note: subgroups cannot be made from other subgroups.\n         * @param name name of the subgroup, 1-32 characters\n         * @param description description of the subgroup, 1-100 characters\n         * @returns \n         */ subGroup(name, description) {\n            if (this.isSubGroup) {\n                throw \"cant make sub groups of sub groups\";\n            }\n            let group = new Group(name, description);\n            group.isSubGroup = true;\n            group.parent = this;\n            this.subGroups.push(group);\n            return group;\n        }\n    }\n    /**\n     * A Command group, can only be used with slash commands currently\n     * \n     * Groups can have subgroups, but not anything deeper than those 2 levels. This is because of discord restrictions.\n     */ Commands.Group = Group;\n    function slashCommand(name, description) {\n        return new SlashCommandBuilder(name, description, {});\n    }\n    /**\n     * Create a new slash command builder\n     * @param name name of the command, 1-32 characters, (no symbols except - and _)\n     * @param description 1-100 character description\n     * @returns a builder\n     * \n     * \n     * @example \n     * ```ts\n     * script.createCommand(Commands.slashCommand(\"echo\", \"echo\'s your input\")\n     * .addOptionString(\"what\", \"what to echo\")\n     * .build(async (ctx, args) => {\n     *      await ctx.sendResponse(args.what);\n     * }))\n     * ```\n     */ Commands.slashCommand = slashCommand;\n    class SlashCommandBuilder {\n        name;\n        description;\n        options;\n        group;\n        ackMode = \"DeferredMessage\";\n        ackMessageFlags = {};\n        constructor(name, description, options, group){\n            this.name = name;\n            this.description = description;\n            this.options = options;\n            this.group = group;\n        }\n        /**\n         * Assigns a group to this command\n         * \n         * @example \n         * ```ts\n         * const group = new Commands.Group(\"some-group\", \"some description\")\n         * script.addCommand(Commands.slashCommand(\"some-cmd\", \"some description\").setGroup(grou).build(...))\n         * ```\n         */ setGroup(group) {\n            this.group = group;\n            return this;\n        }\n        /**\n         * Set the ack mode of this command\n         * (if you\'re experienced with the discord api, this is the callback type to the interaction)\n         * \n         * `DeferredMessage`: It will respond with a deferred message, using the flags from setAckMessageFlags.\n         * `Custom`: You handle the ack\'ing of the interaction yourself, this allows you to use modals.\n         * \n         * Keep in mind when using custom, you have to ack the interaction within 3 seconds otherwise it will fail.\n         */ setAckMode(mode) {\n            this.ackMode = mode;\n            return this;\n        }\n        /**\n         * Sets the flags for the mssage sent when sending the intial interaction response.\n         * Epehemeral means that it can only be see by the person issuing the command.\n         */ setAckMessageFlags(flags) {\n            this.ackMessageFlags = flags;\n            return this;\n        }\n        /**\n         * See {@link addOption}\n         */ addOptionNumber(name, description, opts) {\n            return this.addOption(name, \"Number\", description, opts);\n        }\n        /**\n         * See {@link addOption}\n         */ addOptionString(name, description, opts) {\n            return this.addOption(name, \"String\", description, opts);\n        }\n        /**\n         * See {@link addOption}\n         */ addOptionInteger(name, description, opts) {\n            return this.addOption(name, \"Integer\", description, opts);\n        }\n        /**\n         * See {@link addOption}\n         */ addOptionBoolean(name, description, opts) {\n            return this.addOption(name, \"Boolean\", description, opts);\n        }\n        /**\n         * See {@link addOption}\n         */ addOptionUser(name, description, opts) {\n            return this.addOption(name, \"User\", description, opts);\n        }\n        /**\n         * See {@link addOption}\n         */ addOptionChannel(name, description, opts) {\n            return this.addOption(name, \"Channel\", description, opts);\n        }\n        /**\n         * See {@link addOption}\n         */ addOptionRole(name, description, opts) {\n            return this.addOption(name, \"Role\", description, opts);\n        }\n        /**\n         * See {@link addOption}\n         */ addOptionMentionable(name, description, opts) {\n            return this.addOption(name, \"Mentionable\", description, opts);\n        }\n        /**\n         * Adds a option/argument to this command.\n         * \n         * Each type of option has different settings you can adjust, but all of them have a \"required\" field that defaults\n         * to true, you can set it to false for optional options.\n         * \n         * @param name Name of the option, 1-32 characters (no symbols except - and _)\n         * @param kind What type of option this is\n         * @param description Description of the option, 1-100 characters long\n         * @param opts Additional options, depends on what \"kind\" you pass but all options has a \"required\" field that defaults to true\n         */ addOption(name, kind, description, opts) {\n            let required = true;\n            if (opts && opts.required !== undefined) {\n                required = opts.required;\n            }\n            let fullOpts = {\n                ...this.options,\n                [name]: {\n                    kind: kind,\n                    required: required,\n                    description: description,\n                    extraOptions: {\n                        ...opts\n                    }\n                }\n            };\n            // Return a new builder with new typings\n            // The new opts type is \"layered\" on top of the old one, making us able to use\n            // the generic typings of all the options in the callback\n            let next = new SlashCommandBuilder(this.name, this.description, fullOpts, this.group);\n            Object.assign(next, this);\n            next.options = fullOpts;\n            return next;\n        }\n        /**\n         * Build the command, providing a callback that runs when the command gets executed\n         * @returns The built command, pass it to @{link Script.createCommand} to actually create it on discord \n         */ build(callback) {\n            return {\n                name: this.name,\n                description: this.description,\n                kind: \"Chat\",\n                options: this.options,\n                group: this.group,\n                ackMode: this.ackMode,\n                ackMessageFlags: this.ackMessageFlags,\n                cb: callback\n            };\n        }\n    }\n    Commands.SlashCommandBuilder = SlashCommandBuilder;\n    function userCommand(name) {\n        return new UserCommandBuilder(name);\n    }\n    /**\n     * Creates a new user command builder. User commands show up in the context menu\n     * when right-clicking a user\n     * \n     * @param name 1-32 characters (no symbols except - and _)\n     * @param description 1-100 characters\n     */ Commands.userCommand = userCommand;\n    class UserCommandBuilder {\n        name;\n        ackMode = \"DeferredMessage\";\n        ackMessageFlags = {};\n        constructor(name){\n            this.name = name;\n        }\n        /**\n         * Set the ack mode of this command\n         * (if you\'re experienced with the discord api, this is the callback type to the interaction)\n         * \n         * `DeferredMessage`: It will respond with a public deferred message.\n         * `Custom`: You handle the ack\'ing of the interaction yourself, this allows you to\n         * use ephemeral responses and modals.\n         * \n         * \n         * Keep in mind when using custom, you have to ack the interaction within 3 seconds otherwise it will fail.\n         */ setAckMode(mode) {\n            this.ackMode = mode;\n            return this;\n        }\n        /**\n         * Sets the flags for the mssage sent when sending the intial interaction response.\n         * Epehemeral means that it can only be see by the person issuing the command.\n         */ setAckMessageFlags(flags) {\n            this.ackMessageFlags = flags;\n            return this;\n        }\n        build(cb) {\n            return {\n                name: this.name,\n                kind: \"User\",\n                description: \"\",\n                ackMode: this.ackMode,\n                cb: cb,\n                ackMessageFlags: this.ackMessageFlags\n            };\n        }\n    }\n    Commands.UserCommandBuilder = UserCommandBuilder;\n    function messageCommand(name) {\n        return new MessageCommandBuilder(name);\n    }\n    /**\n     * Creates a new message command builder. Message commands show up in the context menu\n     * when right-clicking a message\n     * \n     * @param name 1-32 characters (no symbols except - and _)\n     * @param description 1-100 characters\n     */ Commands.messageCommand = messageCommand;\n    class MessageCommandBuilder {\n        name;\n        ackMode = \"DeferredMessage\";\n        ackMessageFlags = {};\n        constructor(name){\n            this.name = name;\n        }\n        /**\n         * Set the ack mode of this command\n         * (if you\'re experienced with the discord api, this is the callback type to the interaction)\n         * \n         * `DeferredMessage`: It will respond with a public deferred message.\n         * `Custom`: You handle the ack\'ing of the interaction yourself, this allows you to\n         * use ephemeral responses and modals.\n         * \n         * \n         * Keep in mind when using custom, you have to ack the interaction within 3 seconds otherwise it will fail.\n         */ setAckMode(mode) {\n            this.ackMode = mode;\n            return this;\n        }\n        /**\n         * Sets the flags for the mssage sent when sending the intial interaction response.\n         * Epehemeral means that it can only be see by the person issuing the command.\n         */ setAckMessageFlags(flags) {\n            this.ackMessageFlags = flags;\n            return this;\n        }\n        build(cb) {\n            return {\n                name: this.name,\n                kind: \"Message\",\n                description: \"\",\n                ackMode: this.ackMode,\n                cb: cb,\n                ackMessageFlags: this.ackMessageFlags\n            };\n        }\n    }\n    Commands.MessageCommandBuilder = MessageCommandBuilder;\n})(Commands || (Commands = {}));\n",
                    ),
                    (
                        ::url::Url::parse("file:///httpclient.js").unwrap(),
                        "import { OpWrappers } from \"./op_wrappers\";\nimport { NativeReader } from \"./unstable/streams\";\nimport { decodeText, encodeText } from \"./core_util\";\nexport var HttpClient;\n(function(HttpClient) {\n    function request(method, path, init) {\n        let opts = {\n            ...init ?? {}\n        };\n        return new Request(method, path, opts);\n    }\n    /**\n     * Construct a new request\n     * \n     * @param method Request method\n     * @param path Request path\n     * @param init Additional options\n     * @returns A constructed request, this still needs to be sent with a optional body\n     */ HttpClient.request = request;\n    function get(path, init) {\n        return request(\"GET\", path, init);\n    }\n    /**\n     * Construct a new GET request\n     * \n     * @category Helpers\n     */ HttpClient.get = get;\n    function post(path, init) {\n        return request(\"POST\", path, init);\n    }\n    /**\n     * Construct a new POST request\n     * \n     * @category Helpers\n     */ HttpClient.post = post;\n    function head(path, init) {\n        return request(\"HEAD\", path, init);\n    }\n    /**\n     * Construct a new HEAD request\n     * \n     * @category Helpers\n     */ HttpClient.head = head;\n    function patch(path, init) {\n        return request(\"PATCH\", path, init);\n    }\n    /**\n     * Construct a new PATCH request\n     * \n     * @category Helpers\n     */ HttpClient.patch = patch;\n    function put(path, init) {\n        return request(\"PUT\", path, init);\n    }\n    /**\n     * Construct a new PUT request\n     * \n     * @category Helpers\n     */ HttpClient.put = put;\n    function del(path, init) {\n        return request(\"DELETE\", path, init);\n    }\n    /**\n     * Construct a new DELETE request\n     * \n     * @category Helpers\n     */ HttpClient.del = del;\n    function options(path, init) {\n        return request(\"OPTIONS\", path, init);\n    }\n    /**\n     * Construct a new OPTIONS request\n     * \n     * @category Helpers\n     */ HttpClient.options = options;\n    function trace(path, init) {\n        return request(\"TRACE\", path, init);\n    }\n    /**\n     * Construct a new TRACE request\n     * \n     * @category Helpers\n     */ HttpClient.trace = trace;\n    function connect(path, init) {\n        return request(\"CONNECT\", path, init);\n    }\n    /**\n     * Construct a new CONNECT request\n     * \n     * @category Helpers\n     */ HttpClient.connect = connect;\n    class Request {\n        /** {@inheritdoc RequestInit.scriptId} */ scriptId;\n        /** {@inheritdoc RequestInit.headers} */ headers;\n        // /** {@inheritdoc RequestInit.redirect} */\n        // redirect?: \"follow\" | \"manual\" | \"error\";\n        path;\n        method;\n        constructor(method, path, init){\n            this.path = path;\n            this.method = method;\n            this.headers = init?.headers;\n        // this.redirect = init?.redirect;\n        }\n        /**\n         * Send this request with a optional body.\n         * \n         * Note: if you dont consume the response body you should call `Response.body.close()`\n         * (this is done automatically after 30 seconds if you don\'t, but if you\'re sending a lot of requests its better to do it yourself)\n         * \n         * @param body The request body, see {@link sendJson} and {@link sendText} for helpers\n         * @returns A promise that resolbes with the response\n         */ async send(body) {\n            let reqBodyRid = undefined;\n            if (body) {\n                this.headers = this.headers ?? {};\n                body.setHeaders(this.headers);\n                reqBodyRid = OpWrappers.http.createRequestStream();\n                this.writeBody(body, reqBodyRid).finally(()=>Deno.core.tryClose(reqBodyRid));\n            }\n            let resp = await OpWrappers.http.requestSend({\n                headers: this.headers ?? {},\n                method: this.method,\n                path: this.path,\n                scriptId: this.scriptId ?? 0,\n                bodyResourceId: reqBodyRid\n            });\n            let respBody = new NativeReader(resp.bodyResourceId);\n            return new Response(resp.statusCode, resp.headers, respBody);\n        }\n        then(cb) {\n            return this.send().then(cb);\n        }\n        async writeBody(body, rid) {\n            let buf = new Uint8Array(1024 * 10);\n            while(true){\n                let read = await body.read(buf);\n                if (read > 0) {\n                    let written = await Deno.core.write(rid, buf.subarray(0, read));\n                    if (written < read) {\n                        return;\n                    }\n                }\n                if (read === 0) {\n                    return;\n                }\n            }\n        }\n        async sendJson(data) {\n            const serialized = encodeText(JSON.stringify(data));\n            return this.send(new Uint8ArrayBody(serialized, \"application/json\"));\n        }\n        async sendText(data) {\n            const encoded = encodeText(data);\n            return this.send(new Uint8ArrayBody(encoded, \"text/plain\"));\n        }\n    }\n    /**\n     * A constructed http request that has yet to be sent.\n     * \n     * Use one of the `send` methods to send it.\n     */ HttpClient.Request = Request;\n    class Uint8ArrayBody {\n        contentType;\n        remainingData;\n        constructor(data, contentType){\n            this.contentType = contentType;\n            this.remainingData = data;\n        }\n        setHeaders(headers) {\n            if (this.contentType) {\n                headers[\"Content-Type\"] = this.contentType;\n            }\n        }\n        async read(buf) {\n            if (this.remainingData.length > 0) {\n                const readValues = this.remainingData.subarray(0, buf.length);\n                buf.set(readValues, 0);\n                this.remainingData = this.remainingData.subarray(readValues.length);\n                return readValues.length;\n            }\n            return 0;\n        }\n    }\n    HttpClient.Uint8ArrayBody = Uint8ArrayBody;\n    class Response {\n        body;\n        headers;\n        statusCode;\n        constructor(statusCode, headers, body){\n            this.statusCode = statusCode;\n            this.headers = headers;\n            this.body = body;\n        }\n        /**\n         * Read the entire response body and return the raw Uint8Array for it.\n         */ async readAll() {\n            if (!this.body) {\n                throw new Error(\"no response body\");\n            }\n            let curBuffer = new Uint8Array();\n            let readBuf = new Uint8Array(1024 * 10);\n            while(true){\n                const n = await this.body.read(readBuf);\n                const newBuffer = new Uint8Array(curBuffer.length + n);\n                newBuffer.set(curBuffer, 0);\n                newBuffer.set(readBuf.slice(0, n), curBuffer.length);\n                curBuffer = newBuffer;\n                if (n === 0) {\n                    break;\n                }\n            }\n            return curBuffer;\n        }\n        /**\n         * Read and decode the response body as json\n         */ async json() {\n            let fullBody = decodeText(await this.readAll());\n            return JSON.parse(fullBody);\n        }\n        /**\n         * Read and decode the reponse body as utf8 encoded text\n         */ async text() {\n            let buf = await this.readAll();\n            return decodeText(buf);\n        }\n    }\n    /**\n     * A response to a http request.\n     * \n     * Note: if you dont consume the response body you should call `Response.body.close()`\n     * (this is done automatically after 30 seconds if you don\'t, but if you\'re sending a lot of requests its better to do it yourself)\n     */ HttpClient.Response = Response;\n})(HttpClient || (HttpClient = {}));\n",
                    ),
                    (
                        ::url::Url::parse("file:///core_util.js").unwrap(),
                        "import { OpWrappers } from \"./op_wrappers\";\nconst non_json = [\n    \"boolean\",\n    \"number\",\n    \"string\"\n];\nexport var console;\n(function(console) {\n    function log(...args) {\n        let output = \"\";\n        const first = true;\n        for (let arg of args){\n            if (!first) {\n                output += \", \";\n            }\n            if (non_json.includes(typeof arg)) {\n                output += arg;\n            } else {\n                output += JSON.stringify(arg);\n            }\n        }\n        let [file, line, col] = getCaller(2);\n        OpWrappers.consoleLog({\n            message: output,\n            fileName: file,\n            lineNumber: line,\n            colNumber: col\n        });\n    }\n    console.log = log;\n})(console || (console = {}));\n// after the many hours i\'ve spent digging around in v8, i still don\'t know the proper way of getting a stack trace.\n// so here\'s a hacky solution for now\nfunction getCaller(skip) {\n    const stack = new Error().stack;\n    const lines = stack.split(\"\\n\");\n    // get the correct line\n    let selected_line;\n    if (skip >= lines.length - 2) {\n        selected_line = lines[lines.length - 1];\n    } else {\n        selected_line = lines[skip + 1];\n    }\n    // parse it\n    const re = /(file:\\/\\/\\/.+):(\\d+):(\\d+)/;\n    const match = selected_line.match(re);\n    if (!match || match.length < 4) {\n        return [\n            undefined,\n            undefined,\n            undefined\n        ];\n    }\n    return [\n        match[1],\n        parseInt(match[2]),\n        parseInt(match[3])\n    ];\n}\nglobalThis.console = {\n    log: console.log\n};\n/**\n * Encode a string to its Uint8Array representation.\n */ export function encodeText(s) {\n    return Deno.core.encode(s);\n}\n/**\n * Decode a string from its Uint8Array representation.\n */ export function decodeText(buf) {\n    return Deno.core.decode(buf);\n}\n/**\n * An async lock only runs 1 function at a time, this is useful if you have a series of async operations that depend on the computation of previous operation.\n * \n * @example An example could be changing a single field in a json object:\n * \n * ```ts\n * let storageBucket = script.createStorageVarJson<{ a: number, b: number }>(\"test_async_lock\")\n * storageBucket.set({ a: 0, b: 0 })\n * \n * async function badMutateField() {\n *     // To change a single field we first need to retrieve the whole object\n *     let currentValue = (await storageBucket.get())!.value\n * \n *     // Then we save it with a new value for the \'a\' field\n *     await storageBucket.set({ ...current, a: currentValue.a + 10 })\n * \n *     // But what happens if you run this function twice at the same time? Or if its changed somewhere else in the meantime?\n *     // well it will be pretty random what happens then, it might sometimes work and it might sometimes not\n * }\n * \n * // In fact just running it twice like this without awaiting (causing both promises to run in the background at the same time):\n * badMutateField()\n * badMutateField()\n * // Would create a bad result\n * \n * // To fix this we create a async lock\n * const lock = new AsyncLock()\n * \n * async function goodMutateField() {\n *     // Then we use the withLocked method and give it a function to run\n *     //\n *     // This will produce the expected result of `a` being 20\n *     // This is because AsyncLock only runs 1 function at a time\n *     lock.withLocked(badMutateField)\n *     lock.withLocked(badMutateField)\n * } \n * ```\n */ export class AsyncLock {\n    locked = false;\n    waiting = [];\n    async lock() {\n        if (this.locked) {\n            await new Promise((complete)=>{\n                if (!this.locked) {\n                    this.locked = true;\n                    complete(null);\n                } else {\n                    this.waiting.push(complete);\n                }\n            });\n        } else {\n            this.locked = true;\n        }\n    }\n    unlock() {\n        let next = this.waiting.shift();\n        if (next) {\n            next(null);\n        } else {\n            this.locked = false;\n        }\n    }\n    /**\n     * Run the provided function exclusively on the lock\n     */ async withLocked(cb) {\n        await this.lock();\n        try {\n            return await cb();\n        } finally{\n            this.unlock();\n        }\n    }\n}\n",
                    ),
                    (
                        ::url::Url::parse("file:///settings.js").unwrap(),
                        "import { OpWrappers } from \"./op_wrappers\";\n/**\n * Builtin default values for option types\n */ export const SysDefaultValues = {\n    string: \"\",\n    float: null,\n    integer: null,\n    integer64: null,\n    channel: null,\n    channels: [],\n    role: null,\n    roles: []\n};\nfunction getSysDefaultValue(kind) {\n    return SysDefaultValues[kind];\n}\n/**\n * A loaded settings option, to access the value use the {@link value} field\n */ export class LoadedOption {\n    definition;\n    _value;\n    /**\n     * The loaded settings value\n     */ get value() {\n        return this._value;\n    }\n    /**\n     * @internal\n     */ constructor(definition, rawValue){\n        this.definition = definition;\n        if (rawValue) {\n            this._value = loadOptionValue(rawValue.value, definition.definition);\n        } else {\n            this._value = definition.definition.defaultValue ?? getSysDefaultValue(definition.definition.kind);\n        }\n    }\n}\n/**\n * Configuration options for your script/plugins\n * \n * Configuration options are configurable through the web interface, giving users of your script/plugin\n * the ability to change variables though the configuration options youe expose, without having to edit the source code.\n * \n * To register an optoin you use the appropiate addOption* methods, or the startList method.\n * \n * **Default values and \'required\'**\n * \n * You can provide a default value that is used when the field is not provided but\n * users can still put it to to the types appropiate empty value unless you set \"required\" to true\n * \n * Top level options can only be required if you have a default value assigned to them.\n * \n * The empty value for strings is an empty string (\"\") and setting required to true will require a non-empty string.\n * \n * Example:\n * ```\n * const xpNameSetting = script.settings.addOptionString(\"xp_name\", {\n *     label: \"XP point name\",\n *     description: \"Name to give xp points\",\n *     defaultValue: \"xp\",\n *     required: true,\n * })\n *\n * const messageXpCooldownSecondsSetting = script.settings.addOptionInteger(\"message_xp_cooldown_seconds\", {\n *     label: \"Message XP coooldown\",\n *     description: \"The time period between messages to wait before they\'re eligible for more XP\",\n *     defaultValue: 60,\n *     min: 0,\n *     required: true,\n * })\n * ```\n */ export class SettingsManager {\n    /**\n     * @internal\n     */ definitions = [];\n    /**\n     * @internal\n     */ loadedSettings;\n    /**\n     * @internal\n     */ constructor(scriptId){\n        this.loadedSettings = OpWrappers.getSettings(scriptId);\n    }\n    addOptionString(name, options) {\n        return this.addOption(name, \"string\", options);\n    }\n    addOptionFloat(name, options) {\n        return this.addOption(name, \"float\", options);\n    }\n    addOptionInteger(name, options) {\n        return this.addOption(name, \"integer\", options);\n    }\n    addOptionInteger64(name, options) {\n        return this.addOption(name, \"integer64\", options);\n    }\n    addOptionRole(name, options) {\n        return this.addOption(name, \"role\", options);\n    }\n    addOptionRoles(name, options) {\n        return this.addOption(name, \"roles\", options);\n    }\n    addOptionChannel(name, options) {\n        return this.addOption(name, \"channel\", options);\n    }\n    addOptionChannels(name, options) {\n        return this.addOption(name, \"channels\", options);\n    }\n    addOption(name, kind, options) {\n        const definition = {\n            kind: \"Option\",\n            name,\n            definition: {\n                kind,\n                ...options\n            }\n        };\n        this.definitions.push(definition);\n        const value = this.loadedSettings.find((v)=>v.name === name);\n        return new LoadedOption(definition, value);\n    }\n    /**\n     * Start building a list.\n     * \n     * The list give you the ability to expose a option that users can add multiple items to\n     * \n     * To create a list you define the schema, a set of options each item in the list needs to have.\n     * \n     * An example for this is level roles for a leveling system\n     * where each item would have a level integer option and a role option:\n     * \n     * ```\n     * const levelRolesSetting = script.settings.startList(\"level_roles\")\n     *   .addOptionInteger(\"level\", {\n     *       label: \"Level\",\n     *       required: true,\n     *       min: 1,\n     *       description: \"The level at which the user gains the role\"\n     *   })\n     *   .addOptionRole(\"role\", {\n     *       label: \"Level\",\n     *       required: true,\n     *       description: \"The role to assign the user\"\n     *   }).complete({\n     *       label: \"Level Roles\",\n     *       description: \"Roles to give users as they advance in levels\",\n     *   })\n     * ```\n     */ startList(name) {\n        return new ListBuilder(name, this);\n    }\n    /**\n     * @internal\n     */ toInternalOptions() {\n        return this.definitions.map((def)=>defToInternal(def));\n    }\n}\n/**\n * A loaded settings option list, to access the value use the {@link value} field\n */ export class LoadedList {\n    definition;\n    _value;\n    /**\n     * The actual loaded settings value\n     */ get value() {\n        return this._value;\n    }\n    /**\n     * @internal\n     */ constructor(definition, rawValue){\n        this.definition = definition;\n        if (!rawValue?.value) {\n            this._value = definition.options.defaultValue ?? [];\n            return;\n        }\n        const arrValue = rawValue?.value;\n        if (!Array.isArray(arrValue)) {\n            this._value = definition.options.defaultValue ?? [];\n            return;\n        }\n        this._value = [];\n        OUTER: for (const entry of arrValue){\n            if (!Array.isArray(entry)) {\n                console.log(`Invalid list item in option list ${definition.name} skipping...`);\n                continue;\n            }\n            const obj = {};\n            for (const [name, optionDefinition] of Object.entries(definition.template)){\n                const optionValue = entry.find((v)=>\"name\" in v && v.name === name);\n                if (optionValue && \"value\" in optionValue) {\n                    obj[name] = loadOptionValue(optionValue.value, optionDefinition);\n                } else {\n                    if (optionDefinition.required && optionDefinition.defaultValue === undefined) {\n                        console.log(`List item in option list ${definition.name} missing required option [${name}], skipping...`);\n                        continue OUTER;\n                    } else {\n                        obj[name] = optionDefinition.defaultValue ?? getSysDefaultValue(optionDefinition.kind);\n                    }\n                }\n            }\n            this._value.push(obj);\n        }\n    }\n}\nexport class ListBuilder {\n    manager;\n    name;\n    definitions = {};\n    constructor(name, manager){\n        this.name = name;\n        this.manager = manager;\n    }\n    addOptionString(name, options) {\n        return this.addOption(name, \"string\", options);\n    }\n    addOptionFloat(name, options) {\n        return this.addOption(name, \"float\", options);\n    }\n    addOptionInteger(name, options) {\n        return this.addOption(name, \"integer\", options);\n    }\n    addOptionInteger64(name, options) {\n        return this.addOption(name, \"integer64\", options);\n    }\n    addOptionRole(name, options) {\n        return this.addOption(name, \"role\", options);\n    }\n    addOptionRoles(name, options) {\n        return this.addOption(name, \"roles\", options);\n    }\n    addOptionChannel(name, options) {\n        return this.addOption(name, \"channel\", options);\n    }\n    addOptionChannels(name, options) {\n        return this.addOption(name, \"channels\", options);\n    }\n    addOption(name, kind, options) {\n        this.definitions[name] = {\n            kind: kind,\n            ...options\n        };\n        return this;\n    }\n    complete(options) {\n        const def = {\n            kind: \"List\",\n            name: this.name,\n            options: options ?? {},\n            template: this.definitions\n        };\n        this.manager.definitions.push(def);\n        const value = this.manager.loadedSettings.find((v)=>v.name === this.name);\n        return new LoadedList(def, value);\n    }\n}\nfunction defToInternal(def) {\n    if (def.kind === \"Option\") {\n        return {\n            kind: \"Option\",\n            data: {\n                name: def.name,\n                label: def.definition.label ?? def.name,\n                description: def.definition.description || \"\",\n                required: def.definition.required ?? false,\n                kind: optionTypesUnionToInternal(def.definition),\n                defaultValue: def.definition.defaultValue ?? null\n            }\n        };\n    } else {\n        return {\n            kind: \"List\",\n            data: {\n                name: def.name,\n                description: def.options.description || \"\",\n                label: def.options.label ?? def.name,\n                // asd: 10,\n                required: false,\n                defaultValue: def.options.defaultValue ?? null,\n                template: Object.entries(def.template).map(([k, v])=>({\n                        name: k,\n                        label: v.label ?? k,\n                        defaultValue: v.defaultValue ?? null,\n                        description: v.description ?? \"\",\n                        required: v.required ?? false,\n                        kind: optionTypesUnionToInternal(v)\n                    }))\n            }\n        };\n    }\n}\nfunction optionTypesUnionToInternal(def) {\n    switch(def.kind){\n        case \"string\":\n            return {\n                kind: \"string\",\n                max_length: def.maxLength ?? null,\n                min_length: def.minLength ?? null\n            };\n        case \"float\":\n            return {\n                kind: \"float\",\n                max: def.max ?? null,\n                min: def.min ?? null\n            };\n        case \"integer\":\n            return {\n                kind: \"integer\",\n                max: def.max ?? null,\n                min: def.min ?? null\n            };\n        case \"integer64\":\n            return {\n                kind: \"integer64\",\n                max: def.max ?? null,\n                min: def.min ?? null\n            };\n        case \"channel\":\n            return {\n                kind: \"channel\",\n                types: def.types ?? null\n            };\n        case \"channels\":\n            return {\n                kind: \"channels\",\n                types: def.types ?? null,\n                max_length: def.max ?? null,\n                min_length: 0\n            };\n        case \"role\":\n            return {\n                kind: \"role\",\n                assignable: def.requireAssignable ?? null\n            };\n        case \"roles\":\n            return {\n                kind: \"roles\",\n                assignable: def.requireAssignable ?? null,\n                max_length: def.max ?? null,\n                min_length: 0\n            };\n    }\n}\n// I originally tried to use generics here to double check the return type \n// but i seem to run into weird typescript limitations regaring that\n// and it also wouldn\'t be usable from the list then\'\n//\n// This performs some basic protections and sanity checks, but more in depth ones may be implemented later\nfunction loadOptionValue(value, definition) {\n    switch(definition.kind){\n        case \"string\":\n            {\n                return typeof value === \"string\" ? value : definition.defaultValue ?? getSysDefaultValue(definition.kind);\n            }\n        case \"float\":\n            {\n                return typeof value === \"number\" ? value : definition.defaultValue ?? getSysDefaultValue(definition.kind);\n            }\n        case \"integer\":\n            {\n                return typeof value === \"number\" ? Math.floor(value) : definition.defaultValue ?? getSysDefaultValue(definition.kind);\n            }\n        case \"integer64\":\n            {\n                return typeof value === \"string\" ? value : definition.defaultValue ?? getSysDefaultValue(definition.kind);\n            }\n        case \"channel\":\n            {\n                return typeof value === \"string\" ? value : definition.defaultValue ?? getSysDefaultValue(definition.kind);\n            }\n        case \"channels\":\n            {\n                return Array.isArray(value) ? value : definition.defaultValue ?? getSysDefaultValue(definition.kind);\n            }\n        case \"role\":\n            {\n                return typeof value === \"string\" ? value : definition.defaultValue ?? getSysDefaultValue(definition.kind);\n            }\n        case \"roles\":\n            {\n                return Array.isArray(value) ? value : definition.defaultValue ?? getSysDefaultValue(definition.kind);\n            }\n    }\n}\n",
                    ),
                ]
            }
            #[inline(always)]
            fn __stability() -> &'static [(::url::Url, &'static str); 191] {
                static LAZY: ::lazy_static::lazy::Lazy<
                    [(::url::Url, &'static str); 191],
                > = ::lazy_static::lazy::Lazy::INIT;
                LAZY.get(__static_ref_initialize)
            }
            __stability()
        }
    }
    impl ::lazy_static::LazyStatic for MODULE_MAP {
        fn initialize(lazy: &Self) {
            let _ = &**lazy;
        }
    }
    pub fn create_module_map() -> Vec<ModuleEntry> {
        MODULE_MAP
            .iter()
            .map(|(name, source)| ModuleEntry {
                source,
                specifier: name.clone(),
            })
            .collect()
    }
}
pub mod limits {
    use std::{cell::RefCell, num::NonZeroU32, rc::Rc};
    use crate::RuntimeContext;
    use deno_core::OpState;
    use governor::{
        clock::DefaultClock, state::{InMemoryState, NotKeyed},
        Quota,
    };
    use stores::config::PremiumSlotTier;
    pub type RateLimiter = governor::RateLimiter<NotKeyed, InMemoryState, DefaultClock>;
    pub struct RateLimiters {
        user_http: RateLimiter,
        task_ops: RateLimiter,
        discord_get_public_invite: RateLimiter,
    }
    impl RateLimiters {
        pub async fn user_http(op_state: &Rc<RefCell<OpState>>) {
            let ratelimiters = {
                op_state.borrow().borrow::<Rc<RateLimiters>>().clone()
            };
            ratelimiters.user_http.until_ready().await;
        }
        pub async fn task_ops(op_state: &Rc<RefCell<OpState>>) {
            let ratelimiters = {
                op_state.borrow().borrow::<Rc<RateLimiters>>().clone()
            };
            ratelimiters.task_ops.until_ready().await;
        }
        pub async fn discord_get_public_invite(op_state: &Rc<RefCell<OpState>>) {
            let ratelimiters = {
                op_state.borrow().borrow::<Rc<RateLimiters>>().clone()
            };
            ratelimiters.discord_get_public_invite.until_ready().await;
        }
    }
    impl RateLimiters {
        pub fn new(tier: Option<PremiumSlotTier>) -> Self {
            Self {
                user_http: RateLimiter::direct(
                    Quota::per_second(
                        NonZeroU32::new(
                                match tier {
                                    None => 1,
                                    Some(PremiumSlotTier::Lite) => 2,
                                    Some(PremiumSlotTier::Premium) => 2,
                                },
                            )
                            .unwrap(),
                    ),
                ),
                task_ops: RateLimiter::direct(
                    Quota::per_second(
                        NonZeroU32::new(
                                match tier {
                                    None => 1,
                                    Some(PremiumSlotTier::Lite) => 2,
                                    Some(PremiumSlotTier::Premium) => 10,
                                },
                            )
                            .unwrap(),
                    ),
                ),
                discord_get_public_invite: RateLimiter::direct(
                    Quota::per_second(
                        NonZeroU32::new(
                                match tier {
                                    None => 1,
                                    Some(PremiumSlotTier::Lite) => 1,
                                    Some(PremiumSlotTier::Premium) => 1,
                                },
                            )
                            .unwrap(),
                    ),
                ),
            }
        }
    }
    pub fn storage_total_size(op_state: &Rc<RefCell<OpState>>) -> u64 {
        let premium_tier = {
            let state = op_state.borrow();
            state.borrow::<RuntimeContext>().premium_tier
        };
        match premium_tier {
            None => 1_000_000,
            Some(PremiumSlotTier::Lite) => 10_000_000,
            Some(PremiumSlotTier::Premium) => 100_000_000,
        }
    }
    pub fn tasks_data_size(op_state: &Rc<RefCell<OpState>>) -> u64 {
        let premium_tier = {
            let state = op_state.borrow();
            state.borrow::<RuntimeContext>().premium_tier
        };
        match premium_tier {
            None => 1_000,
            Some(PremiumSlotTier::Lite) => 10_000,
            Some(PremiumSlotTier::Premium) => 10_000,
        }
    }
    pub fn tasks_scheduled_count(op_state: &Rc<RefCell<OpState>>) -> u64 {
        let premium_tier = {
            let state = op_state.borrow();
            state.borrow::<RuntimeContext>().premium_tier
        };
        match premium_tier {
            None => 10_000,
            Some(PremiumSlotTier::Lite) => 100_000,
            Some(PremiumSlotTier::Premium) => 100_000,
        }
    }
}
pub fn create_extensions(ctx: CreateRuntimeContext) -> Vec<Extension> {
    let mut http_client_builder: reqwest::ClientBuilder = reqwest::ClientBuilder::new();
    if let Some(proxy_addr) = &ctx.script_http_client_proxy {
        {
            use ::tracing::__macro_support::Callsite as _;
            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "event components/runtime/src/lib.rs:27",
                        "runtime",
                        ::tracing::Level::INFO,
                        ::core::option::Option::Some("components/runtime/src/lib.rs"),
                        ::core::option::Option::Some(27u32),
                        ::core::option::Option::Some("runtime"),
                        ::tracing_core::field::FieldSet::new(
                            &["message"],
                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                        ),
                        ::tracing::metadata::Kind::EVENT,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let enabled = ::tracing::Level::INFO
                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::INFO
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    let interest = __CALLSITE.interest();
                    !interest.is_never()
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                };
            if enabled {
                (|value_set: ::tracing::field::ValueSet| {
                    let meta = __CALLSITE.metadata();
                    ::tracing::Event::dispatch(meta, &value_set);
                    if match ::tracing::Level::INFO {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                use ::tracing::log;
                                let level = match ::tracing::Level::INFO {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                };
                                if level <= log::max_level() {
                                    let meta = __CALLSITE.metadata();
                                    let log_meta = log::Metadata::builder()
                                        .level(level)
                                        .target(meta.target())
                                        .build();
                                    let logger = log::logger();
                                    if logger.enabled(&log_meta) {
                                        ::tracing::__macro_support::__tracing_log(
                                            meta,
                                            logger,
                                            log_meta,
                                            &value_set,
                                        )
                                    }
                                }
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                })({
                    #[allow(unused_imports)]
                    use ::tracing::field::{debug, display, Value};
                    let mut iter = __CALLSITE.metadata().fields().iter();
                    __CALLSITE
                        .metadata()
                        .fields()
                        .value_set(
                            &[
                                (
                                    &::core::iter::Iterator::next(&mut iter)
                                        .expect("FieldSet corrupted (this is a bug)"),
                                    ::core::option::Option::Some(
                                        &format_args!("using http client proxy: {0}", proxy_addr)
                                            as &dyn Value,
                                    ),
                                ),
                            ],
                        )
                });
            } else {
                if match ::tracing::Level::INFO {
                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                    _ => ::tracing::log::Level::Trace,
                } <= ::tracing::log::STATIC_MAX_LEVEL
                {
                    if !::tracing::dispatcher::has_been_set() {
                        {
                            use ::tracing::log;
                            let level = match ::tracing::Level::INFO {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            };
                            if level <= log::max_level() {
                                let meta = __CALLSITE.metadata();
                                let log_meta = log::Metadata::builder()
                                    .level(level)
                                    .target(meta.target())
                                    .build();
                                let logger = log::logger();
                                if logger.enabled(&log_meta) {
                                    ::tracing::__macro_support::__tracing_log(
                                        meta,
                                        logger,
                                        log_meta,
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!("using http client proxy: {0}", proxy_addr)
                                                                    as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        },
                                    )
                                }
                            }
                        }
                    } else {
                        {}
                    }
                } else {
                    {}
                };
            }
        };
        let proxy = reqwest::Proxy::all(proxy_addr).expect("valid http proxy address");
        http_client_builder = http_client_builder.proxy(proxy);
    } else {}
    let http_client = http_client_builder.build().expect("valid http client");
    let premium_tier = *ctx.premium_tier.read().unwrap();
    let core_ctx = CoreRuntimeContext {
        event_tx: ctx.event_tx.clone(),
        settings_values: ctx.settings_values,
    };
    if let Some(guild_id) = ctx.guild_id {
        let rt_ctx = RuntimeContext {
            guild_id,
            bot_state: ctx.bot_state.clone(),
            discord_config: ctx.discord_config.clone(),
            guild_logger: ctx.guild_logger.clone(),
            script_http_client_proxy: ctx.script_http_client_proxy.clone(),
            event_tx: ctx.event_tx.clone(),
            premium_tier,
            main_tokio_runtime: ctx.main_tokio_runtime,
            db: ctx.db,
        };
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                bl_script_core::init_ops_and_esm(
                    core_ctx,
                    rt_ctx,
                    http_client,
                    premium_tier,
                ),
                extensions::storage::bl_storage::init_ops_and_esm(),
                extensions::discord::bl_discord::init_ops_and_esm(),
                extensions::console::bl_console::init_ops_and_esm(),
                extensions::httpclient::bl_http::init_ops_and_esm(),
                extensions::tasks::bl_tasks::init_ops_and_esm(),
            ]),
        )
    } else {
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                bl_script_core_no_guild::init_ops_and_esm(
                    core_ctx,
                    http_client,
                    premium_tier,
                ),
                extensions::storage::bl_storage::init_ops_and_esm(),
                extensions::discord::bl_discord::init_ops_and_esm(),
                extensions::console::bl_console::init_ops_and_esm(),
                extensions::httpclient::bl_http::init_ops_and_esm(),
                extensions::tasks::bl_tasks::init_ops_and_esm(),
            ]),
        )
    }
}
///
/// An extension for use with the Deno JS runtime.
/// To use it, provide it as an argument when instantiating your runtime:
///
/// ```rust,ignore
/// use deno_core::{ JsRuntime, RuntimeOptions };
///
///let mut extensions = vec![bl_script_core::init_ops_and_esm()];
/// let mut js_runtime = JsRuntime::new(RuntimeOptions {
///   extensions,
///   ..Default::default()
/// });
/// ```
///
#[allow(non_camel_case_types)]
pub struct bl_script_core {}
impl bl_script_core {
    fn ext() -> ::deno_core::Extension {
        #[allow(unused_imports)]
        use ::deno_core::Op;
        ::deno_core::Extension {
            name: "bl_script_core",
            deps: &[],
            js_files: {
                const JS: &'static [::deno_core::ExtensionFileSource] = &[];
                ::std::borrow::Cow::Borrowed(JS)
            },
            esm_files: {
                const JS: &'static [::deno_core::ExtensionFileSource] = &[];
                ::std::borrow::Cow::Borrowed(JS)
            },
            lazy_loaded_esm_files: {
                const JS: &'static [::deno_core::ExtensionFileSource] = &[];
                ::std::borrow::Cow::Borrowed(JS)
            },
            esm_entry_point: {
                const V: ::std::option::Option<&'static ::std::primitive::str> = ::std::option::Option::None;
                V
            },
            ops: ::std::borrow::Cow::Borrowed(
                &[
                    op_botloader_script_start::DECL,
                    op_get_current_bot_user::DECL,
                    op_get_current_guild_id::DECL,
                    op_get_run_mode::DECL,
                    op_get_settings::DECL,
                ],
            ),
            external_references: ::std::borrow::Cow::Borrowed(&[]),
            global_template_middleware: ::std::option::Option::None,
            global_object_middleware: ::std::option::Option::None,
            op_state_fn: ::std::option::Option::None,
            middleware_fn: ::std::option::Option::None,
            enabled: true,
        }
    }
    #[inline(always)]
    #[allow(unused_variables)]
    fn with_ops_fn(ext: &mut ::deno_core::Extension) {}
    #[inline(always)]
    #[allow(unused_variables)]
    fn with_state_and_middleware(
        ext: &mut ::deno_core::Extension,
        ctx: CoreRuntimeContext,
        rt_ctx: RuntimeContext,
        http_client: reqwest::Client,
        premium_tier: Option<PremiumSlotTier>,
    ) {
        {
            #[doc(hidden)]
            struct Config {
                pub ctx: CoreRuntimeContext,
                pub rt_ctx: RuntimeContext,
                pub http_client: reqwest::Client,
                pub premium_tier: Option<PremiumSlotTier>,
            }
            let config = Config {
                ctx,
                rt_ctx,
                http_client,
                premium_tier,
            };
            let state_fn: fn(&mut ::deno_core::OpState, Config) = |state, options| {
                state.put(options.ctx);
                state.put(options.rt_ctx);
                state.put(options.http_client);
                state.put(Rc::new(RateLimiters::new(options.premium_tier)));
            };
            ext
                .op_state_fn = ::std::option::Option::Some(
                ::std::boxed::Box::new(move |state: &mut ::deno_core::OpState| {
                    state_fn(state, config);
                }),
            );
        };
        ext
            .middleware_fn = ::std::option::Option::Some(
            ::std::boxed::Box::new(|op_decl| match op_decl.name {
                "op_print" => disabled_op::DECL,
                "op_wasm_streaming_feed" => disabled_op::DECL,
                "op_wasm_streaming_set_url" => disabled_op::DECL,
                _ => op_decl,
            }),
        );
    }
    #[inline(always)]
    #[allow(unused_variables)]
    #[allow(clippy::redundant_closure_call)]
    fn with_customizer(ext: &mut ::deno_core::Extension) {}
    #[allow(dead_code)]
    /// Initialize this extension for runtime or snapshot creation. Use this
    /// function if the runtime or snapshot is not created from a (separate)
    /// snapshot, or that snapshot does not contain this extension. Otherwise
    /// use `init_ops()` instead.
    ///
    /// # Returns
    /// an Extension object that can be used during instantiation of a JsRuntime
    pub fn init_ops_and_esm(
        ctx: CoreRuntimeContext,
        rt_ctx: RuntimeContext,
        http_client: reqwest::Client,
        premium_tier: Option<PremiumSlotTier>,
    ) -> ::deno_core::Extension {
        let mut ext = Self::ext();
        Self::with_ops_fn(&mut ext);
        Self::with_state_and_middleware(
            &mut ext,
            ctx,
            rt_ctx,
            http_client,
            premium_tier,
        );
        Self::with_customizer(&mut ext);
        ext
    }
    #[allow(dead_code)]
    /// Initialize this extension for runtime or snapshot creation, excluding
    /// its JavaScript sources and evaluation. This is used when the runtime
    /// or snapshot is created from a (separate) snapshot which includes this
    /// extension in order to avoid evaluating the JavaScript twice.
    ///
    /// # Returns
    /// an Extension object that can be used during instantiation of a JsRuntime
    pub fn init_ops(
        ctx: CoreRuntimeContext,
        rt_ctx: RuntimeContext,
        http_client: reqwest::Client,
        premium_tier: Option<PremiumSlotTier>,
    ) -> ::deno_core::Extension {
        let mut ext = Self::ext();
        Self::with_ops_fn(&mut ext);
        Self::with_state_and_middleware(
            &mut ext,
            ctx,
            rt_ctx,
            http_client,
            premium_tier,
        );
        Self::with_customizer(&mut ext);
        ext.js_files = ::std::borrow::Cow::Borrowed(&[]);
        ext.esm_files = ::std::borrow::Cow::Borrowed(&[]);
        ext.esm_entry_point = ::std::option::Option::None;
        ext
    }
}
///
/// An extension for use with the Deno JS runtime.
/// To use it, provide it as an argument when instantiating your runtime:
///
/// ```rust,ignore
/// use deno_core::{ JsRuntime, RuntimeOptions };
///
///let mut extensions = vec![bl_script_core_no_guild::init_ops_and_esm()];
/// let mut js_runtime = JsRuntime::new(RuntimeOptions {
///   extensions,
///   ..Default::default()
/// });
/// ```
///
#[allow(non_camel_case_types)]
pub struct bl_script_core_no_guild {}
impl bl_script_core_no_guild {
    fn ext() -> ::deno_core::Extension {
        #[allow(unused_imports)]
        use ::deno_core::Op;
        ::deno_core::Extension {
            name: "bl_script_core_no_guild",
            deps: &[],
            js_files: {
                const JS: &'static [::deno_core::ExtensionFileSource] = &[];
                ::std::borrow::Cow::Borrowed(JS)
            },
            esm_files: {
                const JS: &'static [::deno_core::ExtensionFileSource] = &[];
                ::std::borrow::Cow::Borrowed(JS)
            },
            lazy_loaded_esm_files: {
                const JS: &'static [::deno_core::ExtensionFileSource] = &[];
                ::std::borrow::Cow::Borrowed(JS)
            },
            esm_entry_point: {
                const V: ::std::option::Option<&'static ::std::primitive::str> = ::std::option::Option::None;
                V
            },
            ops: ::std::borrow::Cow::Borrowed(
                &[
                    op_botloader_script_start::DECL,
                    op_get_current_bot_user::DECL,
                    op_get_current_guild_id::DECL,
                    op_get_run_mode::DECL,
                    op_get_settings::DECL,
                ],
            ),
            external_references: ::std::borrow::Cow::Borrowed(&[]),
            global_template_middleware: ::std::option::Option::None,
            global_object_middleware: ::std::option::Option::None,
            op_state_fn: ::std::option::Option::None,
            middleware_fn: ::std::option::Option::None,
            enabled: true,
        }
    }
    #[inline(always)]
    #[allow(unused_variables)]
    fn with_ops_fn(ext: &mut ::deno_core::Extension) {}
    #[inline(always)]
    #[allow(unused_variables)]
    fn with_state_and_middleware(
        ext: &mut ::deno_core::Extension,
        ctx: CoreRuntimeContext,
        http_client: reqwest::Client,
        premium_tier: Option<PremiumSlotTier>,
    ) {
        {
            #[doc(hidden)]
            struct Config {
                pub ctx: CoreRuntimeContext,
                pub http_client: reqwest::Client,
                pub premium_tier: Option<PremiumSlotTier>,
            }
            let config = Config {
                ctx,
                http_client,
                premium_tier,
            };
            let state_fn: fn(&mut ::deno_core::OpState, Config) = |state, options| {
                state.put(options.ctx);
                state.put(options.http_client);
                state.put(Rc::new(RateLimiters::new(options.premium_tier)));
            };
            ext
                .op_state_fn = ::std::option::Option::Some(
                ::std::boxed::Box::new(move |state: &mut ::deno_core::OpState| {
                    state_fn(state, config);
                }),
            );
        };
        ext
            .middleware_fn = ::std::option::Option::Some(
            ::std::boxed::Box::new(|op_decl| match op_decl.name {
                "op_print" => disabled_op::DECL,
                "op_wasm_streaming_feed" => disabled_op::DECL,
                "op_wasm_streaming_set_url" => disabled_op::DECL,
                _ => op_decl,
            }),
        );
    }
    #[inline(always)]
    #[allow(unused_variables)]
    #[allow(clippy::redundant_closure_call)]
    fn with_customizer(ext: &mut ::deno_core::Extension) {}
    #[allow(dead_code)]
    /// Initialize this extension for runtime or snapshot creation. Use this
    /// function if the runtime or snapshot is not created from a (separate)
    /// snapshot, or that snapshot does not contain this extension. Otherwise
    /// use `init_ops()` instead.
    ///
    /// # Returns
    /// an Extension object that can be used during instantiation of a JsRuntime
    pub fn init_ops_and_esm(
        ctx: CoreRuntimeContext,
        http_client: reqwest::Client,
        premium_tier: Option<PremiumSlotTier>,
    ) -> ::deno_core::Extension {
        let mut ext = Self::ext();
        Self::with_ops_fn(&mut ext);
        Self::with_state_and_middleware(&mut ext, ctx, http_client, premium_tier);
        Self::with_customizer(&mut ext);
        ext
    }
    #[allow(dead_code)]
    /// Initialize this extension for runtime or snapshot creation, excluding
    /// its JavaScript sources and evaluation. This is used when the runtime
    /// or snapshot is created from a (separate) snapshot which includes this
    /// extension in order to avoid evaluating the JavaScript twice.
    ///
    /// # Returns
    /// an Extension object that can be used during instantiation of a JsRuntime
    pub fn init_ops(
        ctx: CoreRuntimeContext,
        http_client: reqwest::Client,
        premium_tier: Option<PremiumSlotTier>,
    ) -> ::deno_core::Extension {
        let mut ext = Self::ext();
        Self::with_ops_fn(&mut ext);
        Self::with_state_and_middleware(&mut ext, ctx, http_client, premium_tier);
        Self::with_customizer(&mut ext);
        ext.js_files = ::std::borrow::Cow::Borrowed(&[]);
        ext.esm_files = ::std::borrow::Cow::Borrowed(&[]);
        ext.esm_entry_point = ::std::option::Option::None;
        ext
    }
}
pub fn in_mem_source_load_fn(
    src: &'static str,
) -> Box<dyn Fn() -> Result<String, AnyError>> {
    Box::new(move || Ok(src.to_string()))
}
#[allow(non_camel_case_types)]
pub struct disabled_op {
    _unconstructable: ::std::marker::PhantomData<()>,
}
impl ::deno_core::_ops::Op for disabled_op {
    const NAME: &'static str = "disabled_op";
    const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
        {
            const LITERAL: &'static [u8] = "disabled_op".as_bytes();
            const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                LITERAL,
            );
            let s: &'static ::deno_core::v8::OneByteConst = &STR;
            ("disabled_op", ::deno_core::FastStaticString::new(s))
        },
        false,
        false,
        0usize as u8,
        Self::v8_fn_ptr as _,
        Self::v8_fn_ptr_metrics as _,
        Some({
            use deno_core::v8::fast_api::Type;
            use deno_core::v8::fast_api::CType;
            deno_core::v8::fast_api::FastFunction::new_with_bigint(
                &[Type::V8Value, Type::CallbackOptions],
                CType::Void,
                Self::v8_fn_ptr_fast as *const ::std::ffi::c_void,
            )
        }),
        Some({
            use deno_core::v8::fast_api::Type;
            use deno_core::v8::fast_api::CType;
            deno_core::v8::fast_api::FastFunction::new_with_bigint(
                &[Type::V8Value, Type::CallbackOptions],
                CType::Void,
                Self::v8_fn_ptr_fast_metrics as *const ::std::ffi::c_void,
            )
        }),
        ::deno_core::OpMetadata {
            ..::deno_core::OpMetadata::default()
        },
    );
}
impl disabled_op {
    pub const fn name() -> &'static str {
        "disabled_op"
    }
    #[deprecated(note = "Use the const op::DECL instead")]
    pub const fn decl() -> deno_core::_ops::OpDecl {
        <Self as deno_core::_ops::Op>::DECL
    }
    #[allow(clippy::too_many_arguments)]
    fn v8_fn_ptr_fast_metrics(
        this: deno_core::v8::Local<deno_core::v8::Object>,
        fast_api_callback_options: *mut deno_core::v8::fast_api::FastApiCallbackOptions,
    ) -> () {
        let fast_api_callback_options = unsafe { &mut *fast_api_callback_options };
        let opctx = unsafe {
            &*(deno_core::v8::Local::<
                deno_core::v8::External,
            >::cast(unsafe { fast_api_callback_options.data.data })
                .value() as *const deno_core::_ops::OpCtx)
        };
        deno_core::_ops::dispatch_metrics_fast(
            &opctx,
            deno_core::_ops::OpMetricsEvent::Dispatched,
        );
        let res = Self::v8_fn_ptr_fast(this, fast_api_callback_options);
        deno_core::_ops::dispatch_metrics_fast(
            &opctx,
            deno_core::_ops::OpMetricsEvent::Completed,
        );
        res
    }
    #[allow(clippy::too_many_arguments)]
    fn v8_fn_ptr_fast(
        _: deno_core::v8::Local<deno_core::v8::Object>,
        fast_api_callback_options: *mut deno_core::v8::fast_api::FastApiCallbackOptions,
    ) -> () {
        #[cfg(debug_assertions)]
        let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
            &<Self as deno_core::_ops::Op>::DECL,
        );
        let fast_api_callback_options = unsafe { &mut *fast_api_callback_options };
        let opctx = unsafe {
            &*(deno_core::v8::Local::<
                deno_core::v8::External,
            >::cast(unsafe { fast_api_callback_options.data.data })
                .value() as *const deno_core::_ops::OpCtx)
        };
        let result = { Self::call() };
        let result = match result {
            Ok(result) => result,
            Err(err) => {
                let err = err.into();
                unsafe {
                    opctx.unsafely_set_last_error_for_ops_only(err);
                }
                fast_api_callback_options.fallback = true;
                return unsafe { std::mem::zeroed() };
            }
        };
        result as _
    }
    #[inline(always)]
    fn slow_function_impl(info: *const deno_core::v8::FunctionCallbackInfo) -> usize {
        #[cfg(debug_assertions)]
        let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
            &<Self as deno_core::_ops::Op>::DECL,
        );
        let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
            &*info
        });
        let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
            &*info
        });
        let opctx = unsafe {
            &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data()).value()
                as *const deno_core::_ops::OpCtx)
        };
        if let Some(err) = unsafe { opctx.unsafely_take_last_error_for_ops_only() } {
            let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
            let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                &*info
            });
            let err = err.into();
            let exception = deno_core::error::to_v8_error(
                &mut scope,
                opctx.get_error_class_fn,
                &err,
            );
            scope.throw_exception(exception);
            return 1;
        }
        let result = { Self::call() };
        match result {
            Ok(result) => deno_core::_ops::RustToV8RetVal::to_v8_rv(result, &mut rv),
            Err(err) => {
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
                    &*info
                });
                let err = err.into();
                let exception = deno_core::error::to_v8_error(
                    &mut scope,
                    opctx.get_error_class_fn,
                    &err,
                );
                scope.throw_exception(exception);
                return 1;
            }
        };
        return 0;
    }
    extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
        Self::slow_function_impl(info);
    }
    extern "C" fn v8_fn_ptr_metrics(info: *const deno_core::v8::FunctionCallbackInfo) {
        let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
            &*info
        });
        let opctx = unsafe {
            &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data()).value()
                as *const deno_core::_ops::OpCtx)
        };
        deno_core::_ops::dispatch_metrics_slow(
            &opctx,
            deno_core::_ops::OpMetricsEvent::Dispatched,
        );
        let res = Self::slow_function_impl(info);
        if res == 0 {
            deno_core::_ops::dispatch_metrics_slow(
                &opctx,
                deno_core::_ops::OpMetricsEvent::Completed,
            );
        } else {
            deno_core::_ops::dispatch_metrics_slow(
                &opctx,
                deno_core::_ops::OpMetricsEvent::Error,
            );
        }
    }
    #[inline(always)]
    pub fn call() -> Result<(), AnyError> {
        Err(
            ::anyhow::__private::must_use({
                let error = ::anyhow::__private::format_err(
                    format_args!("this op is disabled"),
                );
                error
            }),
        )
    }
}
pub struct CoreRuntimeContext {
    pub event_tx: mpsc::UnboundedSender<RuntimeEvent>,
    pub settings_values: Vec<ScriptSettingsValues>,
}
#[automatically_derived]
impl ::core::clone::Clone for CoreRuntimeContext {
    #[inline]
    fn clone(&self) -> CoreRuntimeContext {
        CoreRuntimeContext {
            event_tx: ::core::clone::Clone::clone(&self.event_tx),
            settings_values: ::core::clone::Clone::clone(&self.settings_values),
        }
    }
}
pub struct RuntimeContext {
    pub guild_id: Id<GuildMarker>,
    pub bot_state: dbrokerapi::state_client::Client,
    pub discord_config: Arc<DiscordConfig>,
    pub guild_logger: GuildLogSender,
    pub script_http_client_proxy: Option<String>,
    pub event_tx: mpsc::UnboundedSender<RuntimeEvent>,
    pub premium_tier: Option<PremiumSlotTier>,
    pub main_tokio_runtime: tokio::runtime::Handle,
    pub db: Db,
}
#[automatically_derived]
impl ::core::clone::Clone for RuntimeContext {
    #[inline]
    fn clone(&self) -> RuntimeContext {
        RuntimeContext {
            guild_id: ::core::clone::Clone::clone(&self.guild_id),
            bot_state: ::core::clone::Clone::clone(&self.bot_state),
            discord_config: ::core::clone::Clone::clone(&self.discord_config),
            guild_logger: ::core::clone::Clone::clone(&self.guild_logger),
            script_http_client_proxy: ::core::clone::Clone::clone(
                &self.script_http_client_proxy,
            ),
            event_tx: ::core::clone::Clone::clone(&self.event_tx),
            premium_tier: ::core::clone::Clone::clone(&self.premium_tier),
            main_tokio_runtime: ::core::clone::Clone::clone(&self.main_tokio_runtime),
            db: ::core::clone::Clone::clone(&self.db),
        }
    }
}
pub struct CreateRuntimeContext {
    pub guild_id: Option<Id<GuildMarker>>,
    pub bot_state: dbrokerapi::state_client::Client,
    pub discord_config: Arc<DiscordConfig>,
    pub guild_logger: GuildLogSender,
    pub script_http_client_proxy: Option<String>,
    pub event_tx: mpsc::UnboundedSender<RuntimeEvent>,
    pub premium_tier: Arc<RwLock<Option<PremiumSlotTier>>>,
    pub main_tokio_runtime: tokio::runtime::Handle,
    pub settings_values: Vec<ScriptSettingsValues>,
    pub db: Db,
}
#[automatically_derived]
impl ::core::clone::Clone for CreateRuntimeContext {
    #[inline]
    fn clone(&self) -> CreateRuntimeContext {
        CreateRuntimeContext {
            guild_id: ::core::clone::Clone::clone(&self.guild_id),
            bot_state: ::core::clone::Clone::clone(&self.bot_state),
            discord_config: ::core::clone::Clone::clone(&self.discord_config),
            guild_logger: ::core::clone::Clone::clone(&self.guild_logger),
            script_http_client_proxy: ::core::clone::Clone::clone(
                &self.script_http_client_proxy,
            ),
            event_tx: ::core::clone::Clone::clone(&self.event_tx),
            premium_tier: ::core::clone::Clone::clone(&self.premium_tier),
            main_tokio_runtime: ::core::clone::Clone::clone(&self.main_tokio_runtime),
            settings_values: ::core::clone::Clone::clone(&self.settings_values),
            db: ::core::clone::Clone::clone(&self.db),
        }
    }
}
pub struct ScriptSettingsValues {
    pub script_id: u64,
    pub settings_values: Vec<SettingsOptionValue>,
}
#[automatically_derived]
impl ::core::clone::Clone for ScriptSettingsValues {
    #[inline]
    fn clone(&self) -> ScriptSettingsValues {
        ScriptSettingsValues {
            script_id: ::core::clone::Clone::clone(&self.script_id),
            settings_values: ::core::clone::Clone::clone(&self.settings_values),
        }
    }
}
#[allow(non_camel_case_types)]
pub struct op_get_current_bot_user {
    _unconstructable: ::std::marker::PhantomData<()>,
}
impl ::deno_core::_ops::Op for op_get_current_bot_user {
    const NAME: &'static str = "op_get_current_bot_user";
    const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
        {
            const LITERAL: &'static [u8] = "op_get_current_bot_user".as_bytes();
            const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                LITERAL,
            );
            let s: &'static ::deno_core::v8::OneByteConst = &STR;
            ("op_get_current_bot_user", ::deno_core::FastStaticString::new(s))
        },
        false,
        false,
        1usize as u8,
        Self::v8_fn_ptr as _,
        Self::v8_fn_ptr_metrics as _,
        None,
        None,
        ::deno_core::OpMetadata {
            ..::deno_core::OpMetadata::default()
        },
    );
}
impl op_get_current_bot_user {
    pub const fn name() -> &'static str {
        "op_get_current_bot_user"
    }
    #[deprecated(note = "Use the const op::DECL instead")]
    pub const fn decl() -> deno_core::_ops::OpDecl {
        <Self as deno_core::_ops::Op>::DECL
    }
    #[inline(always)]
    fn slow_function_impl(info: *const deno_core::v8::FunctionCallbackInfo) -> usize {
        #[cfg(debug_assertions)]
        let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
            &<Self as deno_core::_ops::Op>::DECL,
        );
        let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
        let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
            &*info
        });
        let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
            &*info
        });
        let opctx = unsafe {
            &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data()).value()
                as *const deno_core::_ops::OpCtx)
        };
        let opstate = &opctx.state;
        let result = {
            let arg0 = &mut ::std::cell::RefCell::borrow_mut(&opstate);
            Self::call(arg0)
        };
        match result {
            Ok(result) => {
                match deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                    deno_core::_ops::RustToV8Marker::<
                        deno_core::_ops::SerdeMarker,
                        _,
                    >::from(result),
                    &mut scope,
                ) {
                    Ok(v) => rv.set(v),
                    Err(rv_err) => {
                        let msg = deno_core::v8::String::new(
                                &mut scope,
                                &{
                                    let res = ::alloc::fmt::format(
                                        format_args!("{0}", deno_core::anyhow::Error::from(rv_err)),
                                    );
                                    res
                                },
                            )
                            .unwrap();
                        let exc = deno_core::v8::Exception::type_error(&mut scope, msg);
                        scope.throw_exception(exc);
                        return 1;
                    }
                }
            }
            Err(err) => {
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let err = err.into();
                let exception = deno_core::error::to_v8_error(
                    &mut scope,
                    opctx.get_error_class_fn,
                    &err,
                );
                scope.throw_exception(exception);
                return 1;
            }
        };
        return 0;
    }
    extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
        Self::slow_function_impl(info);
    }
    extern "C" fn v8_fn_ptr_metrics(info: *const deno_core::v8::FunctionCallbackInfo) {
        let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
            &*info
        });
        let opctx = unsafe {
            &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data()).value()
                as *const deno_core::_ops::OpCtx)
        };
        deno_core::_ops::dispatch_metrics_slow(
            &opctx,
            deno_core::_ops::OpMetricsEvent::Dispatched,
        );
        let res = Self::slow_function_impl(info);
        if res == 0 {
            deno_core::_ops::dispatch_metrics_slow(
                &opctx,
                deno_core::_ops::OpMetricsEvent::Completed,
            );
        } else {
            deno_core::_ops::dispatch_metrics_slow(
                &opctx,
                deno_core::_ops::OpMetricsEvent::Error,
            );
        }
    }
    #[inline(always)]
    pub fn call(
        state: &mut OpState,
    ) -> Result<runtime_models::internal::user::User, AnyError> {
        let ctx = state.borrow::<RuntimeContext>();
        Ok(ctx.discord_config.bot_user.clone().into())
    }
}
#[allow(non_camel_case_types)]
pub struct op_get_current_guild_id {
    _unconstructable: ::std::marker::PhantomData<()>,
}
impl ::deno_core::_ops::Op for op_get_current_guild_id {
    const NAME: &'static str = "op_get_current_guild_id";
    const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
        {
            const LITERAL: &'static [u8] = "op_get_current_guild_id".as_bytes();
            const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                LITERAL,
            );
            let s: &'static ::deno_core::v8::OneByteConst = &STR;
            ("op_get_current_guild_id", ::deno_core::FastStaticString::new(s))
        },
        false,
        false,
        1usize as u8,
        Self::v8_fn_ptr as _,
        Self::v8_fn_ptr_metrics as _,
        None,
        None,
        ::deno_core::OpMetadata {
            ..::deno_core::OpMetadata::default()
        },
    );
}
impl op_get_current_guild_id {
    pub const fn name() -> &'static str {
        "op_get_current_guild_id"
    }
    #[deprecated(note = "Use the const op::DECL instead")]
    pub const fn decl() -> deno_core::_ops::OpDecl {
        <Self as deno_core::_ops::Op>::DECL
    }
    #[inline(always)]
    fn slow_function_impl(info: *const deno_core::v8::FunctionCallbackInfo) -> usize {
        #[cfg(debug_assertions)]
        let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
            &<Self as deno_core::_ops::Op>::DECL,
        );
        let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
        let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
            &*info
        });
        let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
            &*info
        });
        let opctx = unsafe {
            &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data()).value()
                as *const deno_core::_ops::OpCtx)
        };
        let opstate = &opctx.state;
        let result = {
            let arg0 = &mut ::std::cell::RefCell::borrow_mut(&opstate);
            Self::call(arg0)
        };
        match result {
            Ok(result) => {
                match deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                    result,
                    &mut scope,
                ) {
                    Ok(v) => rv.set(v),
                    Err(rv_err) => {
                        let msg = deno_core::v8::String::new(
                                &mut scope,
                                &{
                                    let res = ::alloc::fmt::format(
                                        format_args!("{0}", deno_core::anyhow::Error::from(rv_err)),
                                    );
                                    res
                                },
                            )
                            .unwrap();
                        let exc = deno_core::v8::Exception::type_error(&mut scope, msg);
                        scope.throw_exception(exc);
                        return 1;
                    }
                }
            }
            Err(err) => {
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let err = err.into();
                let exception = deno_core::error::to_v8_error(
                    &mut scope,
                    opctx.get_error_class_fn,
                    &err,
                );
                scope.throw_exception(exception);
                return 1;
            }
        };
        return 0;
    }
    extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
        Self::slow_function_impl(info);
    }
    extern "C" fn v8_fn_ptr_metrics(info: *const deno_core::v8::FunctionCallbackInfo) {
        let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
            &*info
        });
        let opctx = unsafe {
            &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data()).value()
                as *const deno_core::_ops::OpCtx)
        };
        deno_core::_ops::dispatch_metrics_slow(
            &opctx,
            deno_core::_ops::OpMetricsEvent::Dispatched,
        );
        let res = Self::slow_function_impl(info);
        if res == 0 {
            deno_core::_ops::dispatch_metrics_slow(
                &opctx,
                deno_core::_ops::OpMetricsEvent::Completed,
            );
        } else {
            deno_core::_ops::dispatch_metrics_slow(
                &opctx,
                deno_core::_ops::OpMetricsEvent::Error,
            );
        }
    }
    #[inline(always)]
    pub fn call(state: &mut OpState) -> Result<String, AnyError> {
        let ctx = state.borrow::<RuntimeContext>();
        Ok(ctx.guild_id.to_string())
    }
}
#[allow(non_camel_case_types)]
pub struct op_get_run_mode {
    _unconstructable: ::std::marker::PhantomData<()>,
}
impl ::deno_core::_ops::Op for op_get_run_mode {
    const NAME: &'static str = "op_get_run_mode";
    const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
        {
            const LITERAL: &'static [u8] = "op_get_run_mode".as_bytes();
            const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                LITERAL,
            );
            let s: &'static ::deno_core::v8::OneByteConst = &STR;
            ("op_get_run_mode", ::deno_core::FastStaticString::new(s))
        },
        false,
        false,
        1usize as u8,
        Self::v8_fn_ptr as _,
        Self::v8_fn_ptr_metrics as _,
        None,
        None,
        ::deno_core::OpMetadata {
            ..::deno_core::OpMetadata::default()
        },
    );
}
impl op_get_run_mode {
    pub const fn name() -> &'static str {
        "op_get_run_mode"
    }
    #[deprecated(note = "Use the const op::DECL instead")]
    pub const fn decl() -> deno_core::_ops::OpDecl {
        <Self as deno_core::_ops::Op>::DECL
    }
    #[inline(always)]
    fn slow_function_impl(info: *const deno_core::v8::FunctionCallbackInfo) -> usize {
        #[cfg(debug_assertions)]
        let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
            &<Self as deno_core::_ops::Op>::DECL,
        );
        let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
        let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
            &*info
        });
        let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
            &*info
        });
        let opctx = unsafe {
            &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data()).value()
                as *const deno_core::_ops::OpCtx)
        };
        let opstate = &opctx.state;
        let result = {
            let arg0 = &mut ::std::cell::RefCell::borrow_mut(&opstate);
            Self::call(arg0)
        };
        match deno_core::_ops::RustToV8Fallible::to_v8_fallible(result, &mut scope) {
            Ok(v) => rv.set(v),
            Err(rv_err) => {
                let msg = deno_core::v8::String::new(
                        &mut scope,
                        &{
                            let res = ::alloc::fmt::format(
                                format_args!("{0}", deno_core::anyhow::Error::from(rv_err)),
                            );
                            res
                        },
                    )
                    .unwrap();
                let exc = deno_core::v8::Exception::type_error(&mut scope, msg);
                scope.throw_exception(exc);
                return 1;
            }
        };
        return 0;
    }
    extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
        Self::slow_function_impl(info);
    }
    extern "C" fn v8_fn_ptr_metrics(info: *const deno_core::v8::FunctionCallbackInfo) {
        let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
            &*info
        });
        let opctx = unsafe {
            &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data()).value()
                as *const deno_core::_ops::OpCtx)
        };
        deno_core::_ops::dispatch_metrics_slow(
            &opctx,
            deno_core::_ops::OpMetricsEvent::Dispatched,
        );
        let res = Self::slow_function_impl(info);
        if res == 0 {
            deno_core::_ops::dispatch_metrics_slow(
                &opctx,
                deno_core::_ops::OpMetricsEvent::Completed,
            );
        } else {
            deno_core::_ops::dispatch_metrics_slow(
                &opctx,
                deno_core::_ops::OpMetricsEvent::Error,
            );
        }
    }
    #[inline(always)]
    pub fn call(state: &mut OpState) -> String {
        if state.has::<RuntimeContext>() {
            "normal".to_string()
        } else {
            "validation".to_string()
        }
    }
}
#[allow(non_camel_case_types)]
pub struct op_botloader_script_start {
    _unconstructable: ::std::marker::PhantomData<()>,
}
impl ::deno_core::_ops::Op for op_botloader_script_start {
    const NAME: &'static str = "op_botloader_script_start";
    const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
        {
            const LITERAL: &'static [u8] = "op_botloader_script_start".as_bytes();
            const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                LITERAL,
            );
            let s: &'static ::deno_core::v8::OneByteConst = &STR;
            ("op_botloader_script_start", ::deno_core::FastStaticString::new(s))
        },
        false,
        false,
        2usize as u8,
        Self::v8_fn_ptr as _,
        Self::v8_fn_ptr_metrics as _,
        None,
        None,
        ::deno_core::OpMetadata {
            ..::deno_core::OpMetadata::default()
        },
    );
}
impl op_botloader_script_start {
    pub const fn name() -> &'static str {
        "op_botloader_script_start"
    }
    #[deprecated(note = "Use the const op::DECL instead")]
    pub const fn decl() -> deno_core::_ops::OpDecl {
        <Self as deno_core::_ops::Op>::DECL
    }
    #[inline(always)]
    fn slow_function_impl(info: *const deno_core::v8::FunctionCallbackInfo) -> usize {
        #[cfg(debug_assertions)]
        let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
            &<Self as deno_core::_ops::Op>::DECL,
        );
        let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
        let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
            &*info
        });
        let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
            &*info
        });
        let opctx = unsafe {
            &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data()).value()
                as *const deno_core::_ops::OpCtx)
        };
        let opstate = &opctx.state;
        let result = {
            let arg1 = args.get(0usize as i32);
            let arg1 = match deno_core::_ops::serde_v8_to_rust(&mut scope, arg1) {
                Ok(t) => t,
                Err(arg1_err) => {
                    let msg = deno_core::v8::String::new(
                            &mut scope,
                            &{
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "{0}",
                                        deno_core::anyhow::Error::from(arg1_err),
                                    ),
                                );
                                res
                            },
                        )
                        .unwrap();
                    let exc = deno_core::v8::Exception::type_error(&mut scope, msg);
                    scope.throw_exception(exc);
                    return 1;
                }
            };
            let arg0 = &mut ::std::cell::RefCell::borrow_mut(&opstate);
            Self::call(arg0, arg1)
        };
        match result {
            Ok(result) => deno_core::_ops::RustToV8RetVal::to_v8_rv(result, &mut rv),
            Err(err) => {
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let err = err.into();
                let exception = deno_core::error::to_v8_error(
                    &mut scope,
                    opctx.get_error_class_fn,
                    &err,
                );
                scope.throw_exception(exception);
                return 1;
            }
        };
        return 0;
    }
    extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
        Self::slow_function_impl(info);
    }
    extern "C" fn v8_fn_ptr_metrics(info: *const deno_core::v8::FunctionCallbackInfo) {
        let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
            &*info
        });
        let opctx = unsafe {
            &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data()).value()
                as *const deno_core::_ops::OpCtx)
        };
        deno_core::_ops::dispatch_metrics_slow(
            &opctx,
            deno_core::_ops::OpMetricsEvent::Dispatched,
        );
        let res = Self::slow_function_impl(info);
        if res == 0 {
            deno_core::_ops::dispatch_metrics_slow(
                &opctx,
                deno_core::_ops::OpMetricsEvent::Completed,
            );
        } else {
            deno_core::_ops::dispatch_metrics_slow(
                &opctx,
                deno_core::_ops::OpMetricsEvent::Error,
            );
        }
    }
    #[inline(always)]
    pub fn call(state: &mut OpState, args: JsValue) -> Result<(), AnyError> {
        let des: ScriptMeta = serde_json::from_value(args)?;
        {
            use ::tracing::__macro_support::Callsite as _;
            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "event components/runtime/src/lib.rs:219",
                        "runtime",
                        ::tracing::Level::INFO,
                        ::core::option::Option::Some("components/runtime/src/lib.rs"),
                        ::core::option::Option::Some(219u32),
                        ::core::option::Option::Some("runtime"),
                        ::tracing_core::field::FieldSet::new(
                            &["message"],
                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                        ),
                        ::tracing::metadata::Kind::EVENT,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let enabled = ::tracing::Level::INFO
                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::INFO
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    let interest = __CALLSITE.interest();
                    !interest.is_never()
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                };
            if enabled {
                (|value_set: ::tracing::field::ValueSet| {
                    let meta = __CALLSITE.metadata();
                    ::tracing::Event::dispatch(meta, &value_set);
                    if match ::tracing::Level::INFO {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                use ::tracing::log;
                                let level = match ::tracing::Level::INFO {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                };
                                if level <= log::max_level() {
                                    let meta = __CALLSITE.metadata();
                                    let log_meta = log::Metadata::builder()
                                        .level(level)
                                        .target(meta.target())
                                        .build();
                                    let logger = log::logger();
                                    if logger.enabled(&log_meta) {
                                        ::tracing::__macro_support::__tracing_log(
                                            meta,
                                            logger,
                                            log_meta,
                                            &value_set,
                                        )
                                    }
                                }
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                })({
                    #[allow(unused_imports)]
                    use ::tracing::field::{debug, display, Value};
                    let mut iter = __CALLSITE.metadata().fields().iter();
                    __CALLSITE
                        .metadata()
                        .fields()
                        .value_set(
                            &[
                                (
                                    &::core::iter::Iterator::next(&mut iter)
                                        .expect("FieldSet corrupted (this is a bug)"),
                                    ::core::option::Option::Some(
                                        &format_args!(
                                            "running script! {0}, commands: {1}",
                                            des.script_id.0,
                                            des.commands.len() + des.command_groups.len(),
                                        ) as &dyn Value,
                                    ),
                                ),
                            ],
                        )
                });
            } else {
                if match ::tracing::Level::INFO {
                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                    _ => ::tracing::log::Level::Trace,
                } <= ::tracing::log::STATIC_MAX_LEVEL
                {
                    if !::tracing::dispatcher::has_been_set() {
                        {
                            use ::tracing::log;
                            let level = match ::tracing::Level::INFO {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            };
                            if level <= log::max_level() {
                                let meta = __CALLSITE.metadata();
                                let log_meta = log::Metadata::builder()
                                    .level(level)
                                    .target(meta.target())
                                    .build();
                                let logger = log::logger();
                                if logger.enabled(&log_meta) {
                                    ::tracing::__macro_support::__tracing_log(
                                        meta,
                                        logger,
                                        log_meta,
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!(
                                                                    "running script! {0}, commands: {1}",
                                                                    des.script_id.0,
                                                                    des.commands.len() + des.command_groups.len(),
                                                                ) as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        },
                                    )
                                }
                            }
                        }
                    } else {
                        {}
                    }
                } else {
                    {}
                };
            }
        };
        let ctx = state.borrow::<RuntimeContext>();
        if let Err(err) = validate_script_meta(&des) {
            ctx.guild_logger
                .log(
                    CreateLogEntry::script_error(
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("script meta validation failed: {0}", err),
                            );
                            res
                        },
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("{0}", des.script_id),
                            );
                            res
                        },
                        None,
                    ),
                );
            return Err(err);
        }
        let _ = ctx.event_tx.send(RuntimeEvent::ScriptStarted(des));
        Ok(())
    }
}
#[allow(non_camel_case_types)]
pub struct op_get_settings {
    _unconstructable: ::std::marker::PhantomData<()>,
}
impl ::deno_core::_ops::Op for op_get_settings {
    const NAME: &'static str = "op_get_settings";
    const DECL: ::deno_core::_ops::OpDecl = ::deno_core::_ops::OpDecl::new_internal_op2(
        {
            const LITERAL: &'static [u8] = "op_get_settings".as_bytes();
            const STR: ::deno_core::v8::OneByteConst = ::deno_core::FastStaticString::create_external_onebyte_const(
                LITERAL,
            );
            let s: &'static ::deno_core::v8::OneByteConst = &STR;
            ("op_get_settings", ::deno_core::FastStaticString::new(s))
        },
        false,
        false,
        2usize as u8,
        Self::v8_fn_ptr as _,
        Self::v8_fn_ptr_metrics as _,
        None,
        None,
        ::deno_core::OpMetadata {
            ..::deno_core::OpMetadata::default()
        },
    );
}
impl op_get_settings {
    pub const fn name() -> &'static str {
        "op_get_settings"
    }
    #[deprecated(note = "Use the const op::DECL instead")]
    pub const fn decl() -> deno_core::_ops::OpDecl {
        <Self as deno_core::_ops::Op>::DECL
    }
    #[inline(always)]
    fn slow_function_impl(info: *const deno_core::v8::FunctionCallbackInfo) -> usize {
        #[cfg(debug_assertions)]
        let _reentrancy_check_guard = deno_core::_ops::reentrancy_check(
            &<Self as deno_core::_ops::Op>::DECL,
        );
        let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
        let mut rv = deno_core::v8::ReturnValue::from_function_callback_info(unsafe {
            &*info
        });
        let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
            &*info
        });
        let opctx = unsafe {
            &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data()).value()
                as *const deno_core::_ops::OpCtx)
        };
        let opstate = &opctx.state;
        let result = {
            let arg1 = args.get(0usize as i32);
            let Some(arg1) = deno_core::_ops::to_f64_option(&arg1) else {
                let mut scope = unsafe { deno_core::v8::CallbackScope::new(&*info) };
                let msg = deno_core::v8::String::new_from_one_byte(
                        &mut scope,
                        "expected f64".as_bytes(),
                        deno_core::v8::NewStringType::Normal,
                    )
                    .unwrap();
                let exc = deno_core::v8::Exception::type_error(&mut scope, msg);
                scope.throw_exception(exc);
                return 1;
            };
            let arg1 = arg1 as _;
            let arg0 = &mut ::std::cell::RefCell::borrow_mut(&opstate);
            Self::call(arg0, arg1)
        };
        match result {
            Ok(result) => {
                match deno_core::_ops::RustToV8Fallible::to_v8_fallible(
                    deno_core::_ops::RustToV8Marker::<
                        deno_core::_ops::SerdeMarker,
                        _,
                    >::from(result),
                    &mut scope,
                ) {
                    Ok(v) => rv.set(v),
                    Err(rv_err) => {
                        let msg = deno_core::v8::String::new(
                                &mut scope,
                                &{
                                    let res = ::alloc::fmt::format(
                                        format_args!("{0}", deno_core::anyhow::Error::from(rv_err)),
                                    );
                                    res
                                },
                            )
                            .unwrap();
                        let exc = deno_core::v8::Exception::type_error(&mut scope, msg);
                        scope.throw_exception(exc);
                        return 1;
                    }
                }
            }
            Err(err) => {
                let opctx = unsafe {
                    &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data())
                        .value() as *const deno_core::_ops::OpCtx)
                };
                let err = err.into();
                let exception = deno_core::error::to_v8_error(
                    &mut scope,
                    opctx.get_error_class_fn,
                    &err,
                );
                scope.throw_exception(exception);
                return 1;
            }
        };
        return 0;
    }
    extern "C" fn v8_fn_ptr(info: *const deno_core::v8::FunctionCallbackInfo) {
        Self::slow_function_impl(info);
    }
    extern "C" fn v8_fn_ptr_metrics(info: *const deno_core::v8::FunctionCallbackInfo) {
        let args = deno_core::v8::FunctionCallbackArguments::from_function_callback_info(unsafe {
            &*info
        });
        let opctx = unsafe {
            &*(deno_core::v8::Local::<deno_core::v8::External>::cast(args.data()).value()
                as *const deno_core::_ops::OpCtx)
        };
        deno_core::_ops::dispatch_metrics_slow(
            &opctx,
            deno_core::_ops::OpMetricsEvent::Dispatched,
        );
        let res = Self::slow_function_impl(info);
        if res == 0 {
            deno_core::_ops::dispatch_metrics_slow(
                &opctx,
                deno_core::_ops::OpMetricsEvent::Completed,
            );
        } else {
            deno_core::_ops::dispatch_metrics_slow(
                &opctx,
                deno_core::_ops::OpMetricsEvent::Error,
            );
        }
    }
    #[inline(always)]
    pub fn call(
        state: &mut OpState,
        script_id: u64,
    ) -> Result<Vec<SettingsOptionValue>, AnyError> {
        let core_ctx = state.borrow::<CoreRuntimeContext>();
        let Some(script_settings_entry) = core_ctx
            .settings_values
            .iter()
            .find(|v| v.script_id == script_id) else {
            return Ok(Vec::new());
        };
        Ok(script_settings_entry.settings_values.clone())
    }
}
pub(crate) fn validate_script_meta(meta: &ScriptMeta) -> Result<(), anyhow::Error> {
    let mut out_buf = String::new();
    for command in &meta.commands {
        if let Err(verrs) = validation::validate(command, &()) {
            for verr in verrs {
                out_buf
                    .push_str(
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("\ncommand {0}: {1}", command.name, verr),
                            );
                            res
                        }
                            .as_str(),
                    );
            }
        }
    }
    for group in &meta.command_groups {
        if let Err(verrs) = validation::validate(group, &()) {
            for verr in verrs {
                out_buf
                    .push_str(
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("\ncommand group {0}: {1}", group.name, verr),
                            );
                            res
                        }
                            .as_str(),
                    );
            }
        }
    }
    for option in &meta.settings {
        if let Err(validation_errors) = validation::validate(option, &()) {
            for error in validation_errors {
                out_buf
                    .push_str(
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("\nsettings options: {0}", error),
                            );
                            res
                        }
                            .as_str(),
                    );
            }
        }
    }
    if out_buf.is_empty() {
        Ok(())
    } else {
        Err(
            ::anyhow::Error::msg({
                let res = ::alloc::fmt::format(
                    format_args!("script validation failed: {0}", out_buf),
                );
                res
            }),
        )
    }
}
pub fn try_insert_resource_table<T: deno_core::Resource>(
    table: &mut ResourceTable,
    v: T,
) -> Result<ResourceId, AnyError> {
    let count = table.names().count();
    if count > 100 {
        return Err(
            ::anyhow::__private::must_use({
                let error = ::anyhow::__private::format_err(
                    format_args!(
                        "exhausted resource table limit, make sure to close your resources when you\'re done with them.",
                    ),
                );
                error
            }),
        );
    }
    Ok(table.add(v))
}
pub enum RuntimeEvent {
    ScriptStarted(ScriptMeta),
    NewTaskScheduled,
}
impl RuntimeEvent {
    pub fn span_name(&self) -> &'static str {
        match self {
            RuntimeEvent::ScriptStarted(_) => "RuntimeEvent::ScriptStarted",
            RuntimeEvent::NewTaskScheduled => "RuntimeEvent::NewTaskScheduled",
        }
    }
}
pub fn get_rt_ctx(state: &Rc<RefCell<OpState>>) -> RuntimeContext {
    let state = state.borrow();
    state.borrow::<RuntimeContext>().clone()
}
